<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>文章 on 音视频技术部</title>
    <link>https://wfeii.github.io/posts/</link>
    <description>Recent content in 文章 on 音视频技术部</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 02 Mar 2017 12:00:00 -0500</lastBuildDate>
    
	<atom:link href="https://wfeii.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>升级Gradle3.0</title>
      <link>https://wfeii.github.io/posts/_posts/android_studio/gradle/2017-11-21-%E5%8D%87%E7%BA%A7gradle3.0/</link>
      <pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_studio/gradle/2017-11-21-%E5%8D%87%E7%BA%A7gradle3.0/</guid>
      <description>{: .align-center}
概述 Android Gradle 3.0.0插件是一个大版本的升级，对多个module带来了显著的性能提升。但同时也改变了一些此插件的行为，DSL和APIS。
升级到Gradle3.0.0会带来以下的性能提升：
 由于构建per-call dexing提高了构建速度，每个类编译成独立的DEX文件，并且仅仅被修改的类重新编译。为了提高构建APK的速度，需要设置minSdkVersion到20，或者更低但使用 legacy multi-dex。 当改变依赖项时，Gradle通过不访问依赖项的API的module不重新编译的方式来提高构建速度。通过使用Gradle的新的依赖项的配置(implementation, api, compileOnly, and runtimeOnly)，可以严格的控制依赖项的API的暴露。  升级 配置Gradle版本 Android plugin 3.0.0 要求Gradle4.1或者更高的版本。
需要在gradle-wrapper.properties文件中配置下列的内容：
distributionUrl=\ https\://services.gradle.org/distributions/gradle-4.1-all.zip  配置Android Gradle Plugin 如果使用Android Studio 3.0或者更新版本，会提示自动更新到最新版本的Android plugin。对于手动更新工程，在工程级下的 build.gradle 配置如下的内容。
buildscript { repositories { ... // You need to add the following repository to download the  // new plugin.  google() } dependencies { classpath &amp;#39;com.android.tools.build:gradle:3.0.0&amp;#39; } }  NOTICE:
对于多模块和复合构建，如果Android插件每次构建不止一次加载，则可能会出现构建错误，可以查看常见错误进行修复。
 新的依赖配置接口 问题描述 要理解旧的Gradle插件2.</description>
    </item>
    
    <item>
      <title>升级Gradle3.0</title>
      <link>https://wfeii.github.io/posts/android_studio/gradle/2017-11-21-%E5%8D%87%E7%BA%A7gradle3.0/</link>
      <pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_studio/gradle/2017-11-21-%E5%8D%87%E7%BA%A7gradle3.0/</guid>
      <description>概述 Android Gradle 3.0.0插件是一个大版本的升级，对多个module带来了显著的性能提升。但同时也改变了一些此插件的行为，DSL和APIS.
升级到Gradle3.0.0会带来以下的性能提升：
 由于构建per-call dexing提高了构建速度，每个类编译成独立的DEX文件，并且仅仅被修改的类重新编译。为了提高构建APK的速度，需要设置minSdkVersion到20，或者更低但使用 legacy multi-dex。 当改变依赖项时，Gradle通过不访问依赖项的API的module不重新编译的方式来提高构建速度。通过使用Gradle的新的依赖项的配置(implementation, api, compileOnly, and runtimeOnly)，可以严格的控制依赖项的API的暴露。  升级 配置Gradle版本 Android plugin 3.0.0 要求Gradle4.1或者更高的版本。
需要在gradle-wrapper.properties文件中配置下列的内容：
distributionUrl=\ https\://services.gradle.org/distributions/gradle-4.1-all.zip  配置Android Gradle Plugin 如果使用Android Studio 3.0或者更新版本，会提示自动更新到最新版本的Android plugin。对于手动更新工程，在工程级下的 build.gradle 配置如下的内容。
buildscript { repositories { ... // You need to add the following repository to download the  // new plugin.  google() } dependencies { classpath &amp;#39;com.android.tools.build:gradle:3.0.0&amp;#39; } }  NOTICE:
对于多模块和复合构建，如果Android插件每次构建不止一次加载，则可能会出现构建错误，可以查看常见错误进行修复。
 新的依赖配置接口 问题描述 要理解旧的Gradle插件2.</description>
    </item>
    
    <item>
      <title>Android Log 分析</title>
      <link>https://wfeii.github.io/posts/_posts/android_base/logcat%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 04 Nov 2017 16:40:12 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/logcat%E5%88%86%E6%9E%90/</guid>
      <description>Bug在任何类型的开发中都会存在的，而Bug报告又是定位问题，解决问题的关键。
Bug报告中包含的内容：
 logcat文件以文字形式存储所有的log信息  main 包含了所有的log  system log 存储framework相关的log event log 进程的正在做的事情     dumpsys获取系统运行状态的信息，通过adb shell 可以获取想要的系统信息，内存使用情况的信息等等  Activity Manager的状态 - dumpsys activity  Package信息 - dumpsys package 内存使用情况 - dumpsys meminfo 进程一段时间内的内存使用情况 - dumpsys procstats 界面相关的状态 - dumpsys gfxinfo     dumpstate 系统运行状态的信息   常用命令 ： adb shell bugreport 获取logcat信息，dumpsys信息，dumpstate信息 adb shell logcat -v threadtime -d 获取logcat文件
 adb shell logcat -b events -v threadtime -d 获取events log</description>
    </item>
    
    <item>
      <title>Android Log 分析</title>
      <link>https://wfeii.github.io/posts/android_base/logcat%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 04 Nov 2017 16:40:12 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/logcat%E5%88%86%E6%9E%90/</guid>
      <description>Bug在任何类型的开发中都会存在的，而Bug报告又是定位问题，解决问题的关键。
Bug报告中包含的内容：
 logcat文件以文字形式存储所有的log信息  main 包含了所有的log  system log 存储framework相关的log event log 进程的正在做的事情     dumpsys获取系统运行状态的信息，通过adb shell 可以获取想要的系统信息，内存使用情况的信息等等  Activity Manager的状态 - dumpsys activity  Package信息 - dumpsys package 内存使用情况 - dumpsys meminfo 进程一段时间内的内存使用情况 - dumpsys procstats 界面相关的状态 - dumpsys gfxinfo     dumpstate 系统运行状态的信息   常用命令 ： adb shell bugreport 获取logcat信息，dumpsys信息，dumpstate信息 adb shell logcat -v threadtime -d 获取logcat文件
 adb shell logcat -b events -v threadtime -d 获取events log</description>
    </item>
    
    <item>
      <title>GC可达性实践-内存泄露分析</title>
      <link>https://wfeii.github.io/posts/2017-11-04-gc%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/2017-11-04-gc%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</guid>
      <description>概述 Java中的对象回收是通过GC，但是在回收之前需要知道哪些对象是可回收的，哪些对象是不可回收的。
常见的回收机制 引用计数算法 引用算法是在对象中添加引用计数器，每当有地方引用了此对象时候，引用计数加1，当引用失效时候引用计数器减1。没有任何地方引用此对象时候，说明此对象不再使用，可以被回收。常见的是C++中的智能指针使用了此算法。而Java中并未使用此算法，为什么呢？后面再回答吧。
可达性分析算法 在Java中判断是否可回收是通过可达性来判断的。可达性分析的基本思路是通过一系列的称为“GC ROOT”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC ROOT没有任何引用链时说明此对象可被回收。 例如： 由于A，B对象没有引用链，因此可以被回收。
 注 GC模型中的均为对象，而不是类。
 Java中的引用 现在Java语言中，引用分为强引用，软引用，弱引用，虚引用。
强引用在代码中普遍存在， 类似于“Object object = new Object”，只要强引用存在，GC不会回收被引用的对象。
软引用在代码中不常见，用于描述一些还有用但并非必需的对象。对于软引用关联的对象，Java中用SoftReference来实现的。
弱引用描述非必需的对象，只被弱引用关联的对象只能生存到下一次GC发生之前，一旦GC被触发，只被弱引用引用的对象都会被回收。Java中用WeakReference来实现。
Java中GC ROOT简易模型分析 A对象释放了C的引用后，C，D对象无引用链可以到达,因此C，D对象可以被回收。
 A对象释放对C对象的引用，然而GC ROOT -&amp;gt; A -&amp;gt; B -&amp;gt; C -&amp;gt; D，到C对象有引用链可达,到D对象有引用链子可达，所有没有对象可以被回收。
 A释放对B，C的引用，根据引用链到B，C，D都不可达，因此B，C，D对象均可回收。 如果使用的是引用计数算法呢？ 由于B，C，D相互引用，导致了各个对象的引用计数器都不为0，从而均不可回收，对于相互循环引用的对象，引用计数算法不能很好的解决.
 包含弱引用情况，如下图B弱引用C 当A释放C的引用，由于B是弱引用C，弱引用只会存在到GC发生之前，相当于无引用链可达，因此C，D对象会可被回收。
 Android内存泄露 AsyncTask的使用中会经常的直接Activity或者Fragment中创建匿名内部类来使用，这样很容易导致Activity或者Fragment的泄露。
 public class TaskLeakActivity extends AppCompatActivity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView textView = new TextView(this); textView.setText(&amp;quot;Task&amp;quot;); setContentView(textView); new AsyncTask&amp;lt;Void, Void, Void&amp;gt;() { @Override protected Void doInBackground(Void.</description>
    </item>
    
    <item>
      <title>GC可达性实践-内存泄露分析</title>
      <link>https://wfeii.github.io/posts/_posts/2017-11-04-gc%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/2017-11-04-gc%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</guid>
      <description>概述 Java中的对象回收是通过GC，但是在回收之前需要知道哪些对象是可回收的，哪些对象是不可回收的。
常见的回收机制 引用计数算法 引用算法是在对象中添加引用计数器，每当有地方引用了此对象时候，引用计数加1，当引用失效时候引用计数器减1。没有任何地方引用此对象时候，说明此对象不再使用，可以被回收。常见的是C++中的智能指针使用了此算法。而Java中并未使用此算法，为什么呢？后面再回答吧。
可达性分析算法 在Java中判断是否可回收是通过可达性来判断的。可达性分析的基本思路是通过一系列的称为“GC ROOT”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC ROOT没有任何引用链时说明此对象可被回收。 例如： 由于A，B对象没有引用链，因此可以被回收。
 注 GC模型中的均为对象，而不是类。
 Java中的引用 现在Java语言中，引用分为强引用，软引用，弱引用，虚引用。
强引用在代码中普遍存在， 类似于“Object object = new Object”，只要强引用存在，GC不会回收被引用的对象。
软引用在代码中不常见，用于描述一些还有用但并非必需的对象。对于软引用关联的对象，Java中用SoftReference来实现的。
弱引用描述非必需的对象，只被弱引用关联的对象只能生存到下一次GC发生之前，一旦GC被触发，只被弱引用引用的对象都会被回收。Java中用WeakReference来实现。
Java中GC ROOT简易模型分析 A对象释放了C的引用后，C，D对象无引用链可以到达,因此C，D对象可以被回收。
 A对象释放对C对象的引用，然而GC ROOT -&amp;gt; A -&amp;gt; B -&amp;gt; C -&amp;gt; D，到C对象有引用链可达,到D对象有引用链子可达，所有没有对象可以被回收。
 A释放对B，C的引用，根据引用链到B，C，D都不可达，因此B，C，D对象均可回收。 如果使用的是引用计数算法呢？ 由于B，C，D相互引用，导致了各个对象的引用计数器都不为0，从而均不可回收，对于相互循环引用的对象，引用计数算法不能很好的解决.
 包含弱引用情况，如下图B弱引用C 当A释放C的引用，由于B是弱引用C，弱引用只会存在到GC发生之前，相当于无引用链可达，因此C，D对象会可被回收。
 Android内存泄露 AsyncTask的使用中会经常的直接Activity或者Fragment中创建匿名内部类来使用，这样很容易导致Activity或者Fragment的泄露。
 public class TaskLeakActivity extends AppCompatActivity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView textView = new TextView(this); textView.setText(&amp;quot;Task&amp;quot;); setContentView(textView); new AsyncTask&amp;lt;Void, Void, Void&amp;gt;() { @Override protected Void doInBackground(Void.</description>
    </item>
    
    <item>
      <title>ImageLoader的设计</title>
      <link>https://wfeii.github.io/posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>ImageLoader解决的问题 分析源码之前我们需要知道ImageLoader为什么要出现，或者说ImageLoader是用来解决什么问题的。总结了一下几点:
 对于加载网络的图片是比较耗时的，而对于耗时的排序基本是 网络&amp;gt;磁盘&amp;gt;内存，因此我们需要尽量减少对于网络的请求次数，我们可以牺牲磁盘和内存来达到尽量减少网络请求的加载，这就是我们所说的三级缓存，先从内存获取，然后从磁盘获取，最后再从网络获取。所以ImageLoader需要对此问题给出解决方案。 图片本身会占用大量的内存，如何做到内存的优化？ImageLoader需要对此问题给出解决方案，基本的解决方案是  图片的大小压缩，对应于Bitmap就是其大小 图片的色彩压缩，对应于Bitmap就是像素的标识是565还是8888   对于加载图片需要在子线程中运行，如何合理的处理线程需要考虑 扩展性，对于此问题不实现也可以，但写出来的代码绝对不是好代码，因为无法扩展  显示的时候，对返回的Bitmap做处理，比如说我们需要倒圆角，圆形图，那ImageLoader是否可以给予支持，给用户更好的使用。(ImageLoader可以不给予实现，但是此实现会极大的提高ImageLoader的易用性)。 对于图片的加载，我们需要从网络加载，也可以从磁盘加载，而且网络加载是否可以引入其他的库比如HttpClient等等。如何做到这些呢？ImageLoader最好给予实现。   易用性，既然是库，给client使用时候就需要考虑  以Android-Universal-Image-Loader为例
Android-Universal-Image-Loader流程 ImageLoder对外充当高层接口，ImageLoaderEngine管理线程，而ImageDecoder和ImageDownloader用于加载图片，而BitmapDisplayer用于显示Bitmap到ImageView上。
对外接口结构 供客户端接口是通过Facade模式进行封装，把底层细节隐藏起来，提供给用户使用的是ImageLoader类和ImageLoaderConfiguraton类。客户端不需要涉及底层细节，提高易用性。
源码分析 下面以ImageLoader的displayImage为例，看看如何从网络获取图片，如何把图片设置到ImageView上。
 public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) { ...... // 获取控件大小，后面我们需要根据此来压缩图片 if (targetSize == null) { targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize()); } // 根据Uri生成一个key，这个key非常重要，在ListView中itemView复用的时候通过key识别 String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize); engine.prepareDisplayTaskFor(imageAware, memoryCacheKey); //现在先从memory中看是否能获取到。 Bitmap bmp = configuration.memoryCache.get(memoryCacheKey); if (bmp !</description>
    </item>
    
    <item>
      <title>ImageLoader的设计</title>
      <link>https://wfeii.github.io/posts/_posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>ImageLoader解决的问题 分析源码之前我们需要知道ImageLoader为什么要出现，或者说ImageLoader是用来解决什么问题的。总结了一下几点:
 对于加载网络的图片是比较耗时的，而对于耗时的排序基本是 网络&amp;gt;磁盘&amp;gt;内存，因此我们需要尽量减少对于网络的请求次数，我们可以牺牲磁盘和内存来达到尽量减少网络请求的加载，这就是我们所说的三级缓存，先从内存获取，然后从磁盘获取，最后再从网络获取。所以ImageLoader需要对此问题给出解决方案。 图片本身会占用大量的内存，如何做到内存的优化？ImageLoader需要对此问题给出解决方案，基本的解决方案是  图片的大小压缩，对应于Bitmap就是其大小 图片的色彩压缩，对应于Bitmap就是像素的标识是565还是8888   对于加载图片需要在子线程中运行，如何合理的处理线程需要考虑 扩展性，对于此问题不实现也可以，但写出来的代码绝对不是好代码，因为无法扩展  显示的时候，对返回的Bitmap做处理，比如说我们需要倒圆角，圆形图，那ImageLoader是否可以给予支持，给用户更好的使用。(ImageLoader可以不给予实现，但是此实现会极大的提高ImageLoader的易用性)。 对于图片的加载，我们需要从网络加载，也可以从磁盘加载，而且网络加载是否可以引入其他的库比如HttpClient等等。如何做到这些呢？ImageLoader最好给予实现。   易用性，既然是库，给client使用时候就需要考虑  以Android-Universal-Image-Loader为例
Android-Universal-Image-Loader流程 ImageLoder对外充当高层接口，ImageLoaderEngine管理线程，而ImageDecoder和ImageDownloader用于加载图片，而BitmapDisplayer用于显示Bitmap到ImageView上。
对外接口结构 供客户端接口是通过Facade模式进行封装，把底层细节隐藏起来，提供给用户使用的是ImageLoader类和ImageLoaderConfiguraton类。客户端不需要涉及底层细节，提高易用性。
源码分析 下面以ImageLoader的displayImage为例，看看如何从网络获取图片，如何把图片设置到ImageView上。
 public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) { ...... // 获取控件大小，后面我们需要根据此来压缩图片 if (targetSize == null) { targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize()); } // 根据Uri生成一个key，这个key非常重要，在ListView中itemView复用的时候通过key识别 String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize); engine.prepareDisplayTaskFor(imageAware, memoryCacheKey); //现在先从memory中看是否能获取到。 Bitmap bmp = configuration.memoryCache.get(memoryCacheKey); if (bmp !</description>
    </item>
    
    <item>
      <title>Volley传输网络数据</title>
      <link>https://wfeii.github.io/posts/2017-11-04-volley%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/2017-11-04-volley%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/</guid>
      <description>概述 Volley是一个HTTP的库，能够让Android Apps的网络请求更容易，更迅速。Vollery在github可以获取到。
Volley有以下优点：
 自动调度网络请求 多个并发的网络连接 标准的Http cache coherence 支持请求优先级 取消请求的API，可以取消简单的请求，也可以取消一组网络请求 可定制性，比如重试，重定向等 强大的排序，可以轻松地使用网络请求的数据正确的填充到UI上。 调试和跟踪的工具  Volley的优点在于使用RPC-type的操作来填充UI，比如获取到一页的搜索结果作为结构化的数据。它可以轻松地与任何协议集成，Volley自带了字符串，图片和JSON的支持。通过内嵌一些特性，Volley可以让你从模板的代码中摆脱出来，而只需关注App的特定的逻辑。
Volley不适合大型的下载或者流操作。因为Volley在解析的时候会把所有的响应保存到内存中，对于大型的下载操作，可以考虑使用DownloadManager。
Vollery核心库是在github上开发的，主要有请求分发以及一系列的通用的工具类，可以在Volley的工具箱中获取到。在项目中添加Volley最容易的方式是在gradle文件中添加以下内容。
dependencies { ... compile &amp;#39;com.android.volley:volley:1.0.0&amp;#39; } 你也可以克隆Volley仓库并且设置它作为一个library工程
  通过下列的命令来克隆Volley的仓库
git clone https://github.com/google/volley
  导入源码到你的app工程里作为Android library，在Create an Android Library查看如何创建Android library库。
  发送简单请求 更高层次上，可以创建一个RequestQueue传递给它Request对象。RequestQueue管理工作线程，这些工作线程用于运行网络请求，读写缓存和解析网络响应。Request解析原始的响应并且Volley分派解析后的响应返回到主线程中。
这节描述如何使用Volley.newRequestQueue方法发送请求，此方法设置一个RequestQueue供我们使用。看设置RequestQueue一节也可以了解如何自己设置RequestQueue。
这节描述如何使用RequestQueue去添加请求和取消请求。
添加网络权限 使用Volley，必须在manifest文件中添加android.permission.INTERNET权限。
使用newRequestQueue Volley提供了方便的方法Volley.newRequestQueue去创建RequestQueue，使用默认行为启动队列。例如：
final TextView mTextView = (TextView) findViewById(R.id.text); ... // Instantiate the RequestQueue. RequestQueue queue = Volley.newRequestQueue(this); String url =&amp;#34;http://www.google.com&amp;#34;; // Request a string response from the provided URL.</description>
    </item>
    
    <item>
      <title>Volley传输网络数据</title>
      <link>https://wfeii.github.io/posts/_posts/2017-11-04-volley%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/2017-11-04-volley%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/</guid>
      <description>概述 Volley是一个HTTP的库，能够让Android Apps的网络请求更容易，更迅速。Vollery在github可以获取到。
Volley有以下优点：
 自动调度网络请求 多个并发的网络连接 标准的Http cache coherence 支持请求优先级 取消请求的API，可以取消简单的请求，也可以取消一组网络请求 可定制性，比如重试，重定向等 强大的排序，可以轻松地使用网络请求的数据正确的填充到UI上。 调试和跟踪的工具  Volley的优点在于使用RPC-type的操作来填充UI，比如获取到一页的搜索结果作为结构化的数据。它可以轻松地与任何协议集成，Volley自带了字符串，图片和JSON的支持。通过内嵌一些特性，Volley可以让你从模板的代码中摆脱出来，而只需关注App的特定的逻辑。
Volley不适合大型的下载或者流操作。因为Volley在解析的时候会把所有的响应保存到内存中，对于大型的下载操作，可以考虑使用DownloadManager。
Vollery核心库是在github上开发的，主要有请求分发以及一系列的通用的工具类，可以在Volley的工具箱中获取到。在项目中添加Volley最容易的方式是在gradle文件中添加以下内容。
dependencies { ... compile &amp;#39;com.android.volley:volley:1.0.0&amp;#39; } 你也可以克隆Volley仓库并且设置它作为一个library工程
  通过下列的命令来克隆Volley的仓库
git clone https://github.com/google/volley
  导入源码到你的app工程里作为Android library，在Create an Android Library查看如何创建Android library库。
  发送简单请求 更高层次上，可以创建一个RequestQueue传递给它Request对象。RequestQueue管理工作线程，这些工作线程用于运行网络请求，读写缓存和解析网络响应。Request解析原始的响应并且Volley分派解析后的响应返回到主线程中。
这节描述如何使用Volley.newRequestQueue方法发送请求，此方法设置一个RequestQueue供我们使用。看设置RequestQueue一节也可以了解如何自己设置RequestQueue。
这节描述如何使用RequestQueue去添加请求和取消请求。
添加网络权限 使用Volley，必须在manifest文件中添加android.permission.INTERNET权限。
使用newRequestQueue Volley提供了方便的方法Volley.newRequestQueue去创建RequestQueue，使用默认行为启动队列。例如：
final TextView mTextView = (TextView) findViewById(R.id.text); ... // Instantiate the RequestQueue. RequestQueue queue = Volley.newRequestQueue(this); String url =&amp;#34;http://www.google.com&amp;#34;; // Request a string response from the provided URL.</description>
    </item>
    
    <item>
      <title>高效实用Android Studio (一)</title>
      <link>https://wfeii.github.io/posts/_posts/android_studio/2017-11-04-%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8android-studio-%E4%B8%80/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_studio/2017-11-04-%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8android-studio-%E4%B8%80/</guid>
      <description>{: .align-center}
快捷键 设置Preferences -&amp;gt; Keymap 设置快捷键，可以修改，或者添加keymap等等。
常用快捷键，每个系统及其设置不同，这里只是说出对应的名称，这样就可以直接搜索来查找快捷键。
 Run 运行安装APK Find  Find 在本文件内查找 2. Find in Path 在工程中查找 3. Find Usages 查找引用   Rename 重命名 Sync Project with Gradle Files 同步Gradle Generate 生成代码或者字段的get或者set方法等等 File Structure 查看类的方法等 Type Hierarchy 查看继承关系 Editor Tabs  Select Next Tab 选择下一个编辑窗口 Select Previous Tab 选择上一个编辑窗口 close 关闭一个编辑窗口 close Others 关闭其他窗口 close All 关闭所有的窗口    代码格式 设置Tab的信息，Use tab character,未勾选将会使用空格代替Tab。 经常的我们会有设置类的字段的命名m开头，我们就可以在Code Style -&amp;gt; Java -&amp;gt; Code Generation路径下，使用Name Prefix设置前缀，也可以使用Name suffix也可以设置后缀。 设置文件的特定内容，比如作者等等。可以设置自己的代码风格。 技巧 设置Live Templates，添加模板代码。  添加并勾选 设置abbreviation，当输入的时候会有补全，输入完成就会有响应的代码生成 设置描述 设置代码的内容 设置什么时候会提醒，根据自己的需要设置相关的功能  </description>
    </item>
    
    <item>
      <title>高效实用Android Studio (一)</title>
      <link>https://wfeii.github.io/posts/android_studio/2017-11-04-%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8android-studio-%E4%B8%80/</link>
      <pubDate>Sat, 04 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_studio/2017-11-04-%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8android-studio-%E4%B8%80/</guid>
      <description>{: .align-center}
快捷键 设置Preferences -&amp;gt; Keymap 设置快捷键，可以修改，或者添加keymap等等。
常用快捷键，每个系统及其设置不同，这里只是说出对应的名称，这样就可以直接搜索来查找快捷键。
 Run 运行安装APK Find  Find 在本文件内查找 2. Find in Path 在工程中查找 3. Find Usages 查找引用   Rename 重命名 Sync Project with Gradle Files 同步Gradle Generate 生成代码或者字段的get或者set方法等等 File Structure 查看类的方法等 Type Hierarchy 查看继承关系 Editor Tabs  Select Next Tab 选择下一个编辑窗口 Select Previous Tab 选择上一个编辑窗口 close 关闭一个编辑窗口 close Others 关闭其他窗口 close All 关闭所有的窗口    代码格式 设置Tab的信息，Use tab character,未勾选将会使用空格代替Tab。 经常的我们会有设置类的字段的命名m开头，我们就可以在Code Style -&amp;gt; Java -&amp;gt; Code Generation路径下，使用Name Prefix设置前缀，也可以使用Name suffix也可以设置后缀。 设置文件的特定内容，比如作者等等。可以设置自己的代码风格。 技巧 设置Live Templates，添加模板代码。  添加并勾选 设置abbreviation，当输入的时候会有补全，输入完成就会有响应的代码生成 设置描述 设置代码的内容 设置什么时候会提醒，根据自己的需要设置相关的功能  </description>
    </item>
    
    <item>
      <title>重构原则</title>
      <link>https://wfeii.github.io/posts/_posts/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/2016-08-30-%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/</link>
      <pubDate>Tue, 30 Aug 2016 21:27:50 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/2016-08-30-%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/</guid>
      <description>{: .align-center}
何谓重构  重构 ： 对软件内部结构的一种调整，目的是在不改变软件可观察性的前提下，提高其可理解性，降低其修改的成本 。
 其实重构是在不改变代码的功能基础上，提高代码的可读性，提高代码的扩展性。
两顶帽子
添加新功能，重构。在软件开发中，两种情况不断变换，首先可能尝试添加新功能，其次意识到： 结构调整一下，功能更容易添加。于是就做一次重构，结构调整好之后，继续添加新功能，发现问题又会重构，就这样迭代。
 Notice: 在做新功能时候，不能只为添加新功能而添加新功能，需要保持代码的结构性，易读性。
 为何重构   重构改进软件设计
没有重构，程序的设计可能逐渐的不可控，程序的机构性会遭到破坏，代码的可读性也会降低。代码机构的流失是累积的，越难看出代码的设计意图，就越难保护其设计，代码的设计腐败的越快，代码的可控性就严重降低。 通过重构可以让所有的代码回归的到本身应该在的位置。重构帮助代码维持该有的设计。   重构使软件更容易理解
引用一句话，我觉得很恰当
 连傻子都能写出让机器机能运行的代码，但优秀的代码却是能让人理解的。
 程序设计很大程度上是跟计算机交流，但是除了跟计算机交流之外最重要的交流对象是人，写的连鬼都看不懂的代码，让人看个鬼，过了一段时间自己都看不懂自己写的代码就真是见了鬼了（这种情况比见到鬼容易多了，哈哈哈）。通过重构可以保证代码的可读性，而且通过重构可以更好的理解不熟悉的代码。
重构的开始可能只提留在细枝末节上。随着代码的简化，我们可以看到一些一些一切看不到的设计的层面的问题，有前辈把“早期重构”描述为“擦掉窗户上的污垢，使你看的更远”。如果没有重构，达不到这种层次。   重构帮助找到bug
对于代码的理解，可以帮助找到bug。通过重构更深入的理解代码的结构、行为，从而找到隐藏很深的bug。
 我不是一个伟大的程序员，我只是个有着一些优秀习惯的程序员 - Kent Beck
   提高编程速度
  良好的设计是快速开发的根本，拥有良好的设计才能快速的开发。如果没有良好的设计，或许一段时间内你的进展迅速，但恶劣的设计很快就让你的速度慢下来。会有大量的时间去调试，理解代码的逻辑，寻找重复的代码。最终坏的代码带来大的灾难。
重构一定程度提高了代码的扩展性，保持了代码良好的结构，添加新功能也就容易点。
何时重构  你不应该为了重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把事情做好。
 三次法则
 事不过三，三则重构
 出现了代码重复，说明需要重构了。
添加新功能时重构
 通过重构可以更好的理解代码的逻辑，理清代码的结构，更好的添加新功能。 代码的设计无法帮助我们轻松的添加想要的功能时候，就需要重构来更好的添加新功能。  修复bug时候
收到bug但是不能一眼看出bug的问题，很大程度说明代码的逻辑不够清楚，需要重构了。
复审代码时重构 复审者提出好的建议，然后一起探讨一些修改能否通过重构轻松实现，如果是这样，一起着手修改，这样保证了代码的质量
为什么重构有用
程序有两方面的价值
 今天可以为你做什么 明天可以为你做什么 我们都只关注今天想要程序做什么。修复bug,添加新功能，我们都是为了让程序能力更强，让它今天更有价值。如果为了今天的工作不择手段，导致不可能在明天完成任务，最终还是失败。重构是摆脱这个困境的道路。如果发现昨天的决定已经不能适应今天的情况，放心改变这个决定就是，然后就可以完成今天的决定，日复一日。  是什么程序难以修改</description>
    </item>
    
    <item>
      <title>重构原则</title>
      <link>https://wfeii.github.io/posts/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/2016-08-30-%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/</link>
      <pubDate>Tue, 30 Aug 2016 21:27:50 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/2016-08-30-%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/</guid>
      <description>{: .align-center}
何谓重构  重构 ： 对软件内部结构的一种调整，目的是在不改变软件可观察性的前提下，提高其可理解性，降低其修改的成本 。
 其实重构是在不改变代码的功能基础上，提高代码的可读性，提高代码的扩展性。
两顶帽子
添加新功能，重构。在软件开发中，两种情况不断变换，首先可能尝试添加新功能，其次意识到： 结构调整一下，功能更容易添加。于是就做一次重构，结构调整好之后，继续添加新功能，发现问题又会重构，就这样迭代。
 Notice: 在做新功能时候，不能只为添加新功能而添加新功能，需要保持代码的结构性，易读性。
 为何重构   重构改进软件设计
没有重构，程序的设计可能逐渐的不可控，程序的机构性会遭到破坏，代码的可读性也会降低。代码机构的流失是累积的，越难看出代码的设计意图，就越难保护其设计，代码的设计腐败的越快，代码的可控性就严重降低。 通过重构可以让所有的代码回归的到本身应该在的位置。重构帮助代码维持该有的设计。   重构使软件更容易理解
引用一句话，我觉得很恰当
 连傻子都能写出让机器机能运行的代码，但优秀的代码却是能让人理解的。
 程序设计很大程度上是跟计算机交流，但是除了跟计算机交流之外最重要的交流对象是人，写的连鬼都看不懂的代码，让人看个鬼，过了一段时间自己都看不懂自己写的代码就真是见了鬼了（这种情况比见到鬼容易多了，哈哈哈）。通过重构可以保证代码的可读性，而且通过重构可以更好的理解不熟悉的代码。
重构的开始可能只提留在细枝末节上。随着代码的简化，我们可以看到一些一些一切看不到的设计的层面的问题，有前辈把“早期重构”描述为“擦掉窗户上的污垢，使你看的更远”。如果没有重构，达不到这种层次。   重构帮助找到bug
对于代码的理解，可以帮助找到bug。通过重构更深入的理解代码的结构、行为，从而找到隐藏很深的bug。
 我不是一个伟大的程序员，我只是个有着一些优秀习惯的程序员 - Kent Beck
   提高编程速度
  良好的设计是快速开发的根本，拥有良好的设计才能快速的开发。如果没有良好的设计，或许一段时间内你的进展迅速，但恶劣的设计很快就让你的速度慢下来。会有大量的时间去调试，理解代码的逻辑，寻找重复的代码。最终坏的代码带来大的灾难。
重构一定程度提高了代码的扩展性，保持了代码良好的结构，添加新功能也就容易点。
何时重构  你不应该为了重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把事情做好。
 三次法则
 事不过三，三则重构
 出现了代码重复，说明需要重构了。
添加新功能时重构
 通过重构可以更好的理解代码的逻辑，理清代码的结构，更好的添加新功能。 代码的设计无法帮助我们轻松的添加想要的功能时候，就需要重构来更好的添加新功能。  修复bug时候
收到bug但是不能一眼看出bug的问题，很大程度说明代码的逻辑不够清楚，需要重构了。
复审代码时重构 复审者提出好的建议，然后一起探讨一些修改能否通过重构轻松实现，如果是这样，一起着手修改，这样保证了代码的质量
为什么重构有用
程序有两方面的价值
 今天可以为你做什么 明天可以为你做什么 我们都只关注今天想要程序做什么。修复bug,添加新功能，我们都是为了让程序能力更强，让它今天更有价值。如果为了今天的工作不择手段，导致不可能在明天完成任务，最终还是失败。重构是摆脱这个困境的道路。如果发现昨天的决定已经不能适应今天的情况，放心改变这个决定就是，然后就可以完成今天的决定，日复一日。  是什么程序难以修改</description>
    </item>
    
    <item>
      <title>UI优化</title>
      <link>https://wfeii.github.io/posts/_posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 06 Aug 2016 16:40:12 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/</guid>
      <description>概述 总结来源与Google发布的性能优化的视频 Android Performance Patterns 和 Android Performance Optimizing Apps for Speed and Usability 对于用户感到卡顿,不流畅的原因有很多,比如Layout层级结构过深,动画过多,界面刷新,等等导致了CPU或者GPU的负担过重,16ms内无法完成一帧的绘制,导致了掉帧,从而表现出卡顿,不流畅.
绘制原理 为了更好的理解UI优化,在此之前先要说明一下硬件的基础.
VSYNC 两个概念 :
 Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的参数，例如60Hz。 Frame Rate：代表了GPU在一秒内绘制的帧数,例如60fps。  GPU获取图形数据绘制,然后硬件负责把绘制的内容显示再屏幕上,二者协调正常.
如果帧速率高于屏幕刷新速率,就会出现撕裂的现象,一部分显示当前的帧,一部分显示现在的帧,这种解决的方案就是双缓冲机制,GPU将帧写进存储器被成为back buffer,而存储器的次级区域成为frame buffer,当写入一帧时,它会开始填充back buffer,而framen buffer保持不变,现在刷新屏幕,使用frame buffer进行绘制,刷新屏幕,vsync触发,也会把back buffer复制到fragme buffer. 更具体的内容参考: Graphics
如果屏幕刷新速率高于帧速率时,就会导致屏幕显示还是上一帧的内容,从而出现卡顿,动画不流畅等现象
一帧画面绘制过程 了解了VSYNC的原理,下面该考虑应用程序是如何把画面绘制到屏幕上的了?或者是如何把XML文件转换成用户能够看到并理解的图像的?
其实这个过程的核心就是进行光栅化(rasterization)的处理过程.这个过程就是把一些高级的对象,比如字符串,形状等转换成屏幕上纹理中的像素点.光栅化是一个非常耗时的过程.正因如此,手机硬件上有一个特殊的部分用于提高光栅化的过程,叫做图像处理器,或者说GPU. 图像绘制到屏幕上首先在CPU上转换成多边形或者纹理,然后再传递到GPU进行光栅化处理,处理UI对象并转化成多边形和纹理并不是很快的操作,同样从CPU传递给GPU也不是那么快,这行就想办法较少UI对象转换的数量,和提交到GPU的数量,OpenGL ES API允许你将内容传递到GPU,并保存到GPU中,当以后再次绘制一个按钮的时候,只需要参考GPU内存中的已经存在的纹理.
渲染优化,尽可能多且快的将更多的数据上传到GPU,然后留在GPU中,尽可能长的时间里不去修改.每次更新GPU中的资源,你将会失去宝贵的处理时间.
下面说明什么时候会导致GPU资源更新. Android把xml语言转化成GPU能够识别的资源从而渲染到屏幕上,是通过Display List来实现的,一个Display List对象中基本上包含了所有GPU需要的渲染信息,Display List中包含了GPU可能需要的常用的资源列表,同时也包含了Open GL命令列表.
在某个视图第一次需要被渲染时,Display List就会被创建,当视图需要显示在屏幕时,会执行GPU的相关指令来进行渲染.
从上图可以看出
 只是View属性改变时,只是参考GPU内存中的已经存在,然后执行相关Open GL进行渲染, InvaliDated View也不会重新创建Display List View 布局改变,比如可见性,大小等  优化点 概述 渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。 对于CPU,应该尽量减少布局的层级深度,CPU减少measure等操作的时间,而对于GPU主要是减少不必要的过度绘制.
过度绘制 过度绘制是指同一帧内一个像素点绘制了多次,通过查看overdraw(开发者选项-&amp;gt; 调试GPU过度绘制) 颜色代表了像素点过度绘制的次数:</description>
    </item>
    
    <item>
      <title>UI优化</title>
      <link>https://wfeii.github.io/posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 06 Aug 2016 16:40:12 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/</guid>
      <description>概述 总结来源与Google发布的性能优化的视频 Android Performance Patterns 和 Android Performance Optimizing Apps for Speed and Usability 对于用户感到卡顿,不流畅的原因有很多,比如Layout层级结构过深,动画过多,界面刷新,等等导致了CPU或者GPU的负担过重,16ms内无法完成一帧的绘制,导致了掉帧,从而表现出卡顿,不流畅.
绘制原理 为了更好的理解UI优化,在此之前先要说明一下硬件的基础.
VSYNC 两个概念 :
 Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的参数，例如60Hz。 Frame Rate：代表了GPU在一秒内绘制的帧数,例如60fps。  GPU获取图形数据绘制,然后硬件负责把绘制的内容显示再屏幕上,二者协调正常.
如果帧速率高于屏幕刷新速率,就会出现撕裂的现象,一部分显示当前的帧,一部分显示现在的帧,这种解决的方案就是双缓冲机制,GPU将帧写进存储器被成为back buffer,而存储器的次级区域成为frame buffer,当写入一帧时,它会开始填充back buffer,而framen buffer保持不变,现在刷新屏幕,使用frame buffer进行绘制,刷新屏幕,vsync触发,也会把back buffer复制到fragme buffer. 更具体的内容参考: Graphics
如果屏幕刷新速率高于帧速率时,就会导致屏幕显示还是上一帧的内容,从而出现卡顿,动画不流畅等现象
一帧画面绘制过程 了解了VSYNC的原理,下面该考虑应用程序是如何把画面绘制到屏幕上的了?或者是如何把XML文件转换成用户能够看到并理解的图像的?
其实这个过程的核心就是进行光栅化(rasterization)的处理过程.这个过程就是把一些高级的对象,比如字符串,形状等转换成屏幕上纹理中的像素点.光栅化是一个非常耗时的过程.正因如此,手机硬件上有一个特殊的部分用于提高光栅化的过程,叫做图像处理器,或者说GPU. 图像绘制到屏幕上首先在CPU上转换成多边形或者纹理,然后再传递到GPU进行光栅化处理,处理UI对象并转化成多边形和纹理并不是很快的操作,同样从CPU传递给GPU也不是那么快,这行就想办法较少UI对象转换的数量,和提交到GPU的数量,OpenGL ES API允许你将内容传递到GPU,并保存到GPU中,当以后再次绘制一个按钮的时候,只需要参考GPU内存中的已经存在的纹理.
渲染优化,尽可能多且快的将更多的数据上传到GPU,然后留在GPU中,尽可能长的时间里不去修改.每次更新GPU中的资源,你将会失去宝贵的处理时间.
下面说明什么时候会导致GPU资源更新. Android把xml语言转化成GPU能够识别的资源从而渲染到屏幕上,是通过Display List来实现的,一个Display List对象中基本上包含了所有GPU需要的渲染信息,Display List中包含了GPU可能需要的常用的资源列表,同时也包含了Open GL命令列表.
在某个视图第一次需要被渲染时,Display List就会被创建,当视图需要显示在屏幕时,会执行GPU的相关指令来进行渲染.
从上图可以看出
 只是View属性改变时,只是参考GPU内存中的已经存在,然后执行相关Open GL进行渲染, InvaliDated View也不会重新创建Display List View 布局改变,比如可见性,大小等  优化点 概述 渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。 对于CPU,应该尽量减少布局的层级深度,CPU减少measure等操作的时间,而对于GPU主要是减少不必要的过度绘制.
过度绘制 过度绘制是指同一帧内一个像素点绘制了多次,通过查看overdraw(开发者选项-&amp;gt; 调试GPU过度绘制) 颜色代表了像素点过度绘制的次数:</description>
    </item>
    
    <item>
      <title>知识框架</title>
      <link>https://wfeii.github.io/posts/2016-07-30-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 30 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/2016-07-30-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</guid>
      <description>{: .align-center}
内功心法 算法 框架 重构 外功招式 Android Android基础 Android进阶 Android性能 Java 前端 实践 开源框架 </description>
    </item>
    
    <item>
      <title>知识框架</title>
      <link>https://wfeii.github.io/posts/_posts/2016-07-30-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 30 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/2016-07-30-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</guid>
      <description>{: .align-center}
内功心法 算法 框架 重构 外功招式 Android Android基础 Android进阶 Android性能 Java 前端 实践 开源框架 </description>
    </item>
    
    <item>
      <title>Android事件传递机制</title>
      <link>https://wfeii.github.io/posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 28 Jul 2016 16:40:12 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>Touch事件处理 Activity中的Touch事件处理函数 有touch事件来的时候,会调用Activity的dispatchTouchEvent()派发事件,然后会调用getWindow().superDispatchTouchEvent(ev)派发事件,最终会调用布局中的View.
public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 如果View中没有消耗事件,最后会调用Activity的onTouchEvent()处理.
View的Touch事件处理 View的Touch事件处理特性  View中的Touch事件一个是View控件的Touch事件处理,一个是ViewGroup控件的Touch事件处理,二者处理方式有所不同 View的Touch事件处理是先有子View控件处理,子View控件没有消耗,然后有父View控件进行处理. 对于ViewGroup控件可以通过相关的方法拦截Touch事件 View中的Touch事件处理会先调用dispatchTouchEvent()分发,然后调用onTouch()处理,未处理会调用onTouchEvent()处理.View控件还是ViewGroup控件处理逻辑都是一致  View控件的Touch事件处理. View处理Touch事件时首先被调用的是dispatchTouchEvent(),此方法的主要工作是调用恰当的方法进行处理.
public boolean dispatchTouchEvent(MotionEvent event) { ... ListenerInfo li = mListenerInfo; if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;amp;&amp;amp; onTouchEvent(event)) { result = true; } } .</description>
    </item>
    
    <item>
      <title>Android事件传递机制</title>
      <link>https://wfeii.github.io/posts/_posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 28 Jul 2016 16:40:12 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>Touch事件处理 Activity中的Touch事件处理函数 有touch事件来的时候,会调用Activity的dispatchTouchEvent()派发事件,然后会调用getWindow().superDispatchTouchEvent(ev)派发事件,最终会调用布局中的View.
public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 如果View中没有消耗事件,最后会调用Activity的onTouchEvent()处理.
View的Touch事件处理 View的Touch事件处理特性  View中的Touch事件一个是View控件的Touch事件处理,一个是ViewGroup控件的Touch事件处理,二者处理方式有所不同 View的Touch事件处理是先有子View控件处理,子View控件没有消耗,然后有父View控件进行处理. 对于ViewGroup控件可以通过相关的方法拦截Touch事件 View中的Touch事件处理会先调用dispatchTouchEvent()分发,然后调用onTouch()处理,未处理会调用onTouchEvent()处理.View控件还是ViewGroup控件处理逻辑都是一致  View控件的Touch事件处理. View处理Touch事件时首先被调用的是dispatchTouchEvent(),此方法的主要工作是调用恰当的方法进行处理.
public boolean dispatchTouchEvent(MotionEvent event) { ... ListenerInfo li = mListenerInfo; if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;amp;&amp;amp; onTouchEvent(event)) { result = true; } } .</description>
    </item>
    
    <item>
      <title>事务</title>
      <link>https://wfeii.github.io/posts/_posts/database/2016-05-07-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sat, 07 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/database/2016-05-07-%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;事务定义了一组SQL命令的边界, 这组命令作为一个整体被全部执行,或者都不执行,这被称为数据库完整性的原子性原则.事务和锁在数据库操作中密切相关,数据操作总是在事务中执行,事务又涉及到锁,如果控制不当,会导致很多问题.所以我们应该看懂自己写的代码并能指出事务的状态,或者至少能够发现潜在问题.&lt;/p&gt;
&lt;h2 id=&#34;事务的范围&#34;&gt;事务的范围&lt;/h2&gt;
&lt;p&gt;事务由3个命令控制:begin, commit和rollback, begin开始一个事务, begin之后的所有操作都可以被取消. commit提交事务开始后的所有执行的操作, rollback 还原begin之后的所有操作.
默认情况下, SQLite中每条语句自成事务. 也就是SQLite默认每条单独的SQLu\语句就是begin &amp;hellip; commit/rollback的事务.这种情况下, 所有成功完成的命令自动提交.同样遇到错误命令都会回滚.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>事务</title>
      <link>https://wfeii.github.io/posts/database/2016-05-07-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sat, 07 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/database/2016-05-07-%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;事务定义了一组SQL命令的边界, 这组命令作为一个整体被全部执行,或者都不执行,这被称为数据库完整性的原子性原则.事务和锁在数据库操作中密切相关,数据操作总是在事务中执行,事务又涉及到锁,如果控制不当,会导致很多问题.所以我们应该看懂自己写的代码并能指出事务的状态,或者至少能够发现潜在问题.&lt;/p&gt;
&lt;h2 id=&#34;事务的范围&#34;&gt;事务的范围&lt;/h2&gt;
&lt;p&gt;事务由3个命令控制:begin, commit和rollback, begin开始一个事务, begin之后的所有操作都可以被取消. commit提交事务开始后的所有执行的操作, rollback 还原begin之后的所有操作.
默认情况下, SQLite中每条语句自成事务. 也就是SQLite默认每条单独的SQLu\语句就是begin &amp;hellip; commit/rollback的事务.这种情况下, 所有成功完成的命令自动提交.同样遇到错误命令都会回滚.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ContentProvider</title>
      <link>https://wfeii.github.io/posts/_posts/android_base/content-provider/2014-11-08-contentprovider/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/content-provider/2014-11-08-contentprovider/</guid>
      <description>什么是Android中的Content Provider Content Provider是用于管理访问结构化数据集的一种组件，最经常管理数据集是数据库。content provider会封装数据，提供数据安全的机制。content provider用于一个进程与另一个运行中的进程的数据连接。 Notice:
当不打算共享数据给其他应用时，不需要定义自己的Content Provider.
Content Provider如何表示数据的呢？ Content Provider呈现数据是通过一个或多个表，类似与数据库，使用Content Provider跟使用数据库相类似。
如何访问Content Povider? Content Provider的访问很简单
 定义Uri 获取ContentResolver对象 使用ContentResolver对象进行相关的操作。 配置访问时要求的权限  如何定义Uri，以及Uri到底是做什么用的？ Uri是URI的引用，URI是Uniform Resource Identifier(统一资源标识符)简称，用于标识某一资源名称的, 组成形式：协议://authority／path。
ContentResolver使用的Uri是用于标识内容提供者的数据，组成形式：content://authority/path如果使用Content Provider共享的数据是数据库，那么path就是操作的table
/*填入要操作的数据的内容提供者的字符串*/ Uri uri = Uri.parse(&amp;quot; &amp;quot;); ContentResolver能够进行哪些相关的操作 可能（这里使用可能是因为要看Content Provider具体实现，也许访问的Content Provider只支持其中部分操作）支持的操作如下：
 insert delete update query  如何insert插入数据？ 可以像这样：
{% highlight ruby %} /1. 定义要操作的Uri（记得初始化）/ Uri mUri; /2. 定义ContentValues对象，用于保存要插入的数据/ ContentValues contentValues= new ContentValues(); contentValues.put(); contentValues.pust(); &amp;hellip; /3 获取ContentResolver对象/ ContentResolver resolver = getContentResolver(); /4 插入数据/ resolver.</description>
    </item>
    
    <item>
      <title>ContentProvider</title>
      <link>https://wfeii.github.io/posts/android_base/content-provider/2014-11-08-contentprovider/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/content-provider/2014-11-08-contentprovider/</guid>
      <description>什么是Android中的Content Provider Content Provider是用于管理访问结构化数据集的一种组件，最经常管理数据集是数据库。content provider会封装数据，提供数据安全的机制。content provider用于一个进程与另一个运行中的进程的数据连接。 Notice:
当不打算共享数据给其他应用时，不需要定义自己的Content Provider.
Content Provider如何表示数据的呢？ Content Provider呈现数据是通过一个或多个表，类似与数据库，使用Content Provider跟使用数据库相类似。
如何访问Content Povider? Content Provider的访问很简单
 定义Uri 获取ContentResolver对象 使用ContentResolver对象进行相关的操作。 配置访问时要求的权限  如何定义Uri，以及Uri到底是做什么用的？ Uri是URI的引用，URI是Uniform Resource Identifier(统一资源标识符)简称，用于标识某一资源名称的, 组成形式：协议://authority／path。
ContentResolver使用的Uri是用于标识内容提供者的数据，组成形式：content://authority/path如果使用Content Provider共享的数据是数据库，那么path就是操作的table
/*填入要操作的数据的内容提供者的字符串*/ Uri uri = Uri.parse(&amp;quot; &amp;quot;); ContentResolver能够进行哪些相关的操作 可能（这里使用可能是因为要看Content Provider具体实现，也许访问的Content Provider只支持其中部分操作）支持的操作如下：
 insert delete update query  如何insert插入数据？ 可以像这样：
{% highlight ruby %} /1. 定义要操作的Uri（记得初始化）/ Uri mUri; /2. 定义ContentValues对象，用于保存要插入的数据/ ContentValues contentValues= new ContentValues(); contentValues.put(); contentValues.pust(); &amp;hellip; /3 获取ContentResolver对象/ ContentResolver resolver = getContentResolver(); /4 插入数据/ resolver.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://wfeii.github.io/posts/_posts/android_base/server/2014-10-31-services/</link>
      <pubDate>Sun, 10 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/server/2014-10-31-services/</guid>
      <description>基础 什么是Android中的Serice？ Service是一个长期运行在后台不提供用户界面的组件。
Service听起来像是一个线程，它们有什么区别？  线程独立主线程（UI线程）之外，而Service可以运行在主线程（默认情况下)中，也可以不在其中。 线程一旦被启动，只有满足相应的条件才能停止，而Service开启，可以通过stopService()或者unbindService()来停止。  Service如何启动呢？   started ： 在组件(例如activity)中调用startService()，一旦启动将会长时间运行在后台，通常started的服务用于执行单个操作并且不需要返回结果给开启者。例如下载，当完成下载，应该调用stopSelf()方法&amp;quot;自杀&amp;rdquo;。 bound : 在组件中调用bindService()方法，bound的服务允许组件发送请求，获取结果，甚至可以进行进程间通信（IPC）,当service没有被绑定时，service对象将会被销毁。    Notice: service默认运行在主进程的主线程中，这就意味着如果service要处理耗时操作或者阻塞操作(例如Map3播放，联网，蓝牙连接），应该在服务中开启工作线程来做这些工作，通过这种方式可以减少应用无响应(Application Not Responding ANR)的发生。
 Started Service 如何定义Started Service呢？ 继承Service或者IntentService
在manifest文件中配置Service
&amp;lt;manifest ... &amp;gt; ... &amp;lt;application ... &amp;gt; &amp;lt;service android:name=&amp;quot;....&amp;quot; /&amp;gt; ... &amp;lt;/application&amp;gt; &amp;lt;/manifest&amp;gt; Service和IntentService怎么选择使用哪一个呢？  对于单个操作可以使用IntentService，IntentService开启一个工作线程，
当onHandlentent()函数执行完毕，service就会自杀，部分源码是这样的  	private final class ServiceHandler extends Handler { @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); //处理完操作就会自杀， stopSelf(msg.arg1); } }  较复杂逻辑的要继承Service来完成了。 IntentService使用比较简单只需实现onHandlentent()方法。  继承Service应该覆写哪些方法呢？ 所以要覆写三个方法。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://wfeii.github.io/posts/android_base/server/2014-10-31-services/</link>
      <pubDate>Sun, 10 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/server/2014-10-31-services/</guid>
      <description>基础 什么是Android中的Serice？ Service是一个长期运行在后台不提供用户界面的组件。
Service听起来像是一个线程，它们有什么区别？  线程独立主线程（UI线程）之外，而Service可以运行在主线程（默认情况下)中，也可以不在其中。 线程一旦被启动，只有满足相应的条件才能停止，而Service开启，可以通过stopService()或者unbindService()来停止。  Service如何启动呢？   started ： 在组件(例如activity)中调用startService()，一旦启动将会长时间运行在后台，通常started的服务用于执行单个操作并且不需要返回结果给开启者。例如下载，当完成下载，应该调用stopSelf()方法&amp;quot;自杀&amp;rdquo;。 bound : 在组件中调用bindService()方法，bound的服务允许组件发送请求，获取结果，甚至可以进行进程间通信（IPC）,当service没有被绑定时，service对象将会被销毁。    Notice: service默认运行在主进程的主线程中，这就意味着如果service要处理耗时操作或者阻塞操作(例如Map3播放，联网，蓝牙连接），应该在服务中开启工作线程来做这些工作，通过这种方式可以减少应用无响应(Application Not Responding ANR)的发生。
 Started Service 如何定义Started Service呢？ 继承Service或者IntentService
在manifest文件中配置Service
&amp;lt;manifest ... &amp;gt; ... &amp;lt;application ... &amp;gt; &amp;lt;service android:name=&amp;quot;....&amp;quot; /&amp;gt; ... &amp;lt;/application&amp;gt; &amp;lt;/manifest&amp;gt; Service和IntentService怎么选择使用哪一个呢？  对于单个操作可以使用IntentService，IntentService开启一个工作线程，
当onHandlentent()函数执行完毕，service就会自杀，部分源码是这样的  	private final class ServiceHandler extends Handler { @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); //处理完操作就会自杀， stopSelf(msg.arg1); } }  较复杂逻辑的要继承Service来完成了。 IntentService使用比较简单只需实现onHandlentent()方法。  继承Service应该覆写哪些方法呢？ 所以要覆写三个方法。</description>
    </item>
    
    <item>
      <title>Bound Services</title>
      <link>https://wfeii.github.io/posts/_posts/android_base/server/2014-11-01-boundservices/</link>
      <pubDate>Sat, 20 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/server/2014-11-01-boundservices/</guid>
      <description>&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;
&lt;h4 id=&#34;如何绑定service&#34;&gt;如何绑定service?&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;创建一个bound service&lt;/li&gt;
&lt;li&gt;在组件中调用bindService()方法进行绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何创建一个bound-service呢&#34;&gt;如何创建一个bound Service呢？&lt;/h4&gt;
&lt;p&gt;继承Service，用于绑定的类，首先，必须提供一个IBinder用于与客户端(例如Activity)&lt;br&gt;
交互,有三种方式可以提供此IBinder,每一种方式又有不同的实现方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承Binder(实现了IBinder)类&lt;/li&gt;
&lt;li&gt;使用Messenger&lt;/li&gt;
&lt;li&gt;使用AIDL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其次是在onBind()中返回IBinder&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**Notice:**多个clients连接到service时，只在第一次绑定时调用onBind()方法获取&lt;br&gt;
IBinder对象，对于其他的clients，系统直接传递一个IBinder，不会再调&lt;br&gt;
用onBind()方法.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Bound Services</title>
      <link>https://wfeii.github.io/posts/android_base/server/2014-11-01-boundservices/</link>
      <pubDate>Sat, 20 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/server/2014-11-01-boundservices/</guid>
      <description>&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;
&lt;h4 id=&#34;如何绑定service&#34;&gt;如何绑定service?&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;创建一个bound service&lt;/li&gt;
&lt;li&gt;在组件中调用bindService()方法进行绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何创建一个bound-service呢&#34;&gt;如何创建一个bound Service呢？&lt;/h4&gt;
&lt;p&gt;继承Service，用于绑定的类，首先，必须提供一个IBinder用于与客户端(例如Activity)&lt;br&gt;
交互,有三种方式可以提供此IBinder,每一种方式又有不同的实现方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承Binder(实现了IBinder)类&lt;/li&gt;
&lt;li&gt;使用Messenger&lt;/li&gt;
&lt;li&gt;使用AIDL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其次是在onBind()中返回IBinder&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**Notice:**多个clients连接到service时，只在第一次绑定时调用onBind()方法获取&lt;br&gt;
IBinder对象，对于其他的clients，系统直接传递一个IBinder，不会再调&lt;br&gt;
用onBind()方法.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Brodcast</title>
      <link>https://wfeii.github.io/posts/_posts/android_base/broadcast/2014-11-03-brodcast/</link>
      <pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/broadcast/2014-11-03-brodcast/</guid>
      <description>基础 什么是android中的广播? 广播就是在Android系统中发生某件事情（电量，电话的来电与去电等等），然后会向android系统中发送消息的组件
Android系统中发生某件事情，怎么向android系统中发送消息呢？ 有两种方式，一个通过发送正常的广播，sendBroadcast(),或者发送有序广播，sendOrderedBroadcast()。
发送正常的广播（也可称为无序广播）和发送有序广播有什么区别呢？  正常广播(也可称为无序广播)：所有接受者都可同时接受到广播，更加的高效，但是接受者不能取消广播。 有序广播:一次只能传递给一个接受者（根据android:priority，）上一级接收者可以传送数据给下一级，并且可以中止广播 。  ** Notice: 有序广播的接受是根据属性中priority来判断优先级的，对于优先级越高，越较早接收到广播，相同的优先级，会根据AndroidManfiest.xml中的顺序调用。**
如何使用广播呢?  定义广播接收器,继承自BroadcastReceiver或其子类，覆写onReceive()方法。 注册定义的广播接收器。  如何注册定义的广播接收者呢？  使用代码注册  //监听的广播的动作 IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_ON); //注册广播接收者 registerReceiver(new ScreenonReceiver(), filter); // 在AndroidManifest.xml中配置 &amp;lt;receiver android:name=&amp;quot;com.broadcast.ScreenonReceiver&amp;quot; android:enabled=&amp;quot;true&amp;quot;&amp;gt; &amp;lt;intent-filter &amp;gt; &amp;lt;action android:name=&amp;quot;android.intent.action.SCREEN_ON&amp;quot;/&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/receiver&amp;gt;  Notice: 使用在AndroidManifest.xml中配置的方式，必须指定android:enabled=&amp;quot;true&amp;quot;否则可能导致接收不到广播。
Skill: 最好不要使用AndroidManifest.xml中配置，一般的使用场景是开启service在Service中注册广播接收者，因为这样可以方便的取消注册，可控性比较好。
 常用广播的接受 开机启动的广播接收 ** Intent.ACTION_BOOT_COMPLETED ** 监听此动作的权限：
	RECEIVE_BOOT_COMPLETED 屏幕唤醒的广播接收 监听的广播的动作为:Intent.ACTION_SCREEN_ON
屏幕关闭的广播接收 监听的广播的动作为:Intent.ACTION_SCREEN_OFF
来电广播的接收 监听的广播的动作为: android.intent.action.PHONE_STATE
监听此动作时要加权限，READ_PHONE_STATE
去电广播的接收 监听的广播的动作为: Intent.ACTION_NEW_OUTGOING_CALL 所要求的权限READ_PHONE_STATE，PROCESS_OUTGOING_CALLS</description>
    </item>
    
    <item>
      <title>Brodcast</title>
      <link>https://wfeii.github.io/posts/android_base/broadcast/2014-11-03-brodcast/</link>
      <pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/broadcast/2014-11-03-brodcast/</guid>
      <description>基础 什么是android中的广播? 广播就是在Android系统中发生某件事情（电量，电话的来电与去电等等），然后会向android系统中发送消息的组件
Android系统中发生某件事情，怎么向android系统中发送消息呢？ 有两种方式，一个通过发送正常的广播，sendBroadcast(),或者发送有序广播，sendOrderedBroadcast()。
发送正常的广播（也可称为无序广播）和发送有序广播有什么区别呢？  正常广播(也可称为无序广播)：所有接受者都可同时接受到广播，更加的高效，但是接受者不能取消广播。 有序广播:一次只能传递给一个接受者（根据android:priority，）上一级接收者可以传送数据给下一级，并且可以中止广播 。  ** Notice: 有序广播的接受是根据属性中priority来判断优先级的，对于优先级越高，越较早接收到广播，相同的优先级，会根据AndroidManfiest.xml中的顺序调用。**
如何使用广播呢?  定义广播接收器,继承自BroadcastReceiver或其子类，覆写onReceive()方法。 注册定义的广播接收器。  如何注册定义的广播接收者呢？  使用代码注册  //监听的广播的动作 IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_ON); //注册广播接收者 registerReceiver(new ScreenonReceiver(), filter); // 在AndroidManifest.xml中配置 &amp;lt;receiver android:name=&amp;quot;com.broadcast.ScreenonReceiver&amp;quot; android:enabled=&amp;quot;true&amp;quot;&amp;gt; &amp;lt;intent-filter &amp;gt; &amp;lt;action android:name=&amp;quot;android.intent.action.SCREEN_ON&amp;quot;/&amp;gt; &amp;lt;/intent-filter&amp;gt; &amp;lt;/receiver&amp;gt;  Notice: 使用在AndroidManifest.xml中配置的方式，必须指定android:enabled=&amp;quot;true&amp;quot;否则可能导致接收不到广播。
Skill: 最好不要使用AndroidManifest.xml中配置，一般的使用场景是开启service在Service中注册广播接收者，因为这样可以方便的取消注册，可控性比较好。
 常用广播的接受 开机启动的广播接收 ** Intent.ACTION_BOOT_COMPLETED ** 监听此动作的权限：
	RECEIVE_BOOT_COMPLETED 屏幕唤醒的广播接收 监听的广播的动作为:Intent.ACTION_SCREEN_ON
屏幕关闭的广播接收 监听的广播的动作为:Intent.ACTION_SCREEN_OFF
来电广播的接收 监听的广播的动作为: android.intent.action.PHONE_STATE
监听此动作时要加权限，READ_PHONE_STATE
去电广播的接收 监听的广播的动作为: Intent.ACTION_NEW_OUTGOING_CALL 所要求的权限READ_PHONE_STATE，PROCESS_OUTGOING_CALLS</description>
    </item>
    
    <item>
      <title>Fragment Usage</title>
      <link>https://wfeii.github.io/posts/_posts/android_base/activity/2014-11-25-fragment/</link>
      <pubDate>Sat, 30 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/activity/2014-11-25-fragment/</guid>
      <description>&lt;h3 id=&#34;使用fragment实现代码与布局的复用&#34;&gt;使用Fragment实现代码与布局的复用&lt;/h3&gt;
&lt;p&gt;源码是 &lt;strong&gt;&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample&#34;&gt;Androidbase / Fragment / FragmentExample /&lt;/a&gt;&lt;/strong&gt; 中的&lt;strong&gt;DynamicFragment&lt;/strong&gt;相关的代码。&lt;/p&gt;
&lt;p&gt;实现的效果：在手机中处理title与content显示在不同的界面,在平板中左边显示title,右边显示content。&lt;br&gt;
&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/fragments.png&#34;&gt;查看效果图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现的思路： 在手机中加载的布局和平板加载的布局肯定不同，要分别定义不同的布局。在手机中点击title，跳转到另一界面显示content，可以使用两个fragment分别让activity关联。在平板中不涉及界面的跳转，可以在布局文件中使用**&amp;lt;fragment&amp;gt;**标签来定义。&lt;/p&gt;
&lt;p&gt;实现的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义不同的布局，在本例中定义了两个布局文件activity_dynamic_fragment,一个是在layout中定义（用于手机使用）,一个是layout-large中定义(用于平板)。&lt;/li&gt;
&lt;li&gt;定义title的fragment和content的fragment&lt;/li&gt;
&lt;li&gt;在Activity的onCreate()方法中content相关的view是否存在，不存在就是手机设备要把title的fragment加到activity中。&lt;/li&gt;
&lt;li&gt;title点击处理使用了回调的方式，手机的处理方式是添加content的fragment,而平板的处理方式是获取content的fragment来更新。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Fragment Usage</title>
      <link>https://wfeii.github.io/posts/android_base/activity/2014-11-25-fragment/</link>
      <pubDate>Sat, 30 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/activity/2014-11-25-fragment/</guid>
      <description>&lt;h3 id=&#34;使用fragment实现代码与布局的复用&#34;&gt;使用Fragment实现代码与布局的复用&lt;/h3&gt;
&lt;p&gt;源码是 &lt;strong&gt;&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample&#34;&gt;Androidbase / Fragment / FragmentExample /&lt;/a&gt;&lt;/strong&gt; 中的&lt;strong&gt;DynamicFragment&lt;/strong&gt;相关的代码。&lt;/p&gt;
&lt;p&gt;实现的效果：在手机中处理title与content显示在不同的界面,在平板中左边显示title,右边显示content。&lt;br&gt;
&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/fragments.png&#34;&gt;查看效果图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现的思路： 在手机中加载的布局和平板加载的布局肯定不同，要分别定义不同的布局。在手机中点击title，跳转到另一界面显示content，可以使用两个fragment分别让activity关联。在平板中不涉及界面的跳转，可以在布局文件中使用**&amp;lt;fragment&amp;gt;**标签来定义。&lt;/p&gt;
&lt;p&gt;实现的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义不同的布局，在本例中定义了两个布局文件activity_dynamic_fragment,一个是在layout中定义（用于手机使用）,一个是layout-large中定义(用于平板)。&lt;/li&gt;
&lt;li&gt;定义title的fragment和content的fragment&lt;/li&gt;
&lt;li&gt;在Activity的onCreate()方法中content相关的view是否存在，不存在就是手机设备要把title的fragment加到activity中。&lt;/li&gt;
&lt;li&gt;title点击处理使用了回调的方式，手机的处理方式是添加content的fragment,而平板的处理方式是获取content的fragment来更新。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Fragment</title>
      <link>https://wfeii.github.io/posts/_posts/android_base/activity/2014-11-18-fragment/</link>
      <pubDate>Thu, 28 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/activity/2014-11-18-fragment/</guid>
      <description>&lt;h3 id=&#34;什么是fragment&#34;&gt;什么是Fragment？&lt;/h3&gt;
&lt;p&gt;Fragment不是Activity，但是需要内嵌到Activtiy中，Fragment不是容器（viewGroup或者其子类），通常Fragment创建ViewGroup.&lt;br&gt;
Fragment代表的是一种行为或者Activity的用户界面的一部分。&lt;/p&gt;
&lt;h3 id=&#34;为什么要使用fragment呢&#34;&gt;为什么要使用Fragment呢？&lt;/h3&gt;
&lt;p&gt;Android是在3.0时引入的Fragment，为了更好的支持大屏幕设备（平板）。使用Fragment来封装UI和Java代码，提高了复用性。&lt;/p&gt;
&lt;h3 id=&#34;什么时候使用fragment呢&#34;&gt;什么时候使用Fragment呢？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;逻辑共享：不同设备和屏幕尺寸之间共享UI和逻辑，通常用于平板电脑&lt;/li&gt;
&lt;li&gt;回退导航：把fragment添加到堆栈中，当回退时，就会出栈，这种实现方式避免了activity的重建&lt;/li&gt;
&lt;li&gt;整体滑动的效果：与ViewPager一起使用实现整体滑动的效果&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Fragment</title>
      <link>https://wfeii.github.io/posts/android_base/activity/2014-11-18-fragment/</link>
      <pubDate>Thu, 28 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/activity/2014-11-18-fragment/</guid>
      <description>&lt;h3 id=&#34;什么是fragment&#34;&gt;什么是Fragment？&lt;/h3&gt;
&lt;p&gt;Fragment不是Activity，但是需要内嵌到Activtiy中，Fragment不是容器（viewGroup或者其子类），通常Fragment创建ViewGroup.&lt;br&gt;
Fragment代表的是一种行为或者Activity的用户界面的一部分。&lt;/p&gt;
&lt;h3 id=&#34;为什么要使用fragment呢&#34;&gt;为什么要使用Fragment呢？&lt;/h3&gt;
&lt;p&gt;Android是在3.0时引入的Fragment，为了更好的支持大屏幕设备（平板）。使用Fragment来封装UI和Java代码，提高了复用性。&lt;/p&gt;
&lt;h3 id=&#34;什么时候使用fragment呢&#34;&gt;什么时候使用Fragment呢？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;逻辑共享：不同设备和屏幕尺寸之间共享UI和逻辑，通常用于平板电脑&lt;/li&gt;
&lt;li&gt;回退导航：把fragment添加到堆栈中，当回退时，就会出栈，这种实现方式避免了activity的重建&lt;/li&gt;
&lt;li&gt;整体滑动的效果：与ViewPager一起使用实现整体滑动的效果&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Activity</title>
      <link>https://wfeii.github.io/posts/_posts/android_base/activity/2014-10-30-activity/</link>
      <pubDate>Thu, 07 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/android_base/activity/2014-10-30-activity/</guid>
      <description>&lt;h3 id=&#34;创建activity&#34;&gt;创建Activity&lt;/h3&gt;
&lt;h4 id=&#34;什么是android中的activity&#34;&gt;什么是Android中的Activity？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;一个activity是提供一个界面，用于与用户交互（打电话，发邮件等）的应用组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;如何创建一个activity呢&#34;&gt;如何创建一个Activity呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在layout中定义个布局文件&lt;/li&gt;
&lt;li&gt;定义一个Activity（或者已存在的Activity子类）的子类，并实现相关的方法.&lt;/li&gt;
&lt;li&gt;在AndroidManifest.xml中配置Activity&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;定义一个activity子类时要实现哪些方法呢&#34;&gt;定义一个Activity子类时，要实现哪些方法呢&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;onCreate(): 你必须实现这个方法，系统会在创建activity时，调用此方法，在这个方法中初始化的activity重要部分，尤其是调用setContentView()使用资源资源来设置activity的界面。&lt;/li&gt;
&lt;li&gt;onPause(): 当用户将要离开activity时，系统调用的第一方法就是此方法，通常保存在当前会话中的变化的信息。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wangfei1991.github.io/Blog/android%E5%9F%BA%E7%A1%80/2014/10/30/activity/#activity-7&#34;&gt;更多的activity信息请看管理生命周期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Activity</title>
      <link>https://wfeii.github.io/posts/android_base/activity/2014-10-30-activity/</link>
      <pubDate>Thu, 07 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/android_base/activity/2014-10-30-activity/</guid>
      <description>&lt;h3 id=&#34;创建activity&#34;&gt;创建Activity&lt;/h3&gt;
&lt;h4 id=&#34;什么是android中的activity&#34;&gt;什么是Android中的Activity？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;一个activity是提供一个界面，用于与用户交互（打电话，发邮件等）的应用组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;如何创建一个activity呢&#34;&gt;如何创建一个Activity呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在layout中定义个布局文件&lt;/li&gt;
&lt;li&gt;定义一个Activity（或者已存在的Activity子类）的子类，并实现相关的方法.&lt;/li&gt;
&lt;li&gt;在AndroidManifest.xml中配置Activity&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;定义一个activity子类时要实现哪些方法呢&#34;&gt;定义一个Activity子类时，要实现哪些方法呢&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;onCreate(): 你必须实现这个方法，系统会在创建activity时，调用此方法，在这个方法中初始化的activity重要部分，尤其是调用setContentView()使用资源资源来设置activity的界面。&lt;/li&gt;
&lt;li&gt;onPause(): 当用户将要离开activity时，系统调用的第一方法就是此方法，通常保存在当前会话中的变化的信息。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wangfei1991.github.io/Blog/android%E5%9F%BA%E7%A1%80/2014/10/30/activity/#activity-7&#34;&gt;更多的activity信息请看管理生命周期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>menu和action bar</title>
      <link>https://wfeii.github.io/posts/_posts/ui/2014-11-25-menuandactionbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/ui/2014-11-25-menuandactionbar/</guid>
      <description>从android3.0开始传统的6-items的菜单被action bar的形式所取代，在这篇文章中，将使用action bar方式实现menu，并且使用的是支持库的方式，这样可以解决版本兼容问题。
三种菜单类型  options menu context menu popup menu  如何定义menu  在res/menu/下使用xml中定义menu item, 代码中填充菜单 直接在代码中创建menu，添加menu条目   NOTICE： 最好使用menu资源来定义menu items
   It&amp;rsquo;s easier to visualize the menu structure in XML. It separates the content for the menu from your application&amp;rsquo;s behavioral code. It allows you to create alternative menu configurations for different platform versions, screen sizes, and other configurations by leveraging the app resources framework.   下面就是不同类型menu的创建方式</description>
    </item>
    
    <item>
      <title>menu和action bar</title>
      <link>https://wfeii.github.io/posts/ui/2014-11-25-menuandactionbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/ui/2014-11-25-menuandactionbar/</guid>
      <description>从android3.0开始传统的6-items的菜单被action bar的形式所取代，在这篇文章中，将使用action bar方式实现menu，并且使用的是支持库的方式，这样可以解决版本兼容问题。
三种菜单类型  options menu context menu popup menu  如何定义menu  在res/menu/下使用xml中定义menu item, 代码中填充菜单 直接在代码中创建menu，添加menu条目   NOTICE： 最好使用menu资源来定义menu items
   It&amp;rsquo;s easier to visualize the menu structure in XML. It separates the content for the menu from your application&amp;rsquo;s behavioral code. It allows you to create alternative menu configurations for different platform versions, screen sizes, and other configurations by leveraging the app resources framework.   下面就是不同类型menu的创建方式</description>
    </item>
    
    <item>
      <title>menu和actionbar</title>
      <link>https://wfeii.github.io/posts/_posts/ui/2014-11-26-menuandactionbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/ui/2014-11-26-menuandactionbar/</guid>
      <description>context menu的创建 context menu可以使用到任意view上，但通常使用在ListView，GridView的items上，或者其他用户能够执行item操作的view集合。
有两种方式可以创建context menu
  In a floating context menu. A menu appears as a floating list of menu items (similar to a dialog) when the user performs a long-click (press and hold) on a view that declares support for a context menu. Users can perform a contextual action on one item at a time. In the contextual action mode. This mode is a system implementation of ActionMode that displays a contextual action bar at the top of the screen with action items that affect the selected item(s).</description>
    </item>
    
    <item>
      <title>menu和actionbar</title>
      <link>https://wfeii.github.io/posts/ui/2014-11-26-menuandactionbar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/ui/2014-11-26-menuandactionbar/</guid>
      <description>context menu的创建 context menu可以使用到任意view上，但通常使用在ListView，GridView的items上，或者其他用户能够执行item操作的view集合。
有两种方式可以创建context menu
  In a floating context menu. A menu appears as a floating list of menu items (similar to a dialog) when the user performs a long-click (press and hold) on a view that declares support for a context menu. Users can perform a contextual action on one item at a time. In the contextual action mode. This mode is a system implementation of ActionMode that displays a contextual action bar at the top of the screen with action items that affect the selected item(s).</description>
    </item>
    
    <item>
      <title>异步处理一</title>
      <link>https://wfeii.github.io/posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</guid>
      <description>异步处理 Handler A Handler allows you to send and process Message and Runnable objects associated with a thread&amp;rsquo;s MessageQueue. Each Handler instance is associated with a single thread and that thread&amp;rsquo;s message queue.
从描述可以总结出Handler一些特性:
 每个Handler实例都会与一个线程以及线程的messageQueue关联. 发送消息. 处理消息,处理Runnable.  Handler的处理机制示意图 从上图可以看出其实,Handler机制就是:Looper不断从MessageQueue中获取Message,然后Hanlder处理消息
从上图可以看出要分析的问题:
 looper如何从MessageQueue中获取需要处理的message Handler如何处理消息 Handler如何发送消息  再讲前面的问题之前还是要先了解一个问题,就是Handler实例如何与线程,线程的messageQueue关联的?
Handler与线程,MessageQueue关联 下面以默认构造函数来说明.
public Handler() { this(null, false); } public Handler(Callback callback, boolean async) { ... mLooper = Looper.myLooper(); //获取looper if (mLooper == null) { throw new RuntimeException( &amp;quot;Can&#39;t create handler inside thread that has not called Looper.</description>
    </item>
    
    <item>
      <title>异步处理一</title>
      <link>https://wfeii.github.io/posts/_posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wfeii.github.io/posts/_posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</guid>
      <description>异步处理 Handler A Handler allows you to send and process Message and Runnable objects associated with a thread&amp;rsquo;s MessageQueue. Each Handler instance is associated with a single thread and that thread&amp;rsquo;s message queue.
从描述可以总结出Handler一些特性:
 每个Handler实例都会与一个线程以及线程的messageQueue关联. 发送消息. 处理消息,处理Runnable.  Handler的处理机制示意图 从上图可以看出其实,Handler机制就是:Looper不断从MessageQueue中获取Message,然后Hanlder处理消息
从上图可以看出要分析的问题:
 looper如何从MessageQueue中获取需要处理的message Handler如何处理消息 Handler如何发送消息  再讲前面的问题之前还是要先了解一个问题,就是Handler实例如何与线程,线程的messageQueue关联的?
Handler与线程,MessageQueue关联 下面以默认构造函数来说明.
public Handler() { this(null, false); } public Handler(Callback callback, boolean async) { ... mLooper = Looper.myLooper(); //获取looper if (mLooper == null) { throw new RuntimeException( &amp;quot;Can&#39;t create handler inside thread that has not called Looper.</description>
    </item>
    
  </channel>
</rss>