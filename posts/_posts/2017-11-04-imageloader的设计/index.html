<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>ImageLoader的设计 | 音视频技术部</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.72.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="ImageLoader的设计" />
<meta property="og:description" content="ImageLoader解决的问题 分析源码之前我们需要知道ImageLoader为什么要出现，或者说ImageLoader是用来解决什么问题的。总结了一下几点:
 对于加载网络的图片是比较耗时的，而对于耗时的排序基本是 网络&gt;磁盘&gt;内存，因此我们需要尽量减少对于网络的请求次数，我们可以牺牲磁盘和内存来达到尽量减少网络请求的加载，这就是我们所说的三级缓存，先从内存获取，然后从磁盘获取，最后再从网络获取。所以ImageLoader需要对此问题给出解决方案。 图片本身会占用大量的内存，如何做到内存的优化？ImageLoader需要对此问题给出解决方案，基本的解决方案是  图片的大小压缩，对应于Bitmap就是其大小 图片的色彩压缩，对应于Bitmap就是像素的标识是565还是8888   对于加载图片需要在子线程中运行，如何合理的处理线程需要考虑 扩展性，对于此问题不实现也可以，但写出来的代码绝对不是好代码，因为无法扩展  显示的时候，对返回的Bitmap做处理，比如说我们需要倒圆角，圆形图，那ImageLoader是否可以给予支持，给用户更好的使用。(ImageLoader可以不给予实现，但是此实现会极大的提高ImageLoader的易用性)。 对于图片的加载，我们需要从网络加载，也可以从磁盘加载，而且网络加载是否可以引入其他的库比如HttpClient等等。如何做到这些呢？ImageLoader最好给予实现。   易用性，既然是库，给client使用时候就需要考虑  以Android-Universal-Image-Loader为例
Android-Universal-Image-Loader流程 ImageLoder对外充当高层接口，ImageLoaderEngine管理线程，而ImageDecoder和ImageDownloader用于加载图片，而BitmapDisplayer用于显示Bitmap到ImageView上。
对外接口结构 供客户端接口是通过Facade模式进行封装，把底层细节隐藏起来，提供给用户使用的是ImageLoader类和ImageLoaderConfiguraton类。客户端不需要涉及底层细节，提高易用性。
源码分析 下面以ImageLoader的displayImage为例，看看如何从网络获取图片，如何把图片设置到ImageView上。
 public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) { ...... // 获取控件大小，后面我们需要根据此来压缩图片 if (targetSize == null) { targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize()); } // 根据Uri生成一个key，这个key非常重要，在ListView中itemView复用的时候通过key识别 String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize); engine.prepareDisplayTaskFor(imageAware, memoryCacheKey); //现在先从memory中看是否能获取到。 Bitmap bmp = configuration.memoryCache.get(memoryCacheKey); if (bmp !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wfeii.github.io/posts/_posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/" />
<meta property="article:published_time" content="2017-11-04T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-11-04T00:00:00+00:00" />
<meta itemprop="name" content="ImageLoader的设计">
<meta itemprop="description" content="ImageLoader解决的问题 分析源码之前我们需要知道ImageLoader为什么要出现，或者说ImageLoader是用来解决什么问题的。总结了一下几点:
 对于加载网络的图片是比较耗时的，而对于耗时的排序基本是 网络&gt;磁盘&gt;内存，因此我们需要尽量减少对于网络的请求次数，我们可以牺牲磁盘和内存来达到尽量减少网络请求的加载，这就是我们所说的三级缓存，先从内存获取，然后从磁盘获取，最后再从网络获取。所以ImageLoader需要对此问题给出解决方案。 图片本身会占用大量的内存，如何做到内存的优化？ImageLoader需要对此问题给出解决方案，基本的解决方案是  图片的大小压缩，对应于Bitmap就是其大小 图片的色彩压缩，对应于Bitmap就是像素的标识是565还是8888   对于加载图片需要在子线程中运行，如何合理的处理线程需要考虑 扩展性，对于此问题不实现也可以，但写出来的代码绝对不是好代码，因为无法扩展  显示的时候，对返回的Bitmap做处理，比如说我们需要倒圆角，圆形图，那ImageLoader是否可以给予支持，给用户更好的使用。(ImageLoader可以不给予实现，但是此实现会极大的提高ImageLoader的易用性)。 对于图片的加载，我们需要从网络加载，也可以从磁盘加载，而且网络加载是否可以引入其他的库比如HttpClient等等。如何做到这些呢？ImageLoader最好给予实现。   易用性，既然是库，给client使用时候就需要考虑  以Android-Universal-Image-Loader为例
Android-Universal-Image-Loader流程 ImageLoder对外充当高层接口，ImageLoaderEngine管理线程，而ImageDecoder和ImageDownloader用于加载图片，而BitmapDisplayer用于显示Bitmap到ImageView上。
对外接口结构 供客户端接口是通过Facade模式进行封装，把底层细节隐藏起来，提供给用户使用的是ImageLoader类和ImageLoaderConfiguraton类。客户端不需要涉及底层细节，提高易用性。
源码分析 下面以ImageLoader的displayImage为例，看看如何从网络获取图片，如何把图片设置到ImageView上。
 public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) { ...... // 获取控件大小，后面我们需要根据此来压缩图片 if (targetSize == null) { targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize()); } // 根据Uri生成一个key，这个key非常重要，在ListView中itemView复用的时候通过key识别 String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize); engine.prepareDisplayTaskFor(imageAware, memoryCacheKey); //现在先从memory中看是否能获取到。 Bitmap bmp = configuration.memoryCache.get(memoryCacheKey); if (bmp !">
<meta itemprop="datePublished" content="2017-11-04T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-11-04T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="604">



<meta itemprop="keywords" content="ImageLoader," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ImageLoader的设计"/>
<meta name="twitter:description" content="ImageLoader解决的问题 分析源码之前我们需要知道ImageLoader为什么要出现，或者说ImageLoader是用来解决什么问题的。总结了一下几点:
 对于加载网络的图片是比较耗时的，而对于耗时的排序基本是 网络&gt;磁盘&gt;内存，因此我们需要尽量减少对于网络的请求次数，我们可以牺牲磁盘和内存来达到尽量减少网络请求的加载，这就是我们所说的三级缓存，先从内存获取，然后从磁盘获取，最后再从网络获取。所以ImageLoader需要对此问题给出解决方案。 图片本身会占用大量的内存，如何做到内存的优化？ImageLoader需要对此问题给出解决方案，基本的解决方案是  图片的大小压缩，对应于Bitmap就是其大小 图片的色彩压缩，对应于Bitmap就是像素的标识是565还是8888   对于加载图片需要在子线程中运行，如何合理的处理线程需要考虑 扩展性，对于此问题不实现也可以，但写出来的代码绝对不是好代码，因为无法扩展  显示的时候，对返回的Bitmap做处理，比如说我们需要倒圆角，圆形图，那ImageLoader是否可以给予支持，给用户更好的使用。(ImageLoader可以不给予实现，但是此实现会极大的提高ImageLoader的易用性)。 对于图片的加载，我们需要从网络加载，也可以从磁盘加载，而且网络加载是否可以引入其他的库比如HttpClient等等。如何做到这些呢？ImageLoader最好给予实现。   易用性，既然是库，给client使用时候就需要考虑  以Android-Universal-Image-Loader为例
Android-Universal-Image-Loader流程 ImageLoder对外充当高层接口，ImageLoaderEngine管理线程，而ImageDecoder和ImageDownloader用于加载图片，而BitmapDisplayer用于显示Bitmap到ImageView上。
对外接口结构 供客户端接口是通过Facade模式进行封装，把底层细节隐藏起来，提供给用户使用的是ImageLoader类和ImageLoaderConfiguraton类。客户端不需要涉及底层细节，提高易用性。
源码分析 下面以ImageLoader的displayImage为例，看看如何从网络获取图片，如何把图片设置到ImageView上。
 public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) { ...... // 获取控件大小，后面我们需要根据此来压缩图片 if (targetSize == null) { targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize()); } // 根据Uri生成一个key，这个key非常重要，在ListView中itemView复用的时候通过key识别 String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize); engine.prepareDisplayTaskFor(imageAware, memoryCacheKey); //现在先从memory中看是否能获取到。 Bitmap bmp = configuration.memoryCache.get(memoryCacheKey); if (bmp !"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        音视频技术部
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="关于 page">
              关于
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="文章 page">
              文章
            </a>
          </li>
          
        </ul>
      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        文章
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://wfeii.github.io/posts/_posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://wfeii.github.io/posts/_posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/&amp;text=ImageLoader%e7%9a%84%e8%ae%be%e8%ae%a1" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://wfeii.github.io/posts/_posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/&amp;title=ImageLoader%e7%9a%84%e8%ae%be%e8%ae%a1" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">ImageLoader的设计</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2017-11-04T00:00:00Z">November 4, 2017</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="imageloader解决的问题">ImageLoader解决的问题</h2>
<p>分析源码之前我们需要知道ImageLoader为什么要出现，或者说ImageLoader是用来解决什么问题的。总结了一下几点:</p>
<ul>
<li>对于加载网络的图片是比较耗时的，而对于耗时的排序基本是 网络&gt;磁盘&gt;内存，因此我们需要尽量减少对于网络的请求次数，我们可以牺牲磁盘和内存来达到尽量减少网络请求的加载，这就是我们所说的三级缓存，先从内存获取，然后从磁盘获取，最后再从网络获取。所以ImageLoader需要对此问题给出解决方案。</li>
<li>图片本身会占用大量的内存，如何做到内存的优化？ImageLoader需要对此问题给出解决方案，基本的解决方案是
<ul>
<li>图片的大小压缩，对应于Bitmap就是其大小</li>
<li>图片的色彩压缩，对应于Bitmap就是像素的标识是565还是8888</li>
</ul>
</li>
<li>对于加载图片需要在子线程中运行，如何合理的处理线程需要考虑</li>
<li>扩展性，对于此问题不实现也可以，但写出来的代码绝对不是好代码，因为无法扩展
<ul>
<li>显示的时候，对返回的Bitmap做处理，比如说我们需要倒圆角，圆形图，那ImageLoader是否可以给予支持，给用户更好的使用。(ImageLoader可以不给予实现，但是此实现会极大的提高ImageLoader的易用性)。</li>
<li>对于图片的加载，我们需要从网络加载，也可以从磁盘加载，而且网络加载是否可以引入其他的库比如HttpClient等等。如何做到这些呢？ImageLoader最好给予实现。</li>
</ul>
</li>
<li>易用性，既然是库，给client使用时候就需要考虑</li>
</ul>
<p>以<a href="https://github.com/nostra13/Android-Universal-Image-Loader">Android-Universal-Image-Loader</a>为例</p>
<p><a href="https://github.com/nostra13/Android-Universal-Image-Loader">Android-Universal-Image-Loader</a>流程
<img src="http://img.blog.csdn.net/20170521155701391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="流程"></p>
<p>ImageLoder对外充当高层接口，ImageLoaderEngine管理线程，而ImageDecoder和ImageDownloader用于加载图片，而BitmapDisplayer用于显示Bitmap到ImageView上。</p>
<p>对外接口结构
<img src="http://img.blog.csdn.net/20170521155933665?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="对外接口"></p>
<p>供客户端接口是通过Facade模式进行封装，把底层细节隐藏起来，提供给用户使用的是ImageLoader类和ImageLoaderConfiguraton类。客户端不需要涉及底层细节，提高易用性。</p>
<h2 id="源码分析">源码分析</h2>
<p>下面以ImageLoader的displayImage为例，看看如何从网络获取图片，如何把图片设置到ImageView上。</p>
<pre><code>    public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,
          ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) {
     ......
       // 获取控件大小，后面我们需要根据此来压缩图片
       if (targetSize == null) {
          targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());
       }
      // 根据Uri生成一个key，这个key非常重要，在ListView中itemView复用的时候通过key识别
       String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);
       engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);

      //现在先从memory中看是否能获取到。
       Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);
       if (bmp != null &amp;&amp; !bmp.isRecycled()) {
          // 这里是可以获取到Bitmap的代码，把Bitmap展示到ImageView中，可以查看ImageLoader的代码详细了解
       } else {
          if (options.shouldShowImageOnLoading()) {
             imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));
          } else if (options.isResetViewBeforeLoading()) {
             imageAware.setImageDrawable(null);
          }

          ImageLoadingInfo imageLoadingInfo = new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,
                options, listener, progressListener, engine.getLockForUri(uri));
          LoadAndDisplayImageTask displayTask = new LoadAndDisplayImageTask(engine, imageLoadingInfo,
                defineHandler(options));
         //如果是同步加载，直接运行task，否则直接ImageLoaderEngine来提交工作线程处理
          if (options.isSyncLoading()) {
             displayTask.run();
          } else {
             engine.submit(displayTask);
          }
       }
    }

</code></pre><p>从上面的代码中可以看出先从内存中获取，获取不到的话会让LoadAndDisplayImageTask处理，我们一起分析一下LoadAndDisplayImageTask。</p>
<h4 id="loadanddisplayimagetask分析">LoadAndDisplayImageTask分析</h4>
<pre><code>   public void run() {
      //如果pause就需要直接退出，比如我们的Activity进入pause，我们可以调用ImageLoader的
       if (waitIfPaused()) return;
       if (delayIfNeed()) return;
       Bitmap bmp;
       try {
         //先从内存中获取，
          bmp = configuration.memoryCache.get(memoryCacheKey);
          if (bmp == null || bmp.isRecycled()) {
            //没有获取到通过相应的方法获取。
             bmp = tryLoadBitmap();
          } else {
             loadedFrom = LoadedFrom.MEMORY_CACHE;
             L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);
          }

          if (bmp != null &amp;&amp; options.shouldPostProcess()) {
             L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);
             bmp = options.getPostProcessor().process(bmp);
             if (bmp == null) {
                L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);
             }
          }
          checkTaskNotActual();
          checkTaskInterrupted();
       } catch (TaskCancelledException e) {
          fireCancelEvent();
          return;
       } finally {
          loadFromUriLock.unlock();
       }
    	// 创建DisplayBitmapTask去加载Bitmap到ImageView上
       DisplayBitmapTask displayBitmapTask = new DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);
       runTask(displayBitmapTask, syncLoading, handler, engine);
    }
</code></pre><ol>
<li>还是先从内存中获取Bitmap，存在多线程操作，因此这里会重新从内存总获取一次。</li>
<li>调用tryLoadBitmap获取Bitmap</li>
<li>通过DisplayBitmapTask对象来显示Bitmap</li>
</ol>
<p>对于tryLoadBitmap方法的操作如下</p>
<pre><code>    private Bitmap tryLoadBitmap() throws TaskCancelledException {
       Bitmap bitmap = null;
       try {
          File imageFile = configuration.diskCache.get(uri);
          if (imageFile != null &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; 0) {
             L.d(LOG_LOAD_IMAGE_FROM_DISK_CACHE, memoryCacheKey);
             loadedFrom = LoadedFrom.DISC_CACHE;

             checkTaskNotActual();
            //通过磁盘缓存获取
             bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));
          }
          if (bitmap == null || bitmap.getWidth() &lt;= 0 || bitmap.getHeight() &lt;= 0) {
             L.d(LOG_LOAD_IMAGE_FROM_NETWORK, memoryCacheKey);
             loadedFrom = LoadedFrom.NETWORK;
    		 ......
              // 通过网络获取
             bitmap = decodeImage(imageUriForDecoding);

             if (bitmap == null || bitmap.getWidth() &lt;= 0 || bitmap.getHeight() &lt;= 0) {
                fireFailEvent(FailType.DECODING_ERROR, null);
             }
          }
       }
      ......
       return bitmap;
    }
</code></pre><ol>
<li>先从磁盘中获取Bitmap</li>
<li>然后从网络获取</li>
</ol>
<p>下面分析一下decodeImage方法</p>
<pre><code>    private Bitmap decodeImage(String imageUri) throws IOException {
       ViewScaleType viewScaleType = imageAware.getScaleType();
       ImageDecodingInfo decodingInfo = new ImageDecodingInfo(memoryCacheKey, imageUri, uri, targetSize, viewScaleType,
             getDownloader(), options);
       return decoder.decode(decodingInfo);
    }
</code></pre><p>分析一下ImageDecoder的decode方法，而我们默认的BaseImageDecoder。</p>
<p>以BaseImageDecoder为例</p>
<pre><code>    public Bitmap decode(ImageDecodingInfo decodingInfo) throws IOException {
       Bitmap decodedBitmap;
       ImageFileInfo imageInfo;

      //通过ImageDownloader获取到InputStream对象
       InputStream imageStream = getImageStream(decodingInfo);
       if (imageStream == null) {
          L.e(ERROR_NO_IMAGE_STREAM, decodingInfo.getImageKey());
          return null;
       }
      //创建Bitmap
       try {
          imageInfo = defineImageSizeAndRotation(imageStream, decodingInfo);
          imageStream = resetStream(imageStream, decodingInfo);
          Options decodingOptions = prepareDecodingOptions(imageInfo.imageSize, decodingInfo);
          decodedBitmap = BitmapFactory.decodeStream(imageStream, null, decodingOptions);
       } finally {
          IoUtils.closeSilently(imageStream);
       }

      // 处理Bitmap类。
       if (decodedBitmap == null) {
          L.e(ERROR_CANT_DECODE_IMAGE, decodingInfo.getImageKey());
       } else {
          decodedBitmap = considerExactScaleAndOrientatiton(decodedBitmap, decodingInfo, imageInfo.exif.rotation,
                imageInfo.exif.flipHorizontal);
       }
       return decodedBitmap;
    }
</code></pre><p>最主要的通过ImageDownloader获取到InputStream对象。后面还会详细分析。</p>
<p>还有两个没有分析，一个是DisplayBitmapTask如何显示Bitmap的，一个是ImageLoaderEngine如何加载管理线程的。</p>
<h3 id="displaybitmaptask分析">DisplayBitmapTask分析</h3>
<p>DisplayBitmapTask继承Runnable</p>
<pre><code>    public void run() {
       if (imageAware.isCollected()) {
          L.d(LOG_TASK_CANCELLED_IMAGEAWARE_COLLECTED, memoryCacheKey);
          listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());
       } else if (isViewWasReused()) {
          L.d(LOG_TASK_CANCELLED_IMAGEAWARE_REUSED, memoryCacheKey);
          listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());
       } else {
          L.d(LOG_DISPLAY_IMAGE_IN_IMAGEAWARE, loadedFrom, memoryCacheKey);
          displayer.display(bitmap, imageAware, loadedFrom);
          engine.cancelDisplayTaskFor(imageAware);
          listener.onLoadingComplete(imageUri, imageAware.getWrappedView(), bitmap);
       }
    }
</code></pre><p>通过BitmapDisplayer的对象来显示的。</p>
<pre><code>    public final class SimpleBitmapDisplayer implements BitmapDisplayer {
       @Override
       public void display(Bitmap bitmap, ImageAware imageAware, LoadedFrom loadedFrom) {
          imageAware.setImageBitmap(bitmap);
       }
    }
</code></pre><h3 id="imageloaderengine">ImageLoaderEngine</h3>
<p>ImageLoaderEngine主要是task的分发执行</p>
<pre><code>    void submit(final LoadAndDisplayImageTask task) {
       taskDistributor.execute(new Runnable() {
          @Override
          public void run() {
             File image = configuration.diskCache.get(task.getLoadingUri());
             boolean isImageCachedOnDisk = image != null &amp;&amp; image.exists();
             initExecutorsIfNeed();
             if (isImageCachedOnDisk) {
                taskExecutorForCachedImages.execute(task);
             } else {
                taskExecutor.execute(task);
             }
          }
       });
    }
</code></pre><h2 id="模块结构">模块结构</h2>
<p>主要功能有一下几点</p>
<h3 id="线程池管理">线程池管理</h3>
<p>线程池的管理主要是由ImageLoaderEngine负责。
<img src="http://img.blog.csdn.net/20170521160445980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程池">
对于ImageLoaderEngine的线程池主要有三个</p>
<ul>
<li>
<p>taskDistributor 用于分发Task,具体可查看ImageLoaderEngine的submit方法</p>
</li>
<li>
<p>taskExecutor 用于从网络上下载</p>
</li>
<li>
<p>taskExecutorForCachedImages 用于从磁盘缓存中获取，或者提交ProcessAndDisplayImageTask时候使用</p>
</li>
</ul>
<p>考虑一种情况，在Activity中有一个ListView而itemView中会从Uri中获取图片，在Activity中我们需要做什么操作呢？</p>
<ul>
<li>当Activity处于paused的时候，现在界面不需要刷新，我们可以调用ImageLoader的pause来暂定新的请求加载</li>
<li>当Activity处于stop的时候，界面不可见，我们可以调用stop来暂定所有的线程</li>
<li>当Activity处于destory的时候，调用destroy来销毁</li>
</ul>
<p>这样做到了加载与Activity声明周期相关联。</p>
<h3 id="缓存">缓存</h3>
<p>这里以内存缓存为例
<img src="http://img.blog.csdn.net/20170521160536497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="缓存"></p>
<p>抽象出MemoryCache接口，而外界只是引用其接口，DiskCache与此类似</p>
<h3 id="下载解析">下载解析</h3>
<p><img src="http://img.blog.csdn.net/20170521160630324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>对于ImageDecoder解析是根据ImageDowloader的getStream获取InputStream，然后根据InputStream来解析出Bitmap。对外也都是引用均为接口。</p>
<p>而ImageDownloader是通过装饰模式进行组织，BaseImageDownloader为ConcreateComponent。而SlowNetWorkImageDowloader为Decorator。</p>
<ul>
<li>
<p>实现自己的下载，可以根据ImageDownloader来实现。</p>
</li>
<li>
<p>而实现自己的图片解析器，可以根据ImageDecoder。</p>
</li>
</ul>
<h3 id="显示">显示</h3>
<p>对于显示除了DisplayBitmapTask类外最主要的就是下面类图。</p>
<p><img src="http://img.blog.csdn.net/20170521160659997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="显示"></p>
<p>对于BitmapDisplayer类图是对Bitmap进行进一步处理的过程，处理成圆形等等。</p>
<p>对于ImageAware的类图主要是处理View的显示，弱引用View避免内存泄露，其中是通过<strong>模板方法</strong>模式组织。</p>
<p>ViewAware</p>
<pre><code>    @Override
    public boolean setImageBitmap(Bitmap bitmap) {
       if (Looper.myLooper() == Looper.getMainLooper()) {
          View view = viewRef.get();
          if (view != null) {
             setImageBitmapInto(bitmap, view);
             return true;
          }
       } else {
          L.w(WARN_CANT_SET_BITMAP);
       }
       return false;
    }
</code></pre><p>对于ViewAware子类只需要实现相应的抽象方法。</p>
<h2 id="imageloader问题解答">ImageLoader问题解答</h2>
<ul>
<li>加载网络的图片是比较耗时，ImageLoader使用三级缓存进行处理。</li>
<li>图片内存占用优化，Android-Universal-Image-Loader中ImageLoaderConfigue可以配置最大的长宽，而且还会根据View的大小计算出相应的图片大小。在ImageSizeUtils中获取ImageSize，而对于ImageDecoder中根据ImageSize进行计算取样（Glide会缓存两份，一份是大图，一份是缩略图，对于控件比较小，直接从缩略图中加载，以后分析Glide的时候在详细讲解）。</li>
</ul>
<pre><code>public static ImageSize defineTargetSizeForView(ImageAware imageAware, ImageSize maxImageSize) {
          int width = imageAware.getWidth();
          if (width &lt;= 0) width = maxImageSize.getWidth();

          int height = imageAware.getHeight();
          if (height &lt;= 0) height = maxImageSize.getHeight();

          return new ImageSize(width, height);
       }
</code></pre><ul>
<li>对于色彩的优化，这里没有指定，默认是Bitmap.Config.ARGB_8888，如果需要优化需要自己指定。（对<a href="https://github.com/bumptech/glide">Glide</a>默认是565）。</li>
<li>线程的优化
<ul>
<li>对于Activity的生命周期有优化，不过需要自己手动设置pause，还有stop等，（<a href="https://github.com/bumptech/glide">Glide</a>实现了自动管理）</li>
<li>对于ListView的滑动，优化加载可见View的图片，具体可参考ImageLoader类的cancelDisplayTask方法（也是需要自己去实现，<a href="https://github.com/bumptech/glide">Glide</a>实现自动管理）</li>
</ul>
</li>
<li>扩展性与易用性，对于扩展性，使用面向接口，从而摆脱对具体实现的依赖。对于易用性，通过Facade模式来完成，隐藏底层细节，对外高层级的接口。</li>
</ul>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/imageloader" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">ImageLoader</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">这是什么 posts</p>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#imageloader解决的问题">ImageLoader解决的问题</a></li>
    <li><a href="#源码分析">源码分析</a>
      <ul>
        <li></li>
        <li><a href="#displaybitmaptask分析">DisplayBitmapTask分析</a></li>
        <li><a href="#imageloaderengine">ImageLoaderEngine</a></li>
      </ul>
    </li>
    <li><a href="#模块结构">模块结构</a>
      <ul>
        <li><a href="#线程池管理">线程池管理</a></li>
        <li><a href="#缓存">缓存</a></li>
        <li><a href="#下载解析">下载解析</a></li>
        <li><a href="#显示">显示</a></li>
      </ul>
    </li>
    <li><a href="#imageloader问题解答">ImageLoader问题解答</a></li>
  </ul>
</nav>
  </div>




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">相关內容</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/">ImageLoader的设计</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://wfeii.github.io/" >
    &copy;  音视频技术部 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
