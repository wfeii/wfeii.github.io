<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.7.1 by Michael Rose
  Copyright 2017 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin SEO -->









<title>异步处理一 - 杂记</title>




<meta name="description" content="异步处理">




<meta name="author" content="王飞">

<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="杂记">
<meta property="og:title" content="异步处理一">


  <link rel="canonical" href="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E8%BF%9B%E9%98%B6/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">
  <meta property="og:url" content="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E8%BF%9B%E9%98%B6/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">



  <meta property="og:description" content="异步处理">

















  

  





  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2016-07-25T00:15:00+08:00">








  <script type="application/ld+json">
    {
      "@context" : "http://schema.org",
      "@type" : "Person",
      "name" : "王飞",
      "url" : "http://localhost:4000",
      "sameAs" : null
    }
  </script>







<!-- end SEO -->


<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="杂记 Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->
  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="http://localhost:4000/">杂记</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/year-archive/">Posts</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/categories/">Categories</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/tags/">Tags</a></li>
          
            
            <li class="masthead__menu-item"><a href="http://localhost:4000/search/">Search</a></li>
          
            
            <li class="masthead__menu-item"><a href="https://google.com">External Link</a></li>
          
        </ul>
        <button type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    



<div id="main" role="main">
  
  <div class="sidebar sticky">
  

<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="http://localhost:4000/assets/images/bio-photo.jpeg" class="author__avatar" alt="王飞" itemprop="image">
      
    </div>
  

  <div class="author__content">
    <h3 class="author__name" itemprop="name">王飞</h3>
    
      <p class="author__bio" itemprop="description">
        天行健君子以自强不息
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> <span itemprop="name">广东-深圳</span>
        </li>
      

      

      
        <li>
          <a href="mailto:wangfei199101@gamil.com">
            <meta itemprop="email" content="wangfei199101@gamil.com" />
            <i class="fa fa-fw fa-envelope-square" aria-hidden="true"></i> 电子邮箱
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      
        <li>
          <a href="https://github.com/wfeii" itemprop="sameAs">
            <i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fa fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="异步处理一">
    <meta itemprop="description" content="异步处理">
    <meta itemprop="datePublished" content="July 25, 2016">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 class="page__title" itemprop="headline">异步处理一
</h1>
          
            <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 




  3 分钟读完
</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <h3 id="异步处理">异步处理</h3>

<h4 id="handler">Handler</h4>

<p>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue.</p>

<p>从描述可以总结出Handler一些特性:</p>

<ol>
  <li>每个Handler实例都会与一个线程以及线程的messageQueue关联.</li>
  <li>发送消息.</li>
  <li>处理消息,处理Runnable.</li>
</ol>

<p>Handler的处理机制示意图  <br />
<img src="https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/Handler%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.png" alt="Handler处理机制" /></p>

<p>从上图可以看出其实,Handler机制就是:Looper不断从MessageQueue中获取Message,然后Hanlder处理消息<br />
从上图可以看出要分析的问题:</p>

<ol>
  <li>looper如何从MessageQueue中获取需要处理的message</li>
  <li>Handler如何处理消息</li>
  <li>Handler如何发送消息
<!--  more  -->
再讲前面的问题之前还是要先了解一个问题,就是Handler实例如何与线程,线程的messageQueue关联的?</li>
</ol>

<h5 id="handler与线程messagequeue关联">Handler与线程,MessageQueue关联</h5>

<p>下面以默认构造函数来说明.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public Handler() {
        this(null, false);
    }

	public Handler(Callback callback, boolean async) {
		...
        mLooper = Looper.myLooper();  //获取looper
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;   //从looper中获取MessageQueue
        mCallback = callback;
		...
    }
</code></pre></div></div>

<p>从上面看能看出是looper中获取MessageQueue,并没有与什么线程关联?
其实玄机在于Looper.myLooper()中.
下面是Looper类用于说明原因.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class Looper {
	static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();

	private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

	public static Looper myLooper() {
        return sThreadLocal.get();   //从sThreadLocal获取中looper,而添加是在prepare中.
    }
}
</code></pre></div></div>

<p>其实每个Thread只能对应一个Looper,也可以不对应Looper,而每个Handler必须对应一个Looper.</p>

<h5 id="looper如何从messagequeue中获取需要处理的message">Looper如何从MessageQueue中获取需要处理的message</h5>

<p>对于Looper从MessageQueue是在looper类的loope()方法中,loope()函数一直从MessageQueue中获取Message,获取到了message然后调用message.target.dispatchMessage(),message.target其实就是Handler本身,message.target的设置是在发送消息时设置的.</p>

<h5 id="handler如何处理消息">Handler如何处理消息</h5>

<p>其实Handler机制图中已经很清楚了,就是dispatchMessage()分发消息,调用恰当的函数处理.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void dispatchMessage(Message msg) {
        if (msg.callback != null) {    //基本是通过Handler的post的相关的函数来发送的消息时调用
            handleCallback(msg);
        } else {
            if (mCallback != null) {   //通过基本的Handler的构造函数
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);       //上述的都为null,最后交有handleMessage()方法处理
        }
    }
</code></pre></div></div>

<h5 id="handler如何发送消息">Handler如何发送消息</h5>

<p>通过两种方式post()相关的函数,sendMessage()相关的函数.而这两种方式最终都会调用到sendMessageAtTime()发送message.</p>

<ul>
  <li>post()传入的是一个Runnable,然后有调用sendMessageAtTime()并把Runnable封装成message,message.callback为Runnable,有Handler消息处理机制可以知道,处理消息时优先调用message.callback,从而Runnable得以处理.</li>
  <li>sendMessage()的方法最终会调用sendMessageAtTime()方法,然后调用enqueueMessage()方法,而在enqueueMessage()方法中会设置message.target为此Handler,这样looper获取到的message可以调用message.target来处理了.</li>
</ul>

<h4 id="thread">Thread</h4>

<p>Thread类对于开发者并不陌生,两种实现方式,然后调用start()方法就开启了线程.而在Android中Thread经常与Looper的结合使用.下面以Android中的HandlerThread为例:<br />
主要看run()方法.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void run() {
		...
        Looper.prepare();      //1. 做好准备工作 主要是创建looper,并创建MssageQueue,获取当前线程
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        onLooperPrepared();
        Looper.loop();  //2. 开始循环,获取MessageQueue中的message
		...
    }
</code></pre></div></div>

<p>在Android创建线程,如果涉及到长期处理消息,就使用HandlerThread,然后使用Handler处理消息,效果很佳,对于休眠,退出的设计都不需要自己处理.</p>

<blockquote>
  <p>Notices:</p>
</blockquote>

<blockquote>
  <ul>
    <li>不需要线程时,要调用quit()相关的方法.</li>
    <li>一定要调用start()方法以后,再获取线程中的looper,不然获取的looper为null,因为创建looper是在run()方法中.</li>
  </ul>
</blockquote>

<h4 id="asyncqueryhandler">AsyncQueryHandler</h4>

<p>AsyncQueryHandler主要用途是使ContentProvider查询等操作更容易. <br />
AsyncQueryHandler继承自Handler,并且内部还有工作线程WorkHandler,工作原理就是AsyncQueryHandler(主线程中) 发送消息到WorkHandler(工作线程中)查询,查询完成,发送消息到AsyncQueryHandler(主线程中)从而更新界面等操作. 现在从源码分析原理. <br />
先分析构造函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public AsyncQueryHandler(ContentResolver cr) {
        super();
        synchronized (AsyncQueryHandler.class) {
        //启动线程
            if (sLooper == null) {
                HandlerThread thread = new HandlerThread("AsyncQueryWorker");
                thread.start();

                sLooper = thread.getLooper();
            }
        }
        mWorkerThreadHandler = createHandler(sLooper);
    }
</code></pre></div></div>

<p>启动一个工作线程(HandlerThread上面有说过),获取looper,然后通过createHandler()创建一个Handler对象.
分析createHandler()方法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected Handler createHandler(Looper looper) {
        return new WorkerHandler(looper);
    }
</code></pre></div></div>

<p>只是创建了一个WorkerHandler对象,并且关联获取的looper,这样handler处理消息,就在工作线程里了.对于WorkerHandler比较简单,就不分析了.  <br />
那startQuery(),startInsert(),如何工作的呢?<br />
下面已startQuery()分析为例.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void startQuery(int token, Object cookie, Uri uri,
            String[] projection, String selection, String[] selectionArgs,
            String orderBy) {
		...
        mWorkerThreadHandler.sendMessage(msg);
    }
</code></pre></div></div>

<p>很简单,使用mWorkerThreadHandler发送消息.<br />
然后mWorkerThreadHandler关联的looper取出消息,交由mWorkerThreadHandler处理.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected class WorkerHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            WorkerArgs args = (WorkerArgs) msg.obj;
			......
            switch (event) {
                case EVENT_ARG_QUERY:
                    Cursor cursor;
                    ......
                    cursor = resolver.query(args.uri, args.projection,
                            args.selection, args.selectionArgs,
                            args.orderBy);
					......
                    args.result = cursor;
                    break;
			}
			Message reply = args.handler.obtainMessage(token);
            reply.obj = args;
            reply.arg1 = msg.arg1;
            reply.sendToTarget();
		}
}
</code></pre></div></div>

<p>查询数据库,组织数据,从AsyncQueueHandler中获取message,函数中设置了message.target,然后通过sendToTarget()发送消息.这样就轮到AsyncQueueHandler处理消息了.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> public void handleMessage(Message msg) {
        switch (event) {
            case EVENT_ARG_QUERY:
                onQueryComplete(token, args.cookie, (Cursor) args.result);
                break;
    }
</code></pre></div></div>

<p>只是调用了onQueryComplete()方法,而onQueryComplete()什么都没做.可以覆写,实现自己的逻辑.</p>

<h4 id="asynctask">AsyncTask</h4>
<p>对于AsyncTask也是Thread，Handler执行task，只是线程的创建方式，返回值做了修改。<br />
Thread如何获取返回值 <br />
一般我们创建线程覆写Thread的run方法，或者是通过runnable接口创建线程，这样不会获取Thread的返回值，而想要获取Thread的返回值，就需要使用Future，callable接口。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableTest {
    public static void main(String[] args){
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
            @Override
            public String call() throws Exception {
                return "Test";
            }
        });
        Thread thread = new Thread(futureTask);
        thread.start();
        try {
            String test = futureTask.get();
            System.out.print(test);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
</code></pre></div></div>

<p>FutureTask实现Future接口
FutureTask中的get()这个方法会产生阻塞，会一直等到任务执行完毕才返回</p>

<p>使用Executor创建线程<br />
Executor只是Java1.5引入的Executor框架的一个接口。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> public interface Executor {
	     void execute(Runnable command);
 }
</code></pre></div></div>

<p>可以在execute中构造线程池进行创建线程。</p>

<p>AsyncTask分析</p>

<ul>
  <li>FutureTask</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> public AsyncTask() {
        mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
            public Result call() throws Exception {
                mTaskInvoked.set(true);

                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                //noinspection unchecked
                return postResult(doInBackground(mParams));
            }
        };

        mFuture = new FutureTask&lt;Result&gt;(mWorker) {
            @Override
            protected void done() {
	           ......
               postResultIfNotInvoked(get());
			   ......
        };
</code></pre></div></div>

<p>mWork是WorkerRunnable的实现的对象，WorkerRunnable实现了Callable接口，在call（）方法中，会调用
doInBackground（）处理，然后通过postResult()通知InnerHandler处理消息。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    private void finish(Result result) {
        if (isCancelled()) {
            onCancelled(result);
        } else {
            onPostExecute(result);
        }
        mStatus = Status.FINISHED;
    }

    private static class InternalHandler extends Handler {
        public InternalHandler() {
            super(Looper.getMainLooper());
        }

        public void handleMessage(Message msg) {
            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT:
                    // There is only one result
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS:
                    result.mTask.onProgressUpdate(result.mData);
                    break;
            }
        }
    }
</code></pre></div></div>

<p>对于<strong>MESSAGE_POST_RESULT</strong>消息，会调用<strong>AsyncTask</strong>的finish（）方法，在finish（）中会调用onPostExecute(result)，可以覆写此方法，来更新界面等操作。</p>

<ul>
  <li>Executor</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;  

public static final Executor SERIAL_EXECUTOR = new SerialExecutor();  

private static class SerialExecutor implements Executor {
    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) {
            scheduleNext();
        }
    }
    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
</code></pre></div></div>

<p>默认的<strong>Executor</strong>是<strong>sDefaultExecutor</strong>，  <strong>sDefaultExecutor</strong>其实是<strong>SERIAL_EXECUTOR</strong>，而<strong>SERIAL_EXECUTOR</strong>是<strong>SerialExecutor</strong>对象,<strong>SerialExecutor</strong>的executor()方法中会使用<strong>THREAD_POOL_EXECUTOR</strong>线程池来创建线程。</p>

<p>THREAD_POOL_EXECUTOR</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public static final Executor THREAD_POOL_EXECUTOR
            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre></div></div>

<p>创建线程池，其中指出了最大的线程数，最大的队列数，线程工厂对象等。</p>

<p>AsyncTask运行</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);
    }  

public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
        Params... params) {
        .......
        onPreExecute();

        mWorker.mParams = params;
        exec.execute(mFuture);

        return this;
    }
</code></pre></div></div>

<p>调用onPreExecute()，可以覆写此方法，然后在线程运行前做些准备，比如进度条运行等。<br />
然后调用<strong>Executor</strong>的execute()方法来开始运行线程。</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="http://localhost:4000/tags/#background-jobs" class="page__taxonomy-item" rel="tag">Background_jobs</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fa fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="http://localhost:4000/categories/#android" class="page__taxonomy-item" rel="tag">Android</a><span class="sep">, </span>
    
      
      
      <a href="http://localhost:4000/categories/#android%E8%BF%9B%E9%98%B6" class="page__taxonomy-item" rel="tag">Android进阶</a><span class="sep">, </span>
    
      
      
      <a href="http://localhost:4000/categories/#%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F" class="page__taxonomy-item" rel="tag">外功招式</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fa fa-fw fa-calendar" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2016-07-25T00:15:00+08:00">July 25, 2016</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  <a href="https://twitter.com/intent/tweet?text=%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E4%B8%80%20http%3A%2F%2Flocalhost%3A4000%2F%25E5%25A4%2596%25E5%258A%259F%25E6%258B%259B%25E5%25BC%258F%2Fandroid%2Fandroid%25E8%25BF%259B%25E9%2598%25B6%2F%25E5%25BC%2582%25E6%25AD%25A5%25E5%25A4%2584%25E7%2590%2586%2F" class="btn btn--twitter" title="分享 Twitter"><i class="fa fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F%25E5%25A4%2596%25E5%258A%259F%25E6%258B%259B%25E5%25BC%258F%2Fandroid%2Fandroid%25E8%25BF%259B%25E9%2598%25B6%2F%25E5%25BC%2582%25E6%25AD%25A5%25E5%25A4%2584%25E7%2590%2586%2F" class="btn btn--facebook" title="分享 Facebook"><i class="fa fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://plus.google.com/share?url=http%3A%2F%2Flocalhost%3A4000%2F%25E5%25A4%2596%25E5%258A%259F%25E6%258B%259B%25E5%25BC%258F%2Fandroid%2Fandroid%25E8%25BF%259B%25E9%2598%25B6%2F%25E5%25BC%2582%25E6%25AD%25A5%25E5%25A4%2584%25E7%2590%2586%2F" class="btn btn--google-plus" title="分享 Google Plus"><i class="fa fa-fw fa-google-plus" aria-hidden="true"></i><span> Google+</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2F%25E5%25A4%2596%25E5%258A%259F%25E6%258B%259B%25E5%25BC%258F%2Fandroid%2Fandroid%25E8%25BF%259B%25E9%2598%25B6%2F%25E5%25BC%2582%25E6%25AD%25A5%25E5%25A4%2584%25E7%2590%2586%2F" class="btn btn--linkedin" title="分享 LinkedIn"><i class="fa fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E5%9F%BA%E7%A1%80/contentprovider/" class="pagination--pager" title="ContentProvider
">向前</a>
    
    
      <a href="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E8%BF%9B%E9%98%B6/Touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" class="pagination--pager" title="Android事件传递机制
">向后</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E8%BF%9B%E9%98%B6/Touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" rel="permalink">Android事件传递机制
</a>
      
    </h2>
    
      <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 




  2 分钟读完
</p>
    
    <p class="archive__item-excerpt" itemprop="description">Touch事件处理

</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E5%9F%BA%E7%A1%80/contentprovider/" rel="permalink">ContentProvider
</a>
      
    </h2>
    
      <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 




  少于 1 分钟读完
</p>
    
    <p class="archive__item-excerpt" itemprop="description">什么是Android中的Content Provider

</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E5%9F%BA%E7%A1%80/services/" rel="permalink">Services
</a>
      
    </h2>
    
      <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 




  少于 1 分钟读完
</p>
    
    <p class="archive__item-excerpt" itemprop="description">基础

</p>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="http://localhost:4000/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/android/android%E5%9F%BA%E7%A1%80/menuandactionbar/" rel="permalink">menu和actionbar
</a>
      
    </h2>
    
      <p class="page__meta"><i class="fa fa-clock-o" aria-hidden="true"></i> 




  1 分钟读完
</p>
    
    <p class="archive__item-excerpt" itemprop="description">context menu的创建

</p>
  </article>
</div>
        
      </div>
    </div>
  
  
</div>


    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    
    
    
    
      <li><a href="https://github.com/wfeii"><i class="fa fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    
    <li><a href="http://localhost:4000/feed.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2017 王飞. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="http://localhost:4000/assets/js/main.min.js"></script>








  </body>
</html>