<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Android | 音视频技术部</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.72.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
      <link href="/categories/android/index.xml" rel="alternate" type="application/rss+xml" title="音视频技术部" />
      <link href="/categories/android/index.xml" rel="feed" type="application/rss+xml" title="音视频技术部" />
      
    
    
    <meta property="og:title" content="Android" />
<meta property="og:description" content="专注于音视频技术输出" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://wfeii.github.io/categories/android/" />
<meta property="og:updated_time" content="2016-08-06T16:40:12+00:00" />
<meta itemprop="name" content="Android">
<meta itemprop="description" content="专注于音视频技术输出"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Android"/>
<meta name="twitter:description" content="专注于音视频技术输出"/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  
  
  <header class="cover bg-top" style="background-image: url('https://wfeii.github.io/images/gohugo-default-sample-hero-image.jpg');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        音视频技术部
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="关于 page">
              关于
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="文章 page">
              文章
            </a>
          </li>
          
        </ul>
      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv4 pv6-l ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 white-90 mb0 lh-title">
          Android
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray">
      <p>Below you will find pages that utilize the taxonomy term “Android”</p>
    </div>
  </article>
  <div class="mw8 center">    
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/" class="link black dim">
        UI优化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      概述 总结来源与Google发布的性能优化的视频 Android Performance Patterns 和 Android Performance Optimizing Apps for Speed and Usability 对于用户感到卡顿,不流畅的原因有很多,比如Layout层级结构过深,动画过多,界面刷新,等等导致了CPU或者GPU的负担过重,16ms内无法完成一帧的绘制,导致了掉帧,从而表现出卡顿,不流畅.
绘制原理 为了更好的理解UI优化,在此之前先要说明一下硬件的基础.
VSYNC 两个概念 :
 Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的参数，例如60Hz。 Frame Rate：代表了GPU在一秒内绘制的帧数,例如60fps。  GPU获取图形数据绘制,然后硬件负责把绘制的内容显示再屏幕上,二者协调正常.
如果帧速率高于屏幕刷新速率,就会出现撕裂的现象,一部分显示当前的帧,一部分显示现在的帧,这种解决的方案就是双缓冲机制,GPU将帧写进存储器被成为back buffer,而存储器的次级区域成为frame buffer,当写入一帧时,它会开始填充back buffer,而framen buffer保持不变,现在刷新屏幕,使用frame buffer进行绘制,刷新屏幕,vsync触发,也会把back buffer复制到fragme buffer. 更具体的内容参考: Graphics
如果屏幕刷新速率高于帧速率时,就会导致屏幕显示还是上一帧的内容,从而出现卡顿,动画不流畅等现象
一帧画面绘制过程 了解了VSYNC的原理,下面该考虑应用程序是如何把画面绘制到屏幕上的了?或者是如何把XML文件转换成用户能够看到并理解的图像的?
其实这个过程的核心就是进行光栅化(rasterization)的处理过程.这个过程就是把一些高级的对象,比如字符串,形状等转换成屏幕上纹理中的像素点.光栅化是一个非常耗时的过程.正因如此,手机硬件上有一个特殊的部分用于提高光栅化的过程,叫做图像处理器,或者说GPU. 图像绘制到屏幕上首先在CPU上转换成多边形或者纹理,然后再传递到GPU进行光栅化处理,处理UI对象并转化成多边形和纹理并不是很快的操作,同样从CPU传递给GPU也不是那么快,这行就想办法较少UI对象转换的数量,和提交到GPU的数量,OpenGL ES API允许你将内容传递到GPU,并保存到GPU中,当以后再次绘制一个按钮的时候,只需要参考GPU内存中的已经存在的纹理.
渲染优化,尽可能多且快的将更多的数据上传到GPU,然后留在GPU中,尽可能长的时间里不去修改.每次更新GPU中的资源,你将会失去宝贵的处理时间.
下面说明什么时候会导致GPU资源更新. Android把xml语言转化成GPU能够识别的资源从而渲染到屏幕上,是通过Display List来实现的,一个Display List对象中基本上包含了所有GPU需要的渲染信息,Display List中包含了GPU可能需要的常用的资源列表,同时也包含了Open GL命令列表.
在某个视图第一次需要被渲染时,Display List就会被创建,当视图需要显示在屏幕时,会执行GPU的相关指令来进行渲染.
从上图可以看出
 只是View属性改变时,只是参考GPU内存中的已经存在,然后执行相关Open GL进行渲染, InvaliDated View也不会重新创建Display List View 布局改变,比如可见性,大小等  优化点 概述 渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。 对于CPU,应该尽量减少布局的层级深度,CPU减少measure等操作的时间,而对于GPU主要是减少不必要的过度绘制.
过度绘制 过度绘制是指同一帧内一个像素点绘制了多次,通过查看overdraw(开发者选项-&gt; 调试GPU过度绘制) 颜色代表了像素点过度绘制的次数:
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/" class="link black dim">
        UI优化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      概述 总结来源与Google发布的性能优化的视频 Android Performance Patterns 和 Android Performance Optimizing Apps for Speed and Usability 对于用户感到卡顿,不流畅的原因有很多,比如Layout层级结构过深,动画过多,界面刷新,等等导致了CPU或者GPU的负担过重,16ms内无法完成一帧的绘制,导致了掉帧,从而表现出卡顿,不流畅.
绘制原理 为了更好的理解UI优化,在此之前先要说明一下硬件的基础.
VSYNC 两个概念 :
 Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的参数，例如60Hz。 Frame Rate：代表了GPU在一秒内绘制的帧数,例如60fps。  GPU获取图形数据绘制,然后硬件负责把绘制的内容显示再屏幕上,二者协调正常.
如果帧速率高于屏幕刷新速率,就会出现撕裂的现象,一部分显示当前的帧,一部分显示现在的帧,这种解决的方案就是双缓冲机制,GPU将帧写进存储器被成为back buffer,而存储器的次级区域成为frame buffer,当写入一帧时,它会开始填充back buffer,而framen buffer保持不变,现在刷新屏幕,使用frame buffer进行绘制,刷新屏幕,vsync触发,也会把back buffer复制到fragme buffer. 更具体的内容参考: Graphics
如果屏幕刷新速率高于帧速率时,就会导致屏幕显示还是上一帧的内容,从而出现卡顿,动画不流畅等现象
一帧画面绘制过程 了解了VSYNC的原理,下面该考虑应用程序是如何把画面绘制到屏幕上的了?或者是如何把XML文件转换成用户能够看到并理解的图像的?
其实这个过程的核心就是进行光栅化(rasterization)的处理过程.这个过程就是把一些高级的对象,比如字符串,形状等转换成屏幕上纹理中的像素点.光栅化是一个非常耗时的过程.正因如此,手机硬件上有一个特殊的部分用于提高光栅化的过程,叫做图像处理器,或者说GPU. 图像绘制到屏幕上首先在CPU上转换成多边形或者纹理,然后再传递到GPU进行光栅化处理,处理UI对象并转化成多边形和纹理并不是很快的操作,同样从CPU传递给GPU也不是那么快,这行就想办法较少UI对象转换的数量,和提交到GPU的数量,OpenGL ES API允许你将内容传递到GPU,并保存到GPU中,当以后再次绘制一个按钮的时候,只需要参考GPU内存中的已经存在的纹理.
渲染优化,尽可能多且快的将更多的数据上传到GPU,然后留在GPU中,尽可能长的时间里不去修改.每次更新GPU中的资源,你将会失去宝贵的处理时间.
下面说明什么时候会导致GPU资源更新. Android把xml语言转化成GPU能够识别的资源从而渲染到屏幕上,是通过Display List来实现的,一个Display List对象中基本上包含了所有GPU需要的渲染信息,Display List中包含了GPU可能需要的常用的资源列表,同时也包含了Open GL命令列表.
在某个视图第一次需要被渲染时,Display List就会被创建,当视图需要显示在屏幕时,会执行GPU的相关指令来进行渲染.
从上图可以看出
 只是View属性改变时,只是参考GPU内存中的已经存在,然后执行相关Open GL进行渲染, InvaliDated View也不会重新创建Display List View 布局改变,比如可见性,大小等  优化点 概述 渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。 对于CPU,应该尽量减少布局的层级深度,CPU减少measure等操作的时间,而对于GPU主要是减少不必要的过度绘制.
过度绘制 过度绘制是指同一帧内一个像素点绘制了多次,通过查看overdraw(开发者选项-&gt; 调试GPU过度绘制) 颜色代表了像素点过度绘制的次数:
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" class="link black dim">
        Android事件传递机制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Touch事件处理 Activity中的Touch事件处理函数 有touch事件来的时候,会调用Activity的dispatchTouchEvent()派发事件,然后会调用getWindow().superDispatchTouchEvent(ev)派发事件,最终会调用布局中的View.
public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 如果View中没有消耗事件,最后会调用Activity的onTouchEvent()处理.
View的Touch事件处理 View的Touch事件处理特性  View中的Touch事件一个是View控件的Touch事件处理,一个是ViewGroup控件的Touch事件处理,二者处理方式有所不同 View的Touch事件处理是先有子View控件处理,子View控件没有消耗,然后有父View控件进行处理. 对于ViewGroup控件可以通过相关的方法拦截Touch事件 View中的Touch事件处理会先调用dispatchTouchEvent()分发,然后调用onTouch()处理,未处理会调用onTouchEvent()处理.View控件还是ViewGroup控件处理逻辑都是一致  View控件的Touch事件处理. View处理Touch事件时首先被调用的是dispatchTouchEvent(),此方法的主要工作是调用恰当的方法进行处理.
public boolean dispatchTouchEvent(MotionEvent event) { ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } .
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" class="link black dim">
        Android事件传递机制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Touch事件处理 Activity中的Touch事件处理函数 有touch事件来的时候,会调用Activity的dispatchTouchEvent()派发事件,然后会调用getWindow().superDispatchTouchEvent(ev)派发事件,最终会调用布局中的View.
public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 如果View中没有消耗事件,最后会调用Activity的onTouchEvent()处理.
View的Touch事件处理 View的Touch事件处理特性  View中的Touch事件一个是View控件的Touch事件处理,一个是ViewGroup控件的Touch事件处理,二者处理方式有所不同 View的Touch事件处理是先有子View控件处理,子View控件没有消耗,然后有父View控件进行处理. 对于ViewGroup控件可以通过相关的方法拦截Touch事件 View中的Touch事件处理会先调用dispatchTouchEvent()分发,然后调用onTouch()处理,未处理会调用onTouchEvent()处理.View控件还是ViewGroup控件处理逻辑都是一致  View控件的Touch事件处理. View处理Touch事件时首先被调用的是dispatchTouchEvent(),此方法的主要工作是调用恰当的方法进行处理.
public boolean dispatchTouchEvent(MotionEvent event) { ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } .
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/android_base/content-provider/2014-11-08-contentprovider/" class="link black dim">
        ContentProvider
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      什么是Android中的Content Provider Content Provider是用于管理访问结构化数据集的一种组件，最经常管理数据集是数据库。content provider会封装数据，提供数据安全的机制。content provider用于一个进程与另一个运行中的进程的数据连接。 Notice:
当不打算共享数据给其他应用时，不需要定义自己的Content Provider.
Content Provider如何表示数据的呢？ Content Provider呈现数据是通过一个或多个表，类似与数据库，使用Content Provider跟使用数据库相类似。
如何访问Content Povider? Content Provider的访问很简单
 定义Uri 获取ContentResolver对象 使用ContentResolver对象进行相关的操作。 配置访问时要求的权限  如何定义Uri，以及Uri到底是做什么用的？ Uri是URI的引用，URI是Uniform Resource Identifier(统一资源标识符)简称，用于标识某一资源名称的, 组成形式：协议://authority／path。
ContentResolver使用的Uri是用于标识内容提供者的数据，组成形式：content://authority/path如果使用Content Provider共享的数据是数据库，那么path就是操作的table
/*填入要操作的数据的内容提供者的字符串*/ Uri uri = Uri.parse(&quot; &quot;); ContentResolver能够进行哪些相关的操作 可能（这里使用可能是因为要看Content Provider具体实现，也许访问的Content Provider只支持其中部分操作）支持的操作如下：
 insert delete update query  如何insert插入数据？ 可以像这样：
{% highlight ruby %} /1. 定义要操作的Uri（记得初始化）/ Uri mUri; /2. 定义ContentValues对象，用于保存要插入的数据/ ContentValues contentValues= new ContentValues(); contentValues.put(); contentValues.pust(); &hellip; /3 获取ContentResolver对象/ ContentResolver resolver = getContentResolver(); /4 插入数据/ resolver.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/android_base/content-provider/2014-11-08-contentprovider/" class="link black dim">
        ContentProvider
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      什么是Android中的Content Provider Content Provider是用于管理访问结构化数据集的一种组件，最经常管理数据集是数据库。content provider会封装数据，提供数据安全的机制。content provider用于一个进程与另一个运行中的进程的数据连接。 Notice:
当不打算共享数据给其他应用时，不需要定义自己的Content Provider.
Content Provider如何表示数据的呢？ Content Provider呈现数据是通过一个或多个表，类似与数据库，使用Content Provider跟使用数据库相类似。
如何访问Content Povider? Content Provider的访问很简单
 定义Uri 获取ContentResolver对象 使用ContentResolver对象进行相关的操作。 配置访问时要求的权限  如何定义Uri，以及Uri到底是做什么用的？ Uri是URI的引用，URI是Uniform Resource Identifier(统一资源标识符)简称，用于标识某一资源名称的, 组成形式：协议://authority／path。
ContentResolver使用的Uri是用于标识内容提供者的数据，组成形式：content://authority/path如果使用Content Provider共享的数据是数据库，那么path就是操作的table
/*填入要操作的数据的内容提供者的字符串*/ Uri uri = Uri.parse(&quot; &quot;); ContentResolver能够进行哪些相关的操作 可能（这里使用可能是因为要看Content Provider具体实现，也许访问的Content Provider只支持其中部分操作）支持的操作如下：
 insert delete update query  如何insert插入数据？ 可以像这样：
{% highlight ruby %} /1. 定义要操作的Uri（记得初始化）/ Uri mUri; /2. 定义ContentValues对象，用于保存要插入的数据/ ContentValues contentValues= new ContentValues(); contentValues.put(); contentValues.pust(); &hellip; /3 获取ContentResolver对象/ ContentResolver resolver = getContentResolver(); /4 插入数据/ resolver.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/android_base/server/2014-10-31-services/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      基础 什么是Android中的Serice？ Service是一个长期运行在后台不提供用户界面的组件。
Service听起来像是一个线程，它们有什么区别？  线程独立主线程（UI线程）之外，而Service可以运行在主线程（默认情况下)中，也可以不在其中。 线程一旦被启动，只有满足相应的条件才能停止，而Service开启，可以通过stopService()或者unbindService()来停止。  Service如何启动呢？   started ： 在组件(例如activity)中调用startService()，一旦启动将会长时间运行在后台，通常started的服务用于执行单个操作并且不需要返回结果给开启者。例如下载，当完成下载，应该调用stopSelf()方法&quot;自杀&rdquo;。 bound : 在组件中调用bindService()方法，bound的服务允许组件发送请求，获取结果，甚至可以进行进程间通信（IPC）,当service没有被绑定时，service对象将会被销毁。    Notice: service默认运行在主进程的主线程中，这就意味着如果service要处理耗时操作或者阻塞操作(例如Map3播放，联网，蓝牙连接），应该在服务中开启工作线程来做这些工作，通过这种方式可以减少应用无响应(Application Not Responding ANR)的发生。
 Started Service 如何定义Started Service呢？ 继承Service或者IntentService
在manifest文件中配置Service
&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=&quot;....&quot; /&gt; ... &lt;/application&gt; &lt;/manifest&gt; Service和IntentService怎么选择使用哪一个呢？  对于单个操作可以使用IntentService，IntentService开启一个工作线程，
当onHandlentent()函数执行完毕，service就会自杀，部分源码是这样的  	private final class ServiceHandler extends Handler { @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); //处理完操作就会自杀， stopSelf(msg.arg1); } }  较复杂逻辑的要继承Service来完成了。 IntentService使用比较简单只需实现onHandlentent()方法。  继承Service应该覆写哪些方法呢？ 所以要覆写三个方法。
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/android_base/server/2014-10-31-services/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      基础 什么是Android中的Serice？ Service是一个长期运行在后台不提供用户界面的组件。
Service听起来像是一个线程，它们有什么区别？  线程独立主线程（UI线程）之外，而Service可以运行在主线程（默认情况下)中，也可以不在其中。 线程一旦被启动，只有满足相应的条件才能停止，而Service开启，可以通过stopService()或者unbindService()来停止。  Service如何启动呢？   started ： 在组件(例如activity)中调用startService()，一旦启动将会长时间运行在后台，通常started的服务用于执行单个操作并且不需要返回结果给开启者。例如下载，当完成下载，应该调用stopSelf()方法&quot;自杀&rdquo;。 bound : 在组件中调用bindService()方法，bound的服务允许组件发送请求，获取结果，甚至可以进行进程间通信（IPC）,当service没有被绑定时，service对象将会被销毁。    Notice: service默认运行在主进程的主线程中，这就意味着如果service要处理耗时操作或者阻塞操作(例如Map3播放，联网，蓝牙连接），应该在服务中开启工作线程来做这些工作，通过这种方式可以减少应用无响应(Application Not Responding ANR)的发生。
 Started Service 如何定义Started Service呢？ 继承Service或者IntentService
在manifest文件中配置Service
&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;service android:name=&quot;....&quot; /&gt; ... &lt;/application&gt; &lt;/manifest&gt; Service和IntentService怎么选择使用哪一个呢？  对于单个操作可以使用IntentService，IntentService开启一个工作线程，
当onHandlentent()函数执行完毕，service就会自杀，部分源码是这样的  	private final class ServiceHandler extends Handler { @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); //处理完操作就会自杀， stopSelf(msg.arg1); } }  较复杂逻辑的要继承Service来完成了。 IntentService使用比较简单只需实现onHandlentent()方法。  继承Service应该覆写哪些方法呢？ 所以要覆写三个方法。
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/android_base/server/2014-11-01-boundservices/" class="link black dim">
        Bound Services
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="基础">基础</h3>
<h4 id="如何绑定service">如何绑定service?</h4>
<ol>
<li>创建一个bound service</li>
<li>在组件中调用bindService()方法进行绑定</li>
</ol>
<h4 id="如何创建一个bound-service呢">如何创建一个bound Service呢？</h4>
<p>继承Service，用于绑定的类，首先，必须提供一个IBinder用于与客户端(例如Activity)<br>
交互,有三种方式可以提供此IBinder,每一种方式又有不同的实现方式。</p>
<ol>
<li>继承Binder(实现了IBinder)类</li>
<li>使用Messenger</li>
<li>使用AIDL</li>
</ol>
<p>其次是在onBind()中返回IBinder</p>
<blockquote>
<p>**Notice:**多个clients连接到service时，只在第一次绑定时调用onBind()方法获取<br>
IBinder对象，对于其他的clients，系统直接传递一个IBinder，不会再调<br>
用onBind()方法.</p>
</blockquote>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/android_base/server/2014-11-01-boundservices/" class="link black dim">
        Bound Services
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="基础">基础</h3>
<h4 id="如何绑定service">如何绑定service?</h4>
<ol>
<li>创建一个bound service</li>
<li>在组件中调用bindService()方法进行绑定</li>
</ol>
<h4 id="如何创建一个bound-service呢">如何创建一个bound Service呢？</h4>
<p>继承Service，用于绑定的类，首先，必须提供一个IBinder用于与客户端(例如Activity)<br>
交互,有三种方式可以提供此IBinder,每一种方式又有不同的实现方式。</p>
<ol>
<li>继承Binder(实现了IBinder)类</li>
<li>使用Messenger</li>
<li>使用AIDL</li>
</ol>
<p>其次是在onBind()中返回IBinder</p>
<blockquote>
<p>**Notice:**多个clients连接到service时，只在第一次绑定时调用onBind()方法获取<br>
IBinder对象，对于其他的clients，系统直接传递一个IBinder，不会再调<br>
用onBind()方法.</p>
</blockquote>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/android_base/activity/2014-11-25-fragment/" class="link black dim">
        Fragment Usage
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="使用fragment实现代码与布局的复用">使用Fragment实现代码与布局的复用</h3>
<p>源码是 <strong><a href="https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample">Androidbase / Fragment / FragmentExample /</a></strong> 中的<strong>DynamicFragment</strong>相关的代码。</p>
<p>实现的效果：在手机中处理title与content显示在不同的界面,在平板中左边显示title,右边显示content。<br>
<a href="https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/fragments.png">查看效果图</a></p>
<p>实现的思路： 在手机中加载的布局和平板加载的布局肯定不同，要分别定义不同的布局。在手机中点击title，跳转到另一界面显示content，可以使用两个fragment分别让activity关联。在平板中不涉及界面的跳转，可以在布局文件中使用**&lt;fragment&gt;**标签来定义。</p>
<p>实现的步骤：</p>
<ol>
<li>定义不同的布局，在本例中定义了两个布局文件activity_dynamic_fragment,一个是在layout中定义（用于手机使用）,一个是layout-large中定义(用于平板)。</li>
<li>定义title的fragment和content的fragment</li>
<li>在Activity的onCreate()方法中content相关的view是否存在，不存在就是手机设备要把title的fragment加到activity中。</li>
<li>title点击处理使用了回调的方式，手机的处理方式是添加content的fragment,而平板的处理方式是获取content的fragment来更新。</li>
</ol>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/android_base/activity/2014-11-25-fragment/" class="link black dim">
        Fragment Usage
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="使用fragment实现代码与布局的复用">使用Fragment实现代码与布局的复用</h3>
<p>源码是 <strong><a href="https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample">Androidbase / Fragment / FragmentExample /</a></strong> 中的<strong>DynamicFragment</strong>相关的代码。</p>
<p>实现的效果：在手机中处理title与content显示在不同的界面,在平板中左边显示title,右边显示content。<br>
<a href="https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/fragments.png">查看效果图</a></p>
<p>实现的思路： 在手机中加载的布局和平板加载的布局肯定不同，要分别定义不同的布局。在手机中点击title，跳转到另一界面显示content，可以使用两个fragment分别让activity关联。在平板中不涉及界面的跳转，可以在布局文件中使用**&lt;fragment&gt;**标签来定义。</p>
<p>实现的步骤：</p>
<ol>
<li>定义不同的布局，在本例中定义了两个布局文件activity_dynamic_fragment,一个是在layout中定义（用于手机使用）,一个是layout-large中定义(用于平板)。</li>
<li>定义title的fragment和content的fragment</li>
<li>在Activity的onCreate()方法中content相关的view是否存在，不存在就是手机设备要把title的fragment加到activity中。</li>
<li>title点击处理使用了回调的方式，手机的处理方式是添加content的fragment,而平板的处理方式是获取content的fragment来更新。</li>
</ol>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/android_base/activity/2014-11-18-fragment/" class="link black dim">
        Fragment
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="什么是fragment">什么是Fragment？</h3>
<p>Fragment不是Activity，但是需要内嵌到Activtiy中，Fragment不是容器（viewGroup或者其子类），通常Fragment创建ViewGroup.<br>
Fragment代表的是一种行为或者Activity的用户界面的一部分。</p>
<h3 id="为什么要使用fragment呢">为什么要使用Fragment呢？</h3>
<p>Android是在3.0时引入的Fragment，为了更好的支持大屏幕设备（平板）。使用Fragment来封装UI和Java代码，提高了复用性。</p>
<h3 id="什么时候使用fragment呢">什么时候使用Fragment呢？</h3>
<ul>
<li>逻辑共享：不同设备和屏幕尺寸之间共享UI和逻辑，通常用于平板电脑</li>
<li>回退导航：把fragment添加到堆栈中，当回退时，就会出栈，这种实现方式避免了activity的重建</li>
<li>整体滑动的效果：与ViewPager一起使用实现整体滑动的效果</li>
</ul>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/android_base/activity/2014-11-18-fragment/" class="link black dim">
        Fragment
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="什么是fragment">什么是Fragment？</h3>
<p>Fragment不是Activity，但是需要内嵌到Activtiy中，Fragment不是容器（viewGroup或者其子类），通常Fragment创建ViewGroup.<br>
Fragment代表的是一种行为或者Activity的用户界面的一部分。</p>
<h3 id="为什么要使用fragment呢">为什么要使用Fragment呢？</h3>
<p>Android是在3.0时引入的Fragment，为了更好的支持大屏幕设备（平板）。使用Fragment来封装UI和Java代码，提高了复用性。</p>
<h3 id="什么时候使用fragment呢">什么时候使用Fragment呢？</h3>
<ul>
<li>逻辑共享：不同设备和屏幕尺寸之间共享UI和逻辑，通常用于平板电脑</li>
<li>回退导航：把fragment添加到堆栈中，当回退时，就会出栈，这种实现方式避免了activity的重建</li>
<li>整体滑动的效果：与ViewPager一起使用实现整体滑动的效果</li>
</ul>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/android_base/activity/2014-10-30-activity/" class="link black dim">
        Activity
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="创建activity">创建Activity</h3>
<h4 id="什么是android中的activity">什么是Android中的Activity？</h4>
<blockquote>
<p>一个activity是提供一个界面，用于与用户交互（打电话，发邮件等）的应用组件。</p>
</blockquote>
<h4 id="如何创建一个activity呢">如何创建一个Activity呢？</h4>
<blockquote>
<ul>
<li>在layout中定义个布局文件</li>
<li>定义一个Activity（或者已存在的Activity子类）的子类，并实现相关的方法.</li>
<li>在AndroidManifest.xml中配置Activity</li>
</ul>
</blockquote>
<h4 id="定义一个activity子类时要实现哪些方法呢">定义一个Activity子类时，要实现哪些方法呢</h4>
<ul>
<li>onCreate(): 你必须实现这个方法，系统会在创建activity时，调用此方法，在这个方法中初始化的activity重要部分，尤其是调用setContentView()使用资源资源来设置activity的界面。</li>
<li>onPause(): 当用户将要离开activity时，系统调用的第一方法就是此方法，通常保存在当前会话中的变化的信息。</li>
<li><a href="http://wangfei1991.github.io/Blog/android%E5%9F%BA%E7%A1%80/2014/10/30/activity/#activity-7">更多的activity信息请看管理生命周期</a></li>
</ul>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/android_base/activity/2014-10-30-activity/" class="link black dim">
        Activity
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="创建activity">创建Activity</h3>
<h4 id="什么是android中的activity">什么是Android中的Activity？</h4>
<blockquote>
<p>一个activity是提供一个界面，用于与用户交互（打电话，发邮件等）的应用组件。</p>
</blockquote>
<h4 id="如何创建一个activity呢">如何创建一个Activity呢？</h4>
<blockquote>
<ul>
<li>在layout中定义个布局文件</li>
<li>定义一个Activity（或者已存在的Activity子类）的子类，并实现相关的方法.</li>
<li>在AndroidManifest.xml中配置Activity</li>
</ul>
</blockquote>
<h4 id="定义一个activity子类时要实现哪些方法呢">定义一个Activity子类时，要实现哪些方法呢</h4>
<ul>
<li>onCreate(): 你必须实现这个方法，系统会在创建activity时，调用此方法，在这个方法中初始化的activity重要部分，尤其是调用setContentView()使用资源资源来设置activity的界面。</li>
<li>onPause(): 当用户将要离开activity时，系统调用的第一方法就是此方法，通常保存在当前会话中的变化的信息。</li>
<li><a href="http://wangfei1991.github.io/Blog/android%E5%9F%BA%E7%A1%80/2014/10/30/activity/#activity-7">更多的activity信息请看管理生命周期</a></li>
</ul>
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/ui/2014-11-25-menuandactionbar/" class="link black dim">
        menu和action bar
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      从android3.0开始传统的6-items的菜单被action bar的形式所取代，在这篇文章中，将使用action bar方式实现menu，并且使用的是支持库的方式，这样可以解决版本兼容问题。
三种菜单类型  options menu context menu popup menu  如何定义menu  在res/menu/下使用xml中定义menu item, 代码中填充菜单 直接在代码中创建menu，添加menu条目   NOTICE： 最好使用menu资源来定义menu items
   It&rsquo;s easier to visualize the menu structure in XML. It separates the content for the menu from your application&rsquo;s behavioral code. It allows you to create alternative menu configurations for different platform versions, screen sizes, and other configurations by leveraging the app resources framework.   下面就是不同类型menu的创建方式
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/ui/2014-11-25-menuandactionbar/" class="link black dim">
        menu和action bar
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      从android3.0开始传统的6-items的菜单被action bar的形式所取代，在这篇文章中，将使用action bar方式实现menu，并且使用的是支持库的方式，这样可以解决版本兼容问题。
三种菜单类型  options menu context menu popup menu  如何定义menu  在res/menu/下使用xml中定义menu item, 代码中填充菜单 直接在代码中创建menu，添加menu条目   NOTICE： 最好使用menu资源来定义menu items
   It&rsquo;s easier to visualize the menu structure in XML. It separates the content for the menu from your application&rsquo;s behavioral code. It allows you to create alternative menu configurations for different platform versions, screen sizes, and other configurations by leveraging the app resources framework.   下面就是不同类型menu的创建方式
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/ui/2014-11-26-menuandactionbar/" class="link black dim">
        menu和actionbar
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      context menu的创建 context menu可以使用到任意view上，但通常使用在ListView，GridView的items上，或者其他用户能够执行item操作的view集合。
有两种方式可以创建context menu
  In a floating context menu. A menu appears as a floating list of menu items (similar to a dialog) when the user performs a long-click (press and hold) on a view that declares support for a context menu. Users can perform a contextual action on one item at a time. In the contextual action mode. This mode is a system implementation of ActionMode that displays a contextual action bar at the top of the screen with action items that affect the selected item(s).
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/ui/2014-11-26-menuandactionbar/" class="link black dim">
        menu和actionbar
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      context menu的创建 context menu可以使用到任意view上，但通常使用在ListView，GridView的items上，或者其他用户能够执行item操作的view集合。
有两种方式可以创建context menu
  In a floating context menu. A menu appears as a floating list of menu items (similar to a dialog) when the user performs a long-click (press and hold) on a view that declares support for a context menu. Users can perform a contextual action on one item at a time. In the contextual action mode. This mode is a system implementation of ActionMode that displays a contextual action bar at the top of the screen with action items that affect the selected item(s).
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/" class="link black dim">
        异步处理一
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      异步处理 Handler A Handler allows you to send and process Message and Runnable objects associated with a thread&rsquo;s MessageQueue. Each Handler instance is associated with a single thread and that thread&rsquo;s message queue.
从描述可以总结出Handler一些特性:
 每个Handler实例都会与一个线程以及线程的messageQueue关联. 发送消息. 处理消息,处理Runnable.  Handler的处理机制示意图 从上图可以看出其实,Handler机制就是:Looper不断从MessageQueue中获取Message,然后Hanlder处理消息
从上图可以看出要分析的问题:
 looper如何从MessageQueue中获取需要处理的message Handler如何处理消息 Handler如何发送消息  再讲前面的问题之前还是要先了解一个问题,就是Handler实例如何与线程,线程的messageQueue关联的?
Handler与线程,MessageQueue关联 下面以默认构造函数来说明.
public Handler() { this(null, false); } public Handler(Callback callback, boolean async) { ... mLooper = Looper.myLooper(); //获取looper if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread that has not called Looper.
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100  mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="https://wfeii.github.io/posts/_posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/" class="link black dim">
        异步处理一
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      异步处理 Handler A Handler allows you to send and process Message and Runnable objects associated with a thread&rsquo;s MessageQueue. Each Handler instance is associated with a single thread and that thread&rsquo;s message queue.
从描述可以总结出Handler一些特性:
 每个Handler实例都会与一个线程以及线程的messageQueue关联. 发送消息. 处理消息,处理Runnable.  Handler的处理机制示意图 从上图可以看出其实,Handler机制就是:Looper不断从MessageQueue中获取Message,然后Hanlder处理消息
从上图可以看出要分析的问题:
 looper如何从MessageQueue中获取需要处理的message Handler如何处理消息 Handler如何发送消息  再讲前面的问题之前还是要先了解一个问题,就是Handler实例如何与线程,线程的messageQueue关联的?
Handler与线程,MessageQueue关联 下面以默认构造函数来说明.
public Handler() { this(null, false); } public Handler(Callback callback, boolean async) { ... mLooper = Looper.myLooper(); //获取looper if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread that has not called Looper.
    </div>
  </div>
</div>

        </div>
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://wfeii.github.io/" >
    &copy;  音视频技术部 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
