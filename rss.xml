<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>技术部的那点事</title>
        <link>https://example.com/</link>
        <description>MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</description>
        <generator>Hugo 0.72.0 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>wangfei199101@gmail.com (快马夜小刀)</managingEditor>
        
        
            <webMaster>wangfei199101@gmail.com (快马夜小刀)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Sun, 14 Jun 2020 09:11:12 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://example.com/rss.xml" />
        
        
            <item>
                <title>升级Gradle3.0</title>
                <link>https://example.com/posts/android_studio/gradle/2017-11-21-%E5%8D%87%E7%BA%A7gradle3.0/</link>
                <guid isPermaLink="true">https://example.com/posts/android_studio/gradle/2017-11-21-%E5%8D%87%E7%BA%A7gradle3.0/</guid>
                <pubDate>Tue, 21 Nov 2017 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Android Gradle 3.0.0插件是一个大版本的升级，对多个module带来了显著的性能提升。但同时也改变了一些此插件的行为，DSL和APIS.&lt;/p&gt;
&lt;p&gt;升级到Gradle3.0.0会带来以下的性能提升：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于构建per-call dexing提高了构建速度，每个类编译成独立的DEX文件，并且仅仅被修改的类重新编译。为了提高构建APK的速度，需要设置minSdkVersion到20，或者更低但使用 &lt;a href=&#34;https://developer.android.com/studio/build/multidex.html#mdex-pre-l&#34;&gt;legacy multi-dex&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;当改变依赖项时，Gradle通过不访问依赖项的API的module不重新编译的方式来提高构建速度。通过使用Gradle的新的依赖项的配置(implementation, api, compileOnly, and runtimeOnly)，可以严格的控制依赖项的API的暴露。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;升级&#34;&gt;升级&lt;/h2&gt;
&lt;h3 id=&#34;配置gradle版本&#34;&gt;配置Gradle版本&lt;/h3&gt;
&lt;p&gt;Android plugin 3.0.0 要求Gradle4.1或者更高的版本。&lt;/p&gt;
&lt;p&gt;需要在&lt;strong&gt;gradle-wrapper.properties&lt;/strong&gt;文件中配置下列的内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;distributionUrl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;\&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//services.gradle.org/distributions/gradle-4.1-all.zip
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;配置android-gradle-plugin&#34;&gt;配置Android Gradle Plugin&lt;/h3&gt;
&lt;p&gt;如果使用Android Studio 3.0或者更新版本，会提示自动更新到最新版本的Android plugin。对于手动更新工程，在工程级下的 &lt;code&gt;build.gradle&lt;/code&gt; 配置如下的内容。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;buildscript&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;repositories&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// You need to add the following repository to download the
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// new plugin.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;google&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;dependencies&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;classpath&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;android&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;tools&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gradle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;NOTICE:&lt;/p&gt;
&lt;p&gt;对于多模块和复合构建，如果Android插件每次构建不止一次加载，则可能会出现构建错误，可以查看&lt;strong&gt;常见错误&lt;/strong&gt;进行修复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;新的依赖配置接口&#34;&gt;新的依赖配置接口&lt;/h2&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;要理解旧的Gradle插件2.0构建系统的局限性，请考虑以下具有多层模块的项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/Gradle/gradle_project_mul_modle.png?raw=true/&#34; alt=&#34;多模块&#34;&gt;&lt;/p&gt;
&lt;p&gt;看最底层的模块，基本上可以做出两种不同的改变：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Implementation change: 内部实现改变，不修改模块的外部接口&lt;/li&gt;
&lt;li&gt;Application binary interface (ABI) change: 修改模块的外部接口&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: 在下面的图形中，重新编译的模块将会以红色高亮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;implementation-change&#34;&gt;Implementation change&lt;/h4&gt;
&lt;p&gt;由于模块的外部接口不变，Gradle将只重新编译该模块。所有的引用的模块都将保持不变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/Gradle/gradle_project_mul_module_implementation_change.png?raw=true/&#34; alt=&#34;多模块&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下没问题。&lt;/p&gt;
&lt;h4 id=&#34;abi-change&#34;&gt;ABI change&lt;/h4&gt;
&lt;p&gt;当外部模块的接口改变，那引用此模块的module也需要重新编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/Gradle/gradle_project_mul_modult_two_layout.png?raw=true/&#34; alt=&#34;two_layout&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是这些模块可能直接通过自己的接口暴露底层模块的一部分！所以为了完全安全，还需要重新编译。&lt;/p&gt;
&lt;p&gt;因此，Gradle将有效地需要重新编译所有模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/Gradle/gradle_project_mul_modult_final.png?raw=true&#34; alt=&#34;final state&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在我们遇到了一个很大的问题：一个代码更改导致所有模块被重新编译。造成这种情况的根本原因是Gradle不知道是否通过另一个模块泄漏了此模块的接口。&lt;/p&gt;
&lt;h3 id=&#34;android-gradle插件30的修改&#34;&gt;Android Gradle插件3.0的修改&lt;/h3&gt;
&lt;p&gt;最新的Android Gradle 3.0插件要求您明确定义是否泄漏模块的接口。基于此来判断是否重新编译。&lt;/p&gt;
&lt;p&gt;因此 &lt;code&gt;compile&lt;/code&gt; 相关的接口被弃用了，引入了如下的接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;api&lt;/code&gt;: 可以通过自己的接口泄漏了这个模块的接口，这意味着和旧版本的&lt;code&gt;compile&lt;/code&gt;完全一致。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;implementation&lt;/code&gt;: 模块的接口只能自己使用，不能泄露给更上层的module中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api配置依赖&#34;&gt;api配置依赖&lt;/h4&gt;
&lt;p&gt;从理论上讲，你可以简单地用api依赖替换所有的编译依赖，但是仍然会导致所有的module都被重新编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/Gradle/gradle_project_mul_modult_final.png?raw=true&#34; alt=&#34;final state&#34;&gt;&lt;/p&gt;
&lt;p&gt;最好的方式是使用&lt;code&gt;implementation&lt;/code&gt;代替所有的&lt;code&gt;compile&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;implementation配置依赖&#34;&gt;implementation配置依赖&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;implementation&lt;/code&gt;会减少module重新编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/Gradle/gradle_project_mul_modult_two_layout.png?raw=true/&#34; alt=&#34;implementation&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Notice: 当想要泄漏底层的module接口给更上层的接口使用&lt;code&gt;api&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;其他依赖配置&#34;&gt;其他依赖配置&lt;/h4&gt;
&lt;p&gt;由于已经接口都已变化，团队也利用这个机会最终给予其他配置适当的名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;provided&lt;/code&gt; 修改为&lt;code&gt;compileOnly&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apk&lt;/code&gt; 修改为 &lt;code&gt;runtimeOnly&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;其他的比如testCompile都已重新修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见错误&#34;&gt;常见错误&lt;/h2&gt;
&lt;h3 id=&#34;flavor相关的错误&#34;&gt;Flavor相关的错误&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;nl&#34;&gt;Error:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;All&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flavors&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;must&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;belong&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;named&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flavor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dimension&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;The&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flavor&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flavor_name&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;assigned&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;flavor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dimension&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现在插件要求flavors必须属于一个flavor dimension，即使是只有一个flover。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Specifies two flavor dimensions.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flavorDimensions&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;tier&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;productFlavors&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;dimension&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;tier&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;paid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;dimension&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;tier&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;依赖相关的配置错误&#34;&gt;依赖相关的配置错误&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;nl&#34;&gt;Error:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Unable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@debug&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compileClasspath&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Could&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;project&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nl&#34;&gt;Error:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Unable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dependency&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@release&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compileClasspath&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Could&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;project&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用变体的依赖关系解决方案，您不再需要使用特定于变体的配置（例如freeDebugImplementation）来获取本地模块依赖关系 - 插件会自动提供配置。&lt;/p&gt;
&lt;p&gt;应该使用下面的配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;dependencies&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// This is the old method and no longer works for local
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// library modules:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// debugImplementation project(path: &amp;#39;:library&amp;#39;, configuration: &amp;#39;debug&amp;#39;)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// releaseImplementation project(path: &amp;#39;:library&amp;#39;, configuration: &amp;#39;release&amp;#39;)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Instead, simply use the following to take advantage of
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// variant-aware dependency resolution. You can learn more about
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// the &amp;#39;implementation&amp;#39; configuration in the section about
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// new dependency configurations.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;implementation&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;project&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;library&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// You can, however, keep using variant-specific configurations when
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// targeting external dependencies. The following line adds &amp;#39;app-magic&amp;#39;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// as a dependency to only the &amp;#34;debug&amp;#34; version of your module.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;debugImplementation&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;example&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;android&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;magic&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;finished&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;found&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;com.meitu.gradle.eva.EvaChannelInfoPluginTest&amp;#34;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Empty&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;suite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;是因为Android Studio没有把build/classes/groovy/test添加到 JUnitStarter的classpath中，具体问题以及临时解决方案看此链接&lt;a href=&#34;https://issuetracker.google.com/issues/65712492&#34;&gt; IDE didn&#39;t add &lt;code&gt;build/classes/groovy/test&lt;/code&gt; to JUnitStarter classpath&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;nl&#34;&gt;Error:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Failed&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Could&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;project&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mylibrary&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Required&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;by&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;project&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;考虑一下应用程序配置了一个名为“staging”的build type，但是它的一个依赖库不存在此build type。 当编译应用程序的“staging”版本时，它将不知道要使用依赖库的哪个版本，并且会看到上述类似的错误。&lt;/p&gt;
&lt;p&gt;Android Gradle Plugin包含DSL元素，可帮助控制Gradle解决应用程序和依赖项之间的变体匹配不可行的情况。 请参阅下表以确定应使用哪个DSL属性来解决与变体依赖关系匹配相关的某些构建错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;app包含，但依赖库不包含&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;错误原因：&lt;/p&gt;
&lt;p&gt;app包含一个依赖库不包含的build type， 比如，app包含“staging”的build type，但依赖库包含“debug”和“release”的build Type。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Notice: 当依赖库包含app不包含的build type时，不存在问题。这是因为根本不需要依赖库构建 build Type。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方案：
使用matchingFallbacks为给定的build type指定替代匹配，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;android&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;buildTypes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;debug&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;release&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;staging&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// Specifies a sorted list of fallback build types that the
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// plugin should try to use when a dependency does not include a
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// &amp;#34;staging&amp;#34; build type. You may specify as many fallbacks as you
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// like, and the plugin selects the first build type that&amp;#39;s
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// available in the dependency.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;matchingFallbacks&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qa&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;特定flavor dimension，app存在而依赖库不存在的flover&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;错误原因：&lt;/p&gt;
&lt;p&gt;对于app及其依赖库中存在的特定flavor dimension，但app包含库不包含的flavor。&lt;/p&gt;
&lt;p&gt;比如，app和依赖都包含一个 &amp;quot;tier&amp;quot; 的flavor dimension。然而app中&amp;quot;tier&amp;quot; 包含 &amp;quot;free&amp;quot;和&amp;quot;paid&amp;quot;，但依赖库仅仅包含&amp;quot;demo&amp;quot; and &amp;quot;paid&amp;quot;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Notice: 对于存在于app及其依赖库的给定flavor dimension，当库包含app所不具备的flavor时，不存在任何问题。 那是因为android gradle plun根本就不会从依赖中请求app不包含的flavor。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;使用matchingFallbacks为app的“free”的flavor指定替代匹配，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// In the app&amp;#39;s build.gradle file.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;android&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;defaultConfig&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Do not configure matchingFallbacks in the defaultConfig block.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// Instead, you must specify fallbacks for a given product flavor in the
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// productFlavors block, as shown below.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;flavorDimensions&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tier&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;productFlavors&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;paid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;dimension&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tier&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// Because the dependency already includes a &amp;#34;paid&amp;#34; flavor in its
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// &amp;#34;tier&amp;#34; dimension, you don&amp;#39;t need to provide a list of fallbacks
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// for the &amp;#34;paid&amp;#34; flavor.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;dimension&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tier&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// Specifies a sorted list of fallback flavors that the plugin
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// should try to use when a dependency&amp;#39;s matching dimension does
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// not include a &amp;#34;free&amp;#34; flavor. You may specify as many
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// fallbacks as you like, and the plugin selects the first flavor
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// that&amp;#39;s available in the dependency&amp;#39;s &amp;#34;tier&amp;#34; dimension.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;matchingFallbacks&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;trial&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;依赖库包含app不支持的flavor dimension&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;错误原因：&lt;/p&gt;
&lt;p&gt;依赖库包含app不支持的flavor dimension。&lt;/p&gt;
&lt;p&gt;比如，依赖库包含“minApi”的flavor dimension，但是app不包含，当构建“freeDebug”版本的时候，插件不知道是使用“minApi23Debug”还是“minApi18Debug”的版本的依赖库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Notice: 当app包含一个flavor dimension，但依赖库不存在这是没问题的。这是因为插件仅仅匹配存在于依赖库里的flavor dimension，比如依赖库不包含ABIs的dimension，app的&amp;quot;freeX86Debug&amp;quot; 仅仅配置依赖库的“freeDebug”版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;defaultConfig&lt;/code&gt;的配置中使用&lt;code&gt;missingDimensionStrategy&lt;/code&gt;指定遗失的dimension。也可以在&lt;code&gt;productFlavors&lt;/code&gt;来复写默认配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;In&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;gradle&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;android&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;defaultConfig&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// Specifies a sorted list of flavors that the plugin should try to use from
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// a given dimension. The following tells the plugin that, when encountering
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// a dependency that includes a &amp;#34;minApi&amp;#34; dimension, it should select the
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// &amp;#34;minApi18&amp;#34; flavor. You can include additional flavor names to provide a
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// sorted list of fallbacks for the dimension.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;missingDimensionStrategy&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minApi&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minApi18&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minApi23&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// You should specify a missingDimensionStrategy property for each
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// dimension that exists in a local dependency but not in your app.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;missingDimensionStrategy&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;abi&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x86&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arm64&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;flavorDimensions&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tier&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;productFlavors&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;dimension&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tier&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// You can override the default selection at the product flavor
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// level by configuring another missingDimensionStrategy property
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// for the &amp;#34;minApi&amp;#34; dimension.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;missingDimensionStrategy&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minApi&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minApi23&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minApi18&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;paid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html&#34;&gt;迁移到Gradle3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/studio/build/build-variants.html&#34;&gt;配置构建变体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jeroenmols.com/blog/2017/06/14/androidstudio3/&#34;&gt;Implementation vs API dependency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/studio/releases/gradle-plugin.html#3-0-0&#34;&gt;Android Plugin for Gradle Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://google.github.io/android-gradle-dsl/current/index.html&#34;&gt;Android Plugin DSL Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groovy-lang.org/&#34;&gt;Groovy官网&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/gradle/">Gradle</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/gradle/">Gradle</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/gradle3.0/">Gradle3.0</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Android Log 分析</title>
                <link>https://example.com/posts/android_base/logcat%E5%88%86%E6%9E%90/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/logcat%E5%88%86%E6%9E%90/</guid>
                <pubDate>Sat, 04 Nov 2017 16:40:12 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;Bug在任何类型的开发中都会存在的，而Bug报告又是定位问题，解决问题的关键。&lt;/p&gt;
&lt;p&gt;Bug报告中包含的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;logcat文件以文字形式存储所有的log信息
&lt;ul&gt;
&lt;li&gt;main 包含了所有的log
&lt;ul&gt;
&lt;li&gt;system log 存储framework相关的log&lt;/li&gt;
&lt;li&gt;event log  进程的正在做的事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dumpsys获取系统运行状态的信息，通过adb shell 可以获取想要的系统信息，内存使用情况的信息等等
&lt;ul&gt;
&lt;li&gt;Activity Manager的状态 - dumpsys activity
&lt;ul&gt;
&lt;li&gt;Package信息 - dumpsys package&lt;/li&gt;
&lt;li&gt;内存使用情况 - dumpsys meminfo&lt;/li&gt;
&lt;li&gt;进程一段时间内的内存使用情况 - dumpsys procstats&lt;/li&gt;
&lt;li&gt;界面相关的状态 - dumpsys gfxinfo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dumpstate 系统运行状态的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;常用命令 ：
adb shell bugreport  获取logcat信息，dumpsys信息，dumpstate信息
adb shell logcat -v threadtime -d 获取logcat文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell logcat -b events -v threadtime -d  获取events log&lt;br&gt;
adb shell logcat -b main -v threadtime -d 获取main log
adb shell dumpsys 获取系统信息。
adb shell dumpstate 获取系统状态信息，dumpstate包含dumpsys&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的部分会细化bug报告中的各部分，描述一个问题给出相关技巧和使用&lt;strong&gt;grep&lt;/strong&gt;来查找相关的log&lt;/p&gt;
&lt;h3 id=&#34;logcat&#34;&gt;&lt;strong&gt;LogCat&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;logcat文件以文字形式存储了所有了的日志信息，&lt;strong&gt;system&lt;/strong&gt; 部分存储了framework的相关log，而 &lt;strong&gt;main&lt;/strong&gt; 包含了所有log。每行log都以 &lt;strong&gt;timestamp PID(Process ID) TID(Thread ID)  log-level&lt;/strong&gt; 开头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\------ SYSTEM LOG (logcat -v threadtime -d *:v) ------
--------- beginning of system  
Blah  
Blah  
Blah  

--------- beginning of main  
Blah   
Blah  
Blah  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;阅读event-log&#34;&gt;&lt;strong&gt;阅读event log&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;event log 里面包含了文字形式的二进格式的log信息，它比logcat里面的信息简洁但是更难理解。当阅读event log的时候，我们应该搜索特定的PID来看进程做了什么，格式为&lt;strong&gt;timestamp PID TID log-level log-tag tag-values.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;log等级包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V: verbose&lt;/li&gt;
&lt;li&gt;D: debug&lt;/li&gt;
&lt;li&gt;I: information&lt;/li&gt;
&lt;li&gt;W: warning&lt;/li&gt;
&lt;li&gt;E: error&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;------ EVENT LOG (logcat -b events -v threadtime -d *:v) ------  
09-28 13:47:34.179   785  5113 I am_proc_bound: [0,23054,com.google.android.gms.unstable]  
09-28 13:47:34.777   785  1975 I am_proc_start: [0,23134,10032,com.android.chrome,broadcast,com.android.chrome/org.chromium.chrome.browser.precache.PrecacheServiceLauncher]  
09-28 13:47:34.806   785  2764 I am_proc_bound: [0,23134,com.android.chrome]  
...  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于Event log标签更详细的信息,可以阅读&lt;a href=&#34;http://download.csdn.net/download/wfeii/9966454&#34;&gt;Event log tags&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;anr和死锁&#34;&gt;&lt;strong&gt;ANR和死锁&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;log能帮助我们找到导致ANR错误和死锁原因。&lt;/p&gt;
&lt;h4 id=&#34;识别无响应的app&#34;&gt;&lt;strong&gt;识别无响应的APP&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;当应用一段时间无响应的时候，通常是由于主线程阻塞了或者是主线程做的事太多。系统会kill掉应用并且把相关的堆栈信息存储在/data/anr目录下。&lt;br&gt;
可以使用&lt;strong&gt;grep am_anr&lt;/strong&gt;在event log找到原因：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &amp;quot;am_anr&amp;quot; bugreport-2015-10-01-18-13-48.txt  
10-01 18:12:49.599  4600  4614 I am_anr  : [0,29761,com.google.android.youtube,953695941,executing service com.google.android.youtube/com.google.android.apps.youtube.app.offline.transfer.OfflineTransferService]  
10-01 18:14:10.211  4600  4614 I am_anr  : [0,30363,com.google.android.apps.plus,953728580,executing service com.google.android.apps.plus/com.google.android.apps.photos.service.PhotosService]  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者在logcat中使用&lt;strong&gt;grep ANR&lt;/strong&gt;来搜索，搜索结果将会包含ANR有关CPU使用的信息。&lt;/p&gt;
&lt;h4 id=&#34;查找堆栈信息&#34;&gt;&lt;strong&gt;查找堆栈信息&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;我们经常可以发现对应的ANR的堆栈信息，确保时间和进程ID匹配正在调查的ANR。然后检查进程的主线的相关堆栈信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要牢记的:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主线程只是说明线程ANR的时候正在做什么，但是不一定是造成ANR的原因（堆栈信息可能是无辜的，有些事可能卡顿了主线程一段时间但是不足以构成ANR）&lt;/li&gt;
&lt;li&gt;可能不止一个堆栈信息，确保浏览正确的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;------ VM TRACES AT LAST ANR (/data/anr/traces.txt: 2015-10-01 18:14:41) ------  

----- pid 30363 at 2015-10-01 18:14:11 -----
Cmd line: com.google.android.apps.plus
Build fingerprint: &#39;google/angler/angler:6.0/MDA89D/2294819:userdebug/dev-keys&#39;
ABI: &#39;arm&#39;
Build type: optimized
Zygote loaded classes=3978 post zygote classes=27
Intern table: 45068 strong; 21 weak
JNI: CheckJNI is off; globals=283 (plus 360 weak)
Libraries: /system/lib/libandroid.so /system/lib/libcompiler_rt.so /system/lib/libjavacrypto.so /system/lib/libjnigraphics.so /system/lib/libmedia_jni.so /system/lib/libwebviewchromium_loader.so libjavacore.so (7)
Heap: 29% free, 21MB/30MB; 32251 objects
Dumping cumulative Gc timings
Total number of allocations 32251
Total bytes allocated 21MB
Total bytes freed 0B
Free memory 9MB
Free memory until GC 9MB
Free memory until OOME 490MB
Total memory 30MB
Max memory 512MB
Zygote space size 1260KB
Total mutator paused time: 0
Total time waiting for GC to complete: 0
Total GC count: 0
Total GC time: 0
Total blocking GC count: 0
Total blocking GC time: 0

suspend all histogram:  Sum: 119.728ms 99% C.I. 0.010ms-107.765ms Avg: 5.442ms Max: 119.562ms
DALVIK THREADS (12):  
&amp;quot;Signal Catcher&amp;quot; daemon prio=5 tid=2 Runnable
  | group=&amp;quot;system&amp;quot; sCount=0 dsCount=0 obj=0x12c400a0 self=0xef460000  
  | sysTid=30368 nice=0 cgrp=default sched=0/0 handle=0xf4a69930  
  | state=R schedstat=( 9021773 5500523 26 ) utm=0 stm=0 core=1 HZ=100  
  | stack=0xf496d000-0xf496f000 stackSize=1014KB  
  | held mutexes= &amp;quot;mutator lock&amp;quot;(shared held)  
  native: #00 pc 0035a217  /system/lib/libart.so (art::DumpNativeStack(std::__1::basic_ostream&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt; &amp;gt;&amp;amp;, int, char const*, art::ArtMethod*, void*)+126)  
  native: #01 pc 0033b03b  /system/lib/libart.so (art::Thread::Dump(std::__1::basic_ostream&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt; &amp;gt;&amp;amp;) const+138)  
  native: #02 pc 00344701  /system/lib/libart.so (art::DumpCheckpoint::Run(art::Thread*)+424)  
  native: #03 pc 00345265  /system/lib/libart.so (art::ThreadList::RunCheckpoint(art::Closure*)+200)  
  native: #04 pc 00345769  /system/lib/libart.so (art::ThreadList::Dump(std::__1::basic_ostream&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt; &amp;gt;&amp;amp;)+124)  
  native: #05 pc 00345e51  /system/lib/libart.so (art::ThreadList::DumpForSigQuit(std::__1::basic_ostream&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt; &amp;gt;&amp;amp;)+312)  
  native: #06 pc 0031f829  /system/lib/libart.so (art::Runtime::DumpForSigQuit(std::__1::basic_ostream&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt; &amp;gt;&amp;amp;)+68)  
  native: #07 pc 00326831  /system/lib/libart.so (art::SignalCatcher::HandleSigQuit()+896)  
  native: #08 pc 003270a1  /system/lib/libart.so (art::SignalCatcher::Run(void*)+324)  
  native: #09 pc 0003f813  /system/lib/libc.so (__pthread_start(void*)+30)  
  native: #10 pc 00019f75  /system/lib/libc.so (__start_thread+6)  
  (no managed stack frames)  

&amp;quot;main&amp;quot; prio=5 tid=1 Suspended  
  | group=&amp;quot;main&amp;quot; sCount=1 dsCount=0 obj=0x747552a0 self=0xf5376500  
  | sysTid=30363 nice=0 cgrp=default sched=0/0 handle=0xf74feb34  
  | state=S schedstat=( 331107086 164153349 851 ) utm=6 stm=27 core=3 HZ=100  
  | stack=0xff00f000-0xff011000 stackSize=8MB  
  | held mutexes=
  kernel: __switch_to+0x7c/0x88  
  kernel: futex_wait_queue_me+0xd4/0x130  
  kernel: futex_wait+0xf0/0x1f4  
  kernel: do_futex+0xcc/0x8f4  
  kernel: compat_SyS_futex+0xd0/0x14c  
  kernel: cpu_switch_to+0x48/0x4c  
  native: #00 pc 000175e8  /system/lib/libc.so (syscall+28)  
  native: #01 pc 000f5ced  /system/lib/libart.so (art::ConditionVariable::Wait(art::Thread*)+80)  
  native: #02 pc 00335353  /system/lib/libart.so (art::Thread::FullSuspendCheck()+838)  
  native: #03 pc 0011d3a7  /system/lib/libart.so (art::ClassLinker::LoadClassMembers(art::Thread*, art::DexFile const&amp;amp;, unsigned char const*, art::Handle&amp;lt;art::mirror::Class&amp;gt;, art::OatFile::OatClass const*)+746)  
  native: #04 pc 0011d81d  /system/lib/libart.so (art::ClassLinker::LoadClass(art::Thread*, art::DexFile const&amp;amp;, art::DexFile::ClassDef const&amp;amp;, art::Handle&amp;lt;art::mirror::Class&amp;gt;)+88)  
  native: #05 pc 00132059  /system/lib/libart.so (art::ClassLinker::DefineClass(art::Thread*, char const*, unsigned int, art::Handle&amp;lt;art::mirror::ClassLoader&amp;gt;, art::DexFile const&amp;amp;, art::DexFile::ClassDef const&amp;amp;)+320)  
  native: #06 pc 001326c1  /system/lib/libart.so (art::ClassLinker::FindClassInPathClassLoader(art::ScopedObjectAccessAlreadyRunnable&amp;amp;, art::Thread*, char const*, unsigned int, art::Handle&amp;lt;art::mirror::ClassLoader&amp;gt;, art::mirror::Class**)+688)  
  native: #07 pc 002cb1a1  /system/lib/libart.so (art::VMClassLoader_findLoadedClass(_JNIEnv*, _jclass*, _jobject*, _jstring*)+264)  
  native: #08 pc 002847fd  /data/dalvik-cache/arm/system@framework@boot.oat (Java_java_lang_VMClassLoader_findLoadedClass__Ljava_lang_ClassLoader_2Ljava_lang_String_2+112)
  at java.lang.VMClassLoader.findLoadedClass!(Native method)  
  at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:362)  
  at java.lang.ClassLoader.loadClass(ClassLoader.java:499)  
  at java.lang.ClassLoader.loadClass(ClassLoader.java:469)  
  at android.app.ActivityThread.installProvider(ActivityThread.java:5141)  
  at android.app.ActivityThread.installContentProviders(ActivityThread.java:4748)  
  at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4688)  
  at android.app.ActivityThread.-wrap1(ActivityThread.java:-1)  
  at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)  
  at android.os.Handler.dispatchMessage(Handler.java:102)
  at android.os.Looper.loop(Looper.java:148)  
  at android.app.ActivityThread.main(ActivityThread.java:5417)  
  at java.lang.reflect.Method.invoke!(Native method)  
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)  
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)    

  ...  
  Stacks for other threads in this process follow  
  ...  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面可以看出是主线程中做了数据库相关的操作，导致了ANR。&lt;/p&gt;
&lt;h4 id=&#34;发现死锁&#34;&gt;&lt;strong&gt;发现死锁&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;死锁常常表现为ANR，因为线程被阻塞。如果死锁触及到系统服务，watchdog最终会kill掉它，在log中会有一条类似&lt;strong&gt;WATCHDOG KILLING SYSTEM PROCESS&lt;/strong&gt;的语句。从用户的角度看，设备会重启，虽然从技术上是运行时重启不是真正的重启。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时重启，系统服务死了并且重启，用户看到设备返回到启动动画&lt;/li&gt;
&lt;li&gt;重启，内核crash了，用户看到设备返回到Google的启动log&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了查找死锁，检查堆栈信息查找类似这样的格式： Thread A等待Thread B持有的东西，Thread B等待线程A等待的东西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;Binder_B&amp;quot; prio=5 tid=73 Blocked  
  | group=&amp;quot;main&amp;quot; sCount=1 dsCount=0 obj=0x13faa0a0 self=0x95e24800  
  | sysTid=2016 nice=0 cgrp=default sched=0/0 handle=0x8b68d930  
  | state=S schedstat=( 9351576559 4141431119 16920 ) utm=819 stm=116 core=1 HZ=100  
  | stack=0x8b591000-0x8b593000 stackSize=1014KB  
  | held mutexes=
  at com.android.server.pm.UserManagerService.exists(UserManagerService.java:387)  
  ** - waiting to lock &amp;lt;0x025f9b02&amp;gt; (a android.util.ArrayMap) held by thread 20**    
  at com.android.server.pm.PackageManagerService.getApplicationInfo(PackageManagerService.java:2848)  
  at com.android.server.AppOpsService.getOpsRawLocked(AppOpsService.java:881)  
  at com.android.server.AppOpsService.getOpsLocked(AppOpsService.java:856)  
  at com.android.server.AppOpsService.noteOperationUnchecked(AppOpsService.java:719)  
  - locked &amp;lt;0x0231885a&amp;gt; (a com.android.server.AppOpsService)  
  at com.android.server.AppOpsService.noteOperation(AppOpsService.java:713)  
  at com.android.server.AppOpsService$2.getMountMode(AppOpsService.java:260)  
  at com.android.server.MountService$MountServiceInternalImpl.getExternalStorageMountMode(MountService.java:3416)  
  at com.android.server.am.ActivityManagerService.startProcessLocked(ActivityManagerService.java:3228)  
  at com.android.server.am.ActivityManagerService.startProcessLocked(ActivityManagerService.java:3170)  
  at com.android.server.am.ActivityManagerService.startProcessLocked(ActivityManagerService.java:3059)  
  at com.android.server.am.BroadcastQueue.processNextBroadcast(BroadcastQueue.java:1070)  
  - locked &amp;lt;0x044d166f&amp;gt; (a com.android.server.am.ActivityManagerService)  
  at com.android.server.am.ActivityManagerService.finishReceiver(ActivityManagerService.java:16950)  
  at android.app.ActivityManagerNative.onTransact(ActivityManagerNative.java:494)  
  at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2432)  
  at android.os.Binder.execTransact(Binder.java:453)  
...  
  &amp;quot;PackageManager&amp;quot; prio=5 tid=20 Blocked  
  | group=&amp;quot;main&amp;quot; sCount=1 dsCount=0 obj=0x1304f4a0 self=0xa7f43900  
  | sysTid=1300 nice=10 cgrp=bg_non_interactive sched=0/0 handle=0x9fcf9930  
  | state=S schedstat=( 26190141996 13612154802 44357 ) utm=2410 stm=209 core=2 HZ=100  
  | stack=0x9fbf7000-0x9fbf9000 stackSize=1038KB  
  | held mutexes=
  at com.android.server.AppOpsService.noteOperationUnchecked(AppOpsService.java:718)  
  **- waiting to lock &amp;lt;0x0231885a&amp;gt; (a com.android.server.AppOpsService) held by thread 73**  
  at com.android.server.AppOpsService.noteOperation(AppOpsService.java:713)  
  at com.android.server.AppOpsService$2.getMountMode(AppOpsService.java:260)  
  at com.android.server.AppOpsService$2.hasExternalStorage(AppOpsService.java:273)  
  at com.android.server.MountService$MountServiceInternalImpl.hasExternalStorage(MountService.java:3431)  
  at com.android.server.MountService.getVolumeList(MountService.java:2609)  
  at android.os.storage.StorageManager.getVolumeList(StorageManager.java:880)  
  at android.os.Environment$UserEnvironment.getExternalDirs(Environment.java:83)  
  at android.os.Environment.isExternalStorageEmulated(Environment.java:708)  
  at com.android.server.pm.PackageManagerService.isExternalMediaAvailable(PackageManagerService.java:9327)  
  at com.android.server.pm.PackageManagerService.startCleaningPackages(PackageManagerService.java:9367)  
  - locked &amp;lt;0x025f9b02&amp;gt; (a android.util.ArrayMap)  
  at com.android.server.pm.PackageManagerService$PackageHandler.doHandleMessage(PackageManagerService.java:1320)  
  at com.android.server.pm.PackageManagerService$PackageHandler.handleMessage(PackageManagerService.java:1122)  
  at android.os.Handler.dispatchMessage(Handler.java:102)  
  at android.os.Looper.loop(Looper.java:148)  
  at android.os.HandlerThread.run(HandlerThread.java:61)  
  at com.android.server.ServiceThread.run(ServiceThread.java:46)  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;activity&#34;&gt;&lt;strong&gt;Activity&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Activity是提供一个界面与用户交互的组件，比如拨打电话，拍照，发邮件等等，从bug报告的角度看，Activity是一个用户能够聚焦的事物，在crash点那个Activity获取了焦点是很重要。Activity是运行在进程中的，所以定位到启动，停止特定Activity的所有进程也有助于故障的排除。&lt;/p&gt;
&lt;h4 id=&#34;查看聚焦的activity&#34;&gt;&lt;strong&gt;查看聚焦的Activity&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;要查看聚焦的Activity可以搜索&lt;strong&gt;am_focused_activity&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &amp;quot;am_focused_activity&amp;quot;  bugreport-2015-10-01-18-13-48.txt  
10-01 18:10:41.409  4600 14112 I am_focused_activity: [0,com.google.android.GoogleCamera/com.android.camera.CameraActivity]  
10-01 18:11:17.313  4600  5687 I am_focused_activity: [0,com.google.android.googlequicksearchbox/com.google.android.launcher.GEL]   
10-01 18:11:52.747  4600 14113 I am_focused_activity: [0,com.google.android.GoogleCamera/com.android.camera.CameraActivity]  
10-01 18:14:07.762  4600  5687 I am_focused_activity: [0,com.google.android.googlequicksearchbox/com.google.android.launcher.GEL]  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;查看进程的启动&#34;&gt;&lt;strong&gt;查看进程的启动&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;为了去查看进程启动的记录，可以搜索&lt;strong&gt;Start proc&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; grep &amp;quot;Start proc&amp;quot; bugreport-2015-10-01-18-13-48.txt
10-01 18:09:15.309  4600  4612 I ActivityManager: Start proc 24533:com.metago.astro/u0a240 for broadcast com.metago.astro/com.inmobi.commons.analytics.androidsdk.IMAdTrackerReceiver  
10-01 18:09:15.687  4600 14112 I ActivityManager: Start proc 24548:com.google.android.apps.fitness/u0a173 for service com.google.android.apps.fitness/.api.services.ActivityUpsamplingService  
10-01 18:09:15.777  4600  6604 I ActivityManager: Start proc 24563:cloudtv.hdwidgets/u0a145 for broadcast cloudtv.hdwidgets/cloudtv.switches.SwitchSystemUpdateReceiver  
10-01 18:09:20.574  4600  6604 I ActivityManager: Start proc 24617:com.wageworks.ezreceipts/u0a111 for broadcast com.wageworks.ezreceipts/.ui.managers.IntentReceiver  
...  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;设备系统波动&#34;&gt;&lt;strong&gt;设备系统波动&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;为了判断设备系统是不是&lt;a href=&#34;https://en.wikipedia.org/wiki/Thrashing_(computer_science)&#34;&gt;thrashing&lt;/a&gt;，检测是不是短时间大量的进程被杀（am_proc_died） 和进程启动（am_proc_start）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -e &amp;quot;am_proc_died&amp;quot; -e &amp;quot;am_proc_start&amp;quot; bugreport-2015-10-01-18-13-48.txt
10-01 18:07:06.494  4600  9696 I am_proc_died: [0,20074,com.android.musicfx]  
10-01 18:07:06.555  4600  6606 I am_proc_died: [0,31166,com.concur.breeze]  
10-01 18:07:06.566  4600 14112 I am_proc_died: [0,18812,com.google.android.apps.fitness]    
10-01 18:07:07.018  4600  7513 I am_proc_start: [0,20361,10113,com.sony.playmemories.mobile,broadcast,com.sony.playmemories.mobile/.service.StartupReceiver]  
10-01 18:07:07.357  4600  4614 I am_proc_start: [0,20381,10056,com.google.android.talk,service,com.google.android.talk/com.google.android.libraries.hangouts.video.CallService]  
10-01 18:07:07.784  4600  4612 I am_proc_start: [0,20402,10190,com.andcreate.app.trafficmonitor:loopback_measure_serivce,service,com.andcreate.app.trafficmonitor/.loopback.LoopbackMeasureService]  
10-01 18:07:10.753  4600  5997 I am_proc_start: [0,20450,10097,com.amazon.mShop.android.shopping,broadcast,com.amazon.mShop.android.shopping/com.amazon.identity.auth.device.storage.LambortishClock$ChangeTimestampsBroadcastReceiver]  
10-01 18:07:15.267  4600  6605 I am_proc_start: [0,20539,10173,com.google.android.apps.fitness,service,com.google.android.apps.fitness/.api.services.ActivityUpsamplingService]  
10-01 18:07:15.985  4600  4612 I am_proc_start: [0,20568,10022,com.android.musicfx,broadcast,com.android.musicfx/.ControlPanelReceiver]  
10-01 18:07:16.315  4600  7512 I am_proc_died: [0,20096,com.google.android.GoogleCamera]  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;内存&#34;&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为Android设备只有有限的物理内存，因此管理RAM是至关重要的，Bug报告中包含一些低内存的提示和提供了内存快照的dumpstate&lt;/p&gt;
&lt;h4 id=&#34;识别低内存&#34;&gt;&lt;strong&gt;识别低内存&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;低内存导致系统的波动，为了启动其他进程不得不去杀其他进程。为了找到对应的证据可以搜索event log的&lt;strong&gt;am_proc_died&lt;/strong&gt;和&lt;strong&gt;am_proc_start&lt;/strong&gt;标签。&lt;/p&gt;
&lt;p&gt;低内存拖慢任务的切换而且会阻止返回（因为用户尝试去返回的任务可能被杀了）。如果launcher被杀，它会在用户触摸主页按钮的时候重新启动，并且日志会显示launcher重新加载其内容。&lt;/p&gt;
&lt;h4 id=&#34;查看历史信息&#34;&gt;&lt;strong&gt;查看历史信息&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在event log中当出现&lt;strong&gt;am_low_memory&lt;/strong&gt;时候表示最后的缓存进程已经被杀了。这之后，系统会启动被杀的服务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep &amp;quot;am_low_memory&amp;quot; bugreport-2015-10-01-18-13-48.txt  
10-01 18:11:02.219  4600  7513 I am_low_memory: 41  
10-01 18:12:18.526  4600 14112 I am_low_memory: 39  
10-01 18:12:18.874  4600  7514 I am_low_memory: 38  
10-01 18:12:22.570  4600 14112 I am_low_memory: 40  
10-01 18:12:34.811  4600 20319 I am_low_memory: 43  
10-01 18:12:37.945  4600  6521 I am_low_memory: 43  
10-01 18:12:47.804  4600 14110 I am_low_memory: 43  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;查看系统波动指标&#34;&gt;&lt;strong&gt;查看系统波动指标&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;其他系统波动的指标(分页，直接回收等等)包括&lt;strong&gt;kswapd&lt;/strong&gt;,&lt;strong&gt;kworker&lt;/strong&gt;，&lt;strong&gt;mmcqd&lt;/strong&gt; 的消耗回收（log收集的时候也可能导致波动的指标）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------ CPU INFO (top -n 1 -d 1 -m 30 -t) ------

User 15%, System 54%, IOW 28%, IRQ 0%  
User 82 + Nice 2 + Sys 287 + Idle 1 + IOW 152 + IRQ 0 + SIRQ 5 = 529  

  PID   TID PR CPU% S     VSS     RSS PCY UID      Thread          Proc  
15229 15229  0  19% R      0K      0K  fg root     kworker/0:2  
29512 29517  1   7% D 1173524K 101188K  bg u0_a27   Signal Catcher  com.google.android.talk  
24565 24570  3   6% D 2090920K 145168K  fg u0_a22   Signal Catcher  com.google.android.googlequicksearchbox:search  
19525 19525  2   6% R   3476K   1644K  fg shell    top             top  
24957 24962  2   5% R 1706928K 125716K  bg u0_a47   Signal Catcher  com.google.android.GoogleCamera  
19519 19519  3   4% S      0K      0K  fg root     kworker/3:1  
  120   120  0   3% S      0K      0K  fg root     mmcqd/1  
18233 18233  1   3% S      0K      0K  fg root     kworker/1:1  
25589 25594  1   2% D 1270476K  75776K  fg u0_a8    Signal Catcher  com.google.android.gms  
19399 19399  2   1% S      0K      0K  fg root     kworker/2:2  
 1963  1978  1   0% S 1819100K 125136K  fg system   android.fg      system_server  
 1963  1981  3   0% S 1819100K 125136K  fg system   android.display system_server    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ANR的log也能提供类似的内存快照&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10-03 17:19:59.959  1963  1976 E ActivityManager: ANR in com.google.android.apps.magazines  
10-03 17:19:59.959  1963  1976 E ActivityManager: PID: 18819   
10-03 17:19:59.959  1963  1976 E ActivityManager: Reason: Broadcast of Intent { act=android.net.conn.CONNECTIVITY_CHANGE flg=0x4000010 cmp=com.google.android.apps.magazines/com.google.apps.dots.android.newsstand.appwidget.NewsWidgetProvider (has extras) }  
10-03 17:19:59.959  1963  1976 E ActivityManager: Load: 19.19 / 14.76 / 12.03  
10-03 17:19:59.959  1963  1976 E ActivityManager: CPU usage from 0ms to 11463ms later:  
10-03 17:19:59.959  1963  1976 E ActivityManager:   54% 15229/kworker/0:2: 0% user + 54% kernel  
10-03 17:19:59.959  1963  1976 E ActivityManager:   38% 1963/system_server: 14% user + 23% kernel / faults: 17152 minor 1073 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   11% 120/mmcqd/1: 0% user + 11% kernel  
10-03 17:19:59.959  1963  1976 E ActivityManager:   10% 2737/com.android.systemui: 4.7% user + 5.6% kernel / faults: 7211 minor 149 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   0.2% 1451/debuggerd: 0% user + 0.2% kernel / faults: 15211 minor 147 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   8.7% 6162/com.twofortyfouram.locale: 4% user + 4.7% kernel / faults: 4924 minor 260 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   6.1% 24565/com.google.android.googlequicksearchbox:search: 2.4% user + 3.7% kernel / faults: 2902 minor 129 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   6% 55/kswapd0: 0% user + 6% kernel  
10-03 17:19:59.959  1963  1976 E ActivityManager:   4.9% 18819/com.google.android.apps.magazines: 1.5% user + 3.3% kernel / faults: 10129 minor 986 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   2.8% 18233/kworker/1:1: 0% user + 2.8% kernel  
10-03 17:19:59.959  1963  1976 E ActivityManager:   4.2% 3145/com.android.phone: 2% user + 2.2% kernel / faults: 3005 minor 43 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   4.2% 8084/com.android.chrome: 2% user + 2.1% kernel / faults: 4798 minor 380 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   3.4% 182/surfaceflinger: 1.1% user + 2.3% kernel / faults: 842 minor 13 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   3% 18236/kworker/1:2: 0% user + 3% kernel  
10-03 17:19:59.959  1963  1976 E ActivityManager:   2.9% 19231/com.android.systemui:screenshot: 0.8% user + 2.1% kernel / faults: 6119 minor 348 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   2.3% 15350/kworker/0:4: 0% user + 2.3% kernel  
10-03 17:19:59.959  1963  1976 E ActivityManager:   2.2% 1454/mediaserver: 0% user + 2.2% kernel / faults: 479 minor 6 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   2% 16496/com.android.chrome:sandboxed_process10: 0.1% user + 1.8% kernel / faults: 3610 minor 234 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   1% 3119/com.android.nfc: 0.4% user + 0.5% kernel / faults: 1789 minor 17 major   
10-03 17:19:59.959  1963  1976 E ActivityManager:   1.7% 19337/com.jarettmillard.localeconnectiontype:background: 0.1% user + 1.5% kernel / faults: 7854 minor 439 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   0.7% 3066/com.google.android.inputmethod.latin: 0.3% user + 0.3% kernel / faults: 1336 minor 7 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   1% 25589/com.google.android.gms: 0.3% user + 0.6% kernel / faults: 2867 minor 237 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   0.9% 1460/sensors.qcom: 0.5% user + 0.4% kernel / faults: 262 minor 5 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   0.8% 3650/mpdecision: 0% user + 0.8% kernel / faults: 160 minor 1 major  
10-03 17:19:59.959  1963  1976 E ActivityManager:   0.1% 3132/com.redbend.vdmc: 0% user + 0% kernel / faults: 1746 minor 5 major  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;获取内存快照&#34;&gt;&lt;strong&gt;获取内存快照&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;dumpstate列出了运行的java和native进程的内存快照，记住快照只是某个特定时间点的，系统可能在时间点之前已经恢复了也可能更糟糕。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了理解进程运行的时间可以参考下面** Process runtime**一节&lt;/li&gt;
&lt;li&gt;为了明白现在哪些事物在运行请看&lt;strong&gt;Why is a process running&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;strong&gt;adb shell dumpstate&lt;/strong&gt;命令获取信息,或者通过&lt;strong&gt;adb shell dumpsys meminfo&lt;/strong&gt;获取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Total PSS by OOM adjustment:  
    86752 kB: Native  
               22645 kB: surfaceflinger (pid 197)  
               18597 kB: mediaserver (pid 204)  
               ...   
   136959 kB: System  
              136959 kB: system (pid 785)  
   220218 kB: Persistent  
              138859 kB: com.android.systemui (pid 947 / activities)  
               39178 kB: com.android.nfc (pid 1636)  
               28313 kB: com.android.phone (pid 1659)  
               13868 kB: com.redbend.vdmc (pid 1646)  
     9534 kB: Persistent Service
                9534 kB: com.android.bluetooth (pid 23807)   
   178604 kB: Foreground  
              168620 kB: com.google.android.googlequicksearchbox (pid 1675 / activities)
                9984 kB: com.google.android.apps.maps (pid 13952)    
   188286 kB: Visible  
               85326 kB: com.google.android.wearable.app (pid 1535)   
               38978 kB: com.google.process.gapps (pid 1510)   
               31936 kB: com.google.android.gms.persistent (pid 2072)   
               27950 kB: com.google.android.gms.wearable (pid 1601)  
                4096 kB: com.google.android.googlequicksearchbox:interactor (pid 1550)   
    52948 kB: Perceptible  
               52948 kB: com.google.android.inputmethod.latin (pid 1566)   
   150851 kB: A Services   
               81121 kB: com.google.android.gms (pid 1814)    
               37586 kB: com.google.android.talk (pid 9584)  
               10949 kB: com.google.android.music:main (pid 4019)  
               10727 kB: com.motorola.targetnotif (pid 31071)  
               10468 kB: com.google.android.GoogleCamera (pid 9984)  
    33298 kB: Previous
               33298 kB: com.android.settings (pid 9673 / activities)  
   165188 kB: B Services
               49490 kB: com.facebook.katana (pid 15035)  
               22483 kB: com.whatsapp (pid 28694)  
               21308 kB: com.iPass.OpenMobile (pid 5325)   
               19788 kB: com.google.android.apps.googlevoice (pid 23934)   
               17399 kB: com.google.android.googlequicksearchbox:search (pid 30359)   
                9073 kB: com.google.android.apps.youtube.unplugged (pid 21194)    
                7660 kB: com.iPass.OpenMobile:remote (pid 23754)   
                7291 kB: com.pujie.wristwear.pujieblack (pid 24240)   
                7157 kB: com.instagram.android:mqtt (pid 9530)   
                3539 kB: com.qualcomm.qcrilmsgtunnel (pid 16186)   
   204324 kB: Cached   
               43424 kB: com.amazon.mShop.android (pid 13558)   
               22563 kB: com.google.android.apps.magazines (pid 13844)   
               ...   
                4298 kB: com.google.android.apps.enterprise.dmagent (pid 13826)   
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;进程&#34;&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Bug报告中包含大量的进程信息，包括启动，停止时间，运行时长，关联的服务，oom_adj值等等。对于Android是怎么管理进程的，请参考&lt;a href=&#34;https://developer.android.com/guide/components/processes-and-threads.html&#34;&gt;Processes and Threads&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;确定进程的运行&#34;&gt;确定进程的运行&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;procstats&lt;/strong&gt; 部分包含了进程运行了多长时间，运行的关联的服务的完整数据。为了获取易读的摘要，可以搜索&lt;strong&gt;AGGREGATED OVER&lt;/strong&gt;来浏览最近3小时或者24小时的数据。搜索的摘要：浏览进程列表，这些进程在各种优先事项中运行了多久，和RAM的使用情况，展示格式min-average-max PSS/min-average-max USS。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips: 使用&lt;strong&gt;adb shell dumpsys procstats&lt;/strong&gt;命令获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;-------------------------------------------------------------------------------   
DUMP OF SERVICE processinfo:  
-------------------------------------------------------------------------------    
DUMP OF SERVICE procstats:  
COMMITTED STATS FROM 2015-10-19-23-54-56 (checked in):    
...    
COMMITTED STATS FROM 2015-10-20-03-00-00 (checked in):    
...    
CURRENT STATS:    
...    
AGGREGATED OVER LAST 24 HOURS:   
System memory usage:   
...   
Per-Package Stats:    
...   
Summary:   
...    
  * com.google.android.gms.persistent / u0a13 / v8186448:    
           TOTAL: 100% (21MB-27MB-40MB/20MB-24MB-38MB over 597)   
             Top: 51% (22MB-26MB-38MB/21MB-24MB-36MB over 383)   
          Imp Fg: 49% (21MB-27MB-40MB/20MB-25MB-38MB over 214)    
…   
          Start time: 2015-10-19 09:14:37   
  Total elapsed time: +1d0h22m7s390ms (partial) libart.so   

AGGREGATED OVER LAST 3 HOURS:    
System memory usage:  
...  
Per-Package Stats:  
...  
Summary:  
  * com.google.android.gms.persistent / u0a13 / v8186448:   
           TOTAL: 100% (23MB-27MB-32MB/21MB-25MB-29MB over 111)  
             Top: 61% (23MB-26MB-31MB/21MB-24MB-28MB over 67）  
          Imp Fg: 39% (23MB-28MB-32MB/21MB-26MB-29MB over 44)   
...   
          Start time: 2015-10-20 06:49:24  
  Total elapsed time: +2h46m59s736ms (partial) libart.so   
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;为什么进程会运行&#34;&gt;&lt;strong&gt;为什么进程会运行?&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;adb shell dumpsys activity processes&lt;/strong&gt; 部分列出了所有当前正在运行的进程并且通过oom_adj值排序（Android 标记进程的重要性是通过分配给进程一个oom_adj值，这个值会通过ActivityManager动态的更新）。这个输出类似于 &lt;strong&gt;memory snapshot&lt;/strong&gt; 但是会包含一些进程正在运行的原因。下面的例子中，黑色条目中表示 &lt;strong&gt;gms.persistent&lt;/strong&gt; 进程运行在 &lt;strong&gt;vis&lt;/strong&gt; （visible）优先级下是因为 &lt;strong&gt;system&lt;/strong&gt; 进程绑定到了它的 &lt;strong&gt;NetworkLocationService&lt;/strong&gt; 服务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-------------------------------------------------------------------------------  
ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)  
...  
Process LRU list (sorted by oom_adj, 34 total, non-act at 14, non-svc at 14):  
    PERS #33: sys   F/ /P  trm: 0 902:system/1000 (fixed)  
    PERS #32: pers  F/ /P  trm: 0 2925:com.android.systemui/u0a27 (fixed)  
    PERS #31: pers  F/ /P  trm: 0 3477:com.quicinc.cne.CNEService/1000 (fixed)  
    PERS #30: pers  F/ /P  trm: 0 3484:com.android.nfc/1027 (fixed)  
    PERS #29: pers  F/ /P  trm: 0 3502:com.qualcomm.qti.rcsbootstraputil/1001 (fixed)  
    PERS #28: pers  F/ /P  trm: 0 3534:com.qualcomm.qti.rcsimsbootstraputil/1001 (fixed)  
    PERS #27: pers  F/ /P  trm: 0 3553:com.android.phone/1001 (fixed)  
    Proc #25: psvc  F/ /IF trm: 0 4951:com.android.bluetooth/1002 (service)  
        com.android.bluetooth/.hfp.HeadsetService&amp;lt;=Proc{902:system/1000}  
    Proc # 0: fore  F/A/T  trm: 0 3586:com.google.android.googlequicksearchbox/u0a29 (top-activity)  
  Proc #26: vis   F/ /SB trm: 0 3374:com.google.android.googlequicksearchbox:interactor/u0a29 (service)
        com.google.android.googlequicksearchbox/com.google.android.voiceinteraction.GsaVoiceInteractionService&amp;lt;=Proc{902:system/1000}   
    Proc # 5: vis   F/ /T  trm: 0 3745:com.google.android.gms.persistent/u0a12 (service)
        com.google.android.gms/com.google.android.location.network.NetworkLocationService&amp;lt;=Proc{902:system/1000}    
    Proc # 3: vis   F/ /SB trm: 0 3279:com.google.android.gms/u0a12 (service)
        com.google.android.gms/.icing.service.IndexService&amp;lt;=Proc{947:com.google.android.googlequicksearchbox:search/u0a29}  
    Proc # 2: vis   F/ /T  trm: 0 947:com.google.android.googlequicksearchbox:search/u0a29 (service)
        com.google.android.googlequicksearchbox/com.google.android.sidekick.main.remoteservice.GoogleNowRemoteService&amp;lt;=Proc{3586:com.google.android.googlequicksearchbox/u0a29}  
    Proc # 1: vis   F/ /T  trm: 0 2981:com.google.process.gapps/u0a12 (service)
        com.google.android.gms/.tapandpay.hce.service.TpHceService&amp;lt;=Proc{3484:com.android.nfc/1027}  
    Proc #11: prcp  B/ /IB trm: 0 3392:com.google.android.inputmethod.latin/u0a64 (service)
        com.google.android.inputmethod.latin/com.android.inputmethod.latin.LatinIME&amp;lt;=Proc{902:system/1000}  
    Proc #24: svc   B/ /S  trm: 0 27071:com.google.android.music:main/u0a67 (started-services)  
    Proc #22: svc   B/ /S  trm: 0 853:com.qualcomm.qcrilmsgtunnel/1001 (started-services)  
    Proc # 4: prev  B/ /LA trm: 0 32734:com.google.android.GoogleCamera/u0a53 (previous)  
    Proc #23: svcb  B/ /S  trm: 0 671:com.qualcomm.telephony/1000 (started-services)  
    Proc #20: cch   B/ /CE trm: 0 27659:com.android.providers.calendar/u0a2 (provider)
        com.android.providers.calendar/.CalendarProvider2&amp;lt;=Proc{27697:com.google.android.calendar/u0a40}
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>GC可达性实践-内存泄露分析</title>
                <link>https://example.com/posts/2017-11-04-gc%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</link>
                <guid isPermaLink="true">https://example.com/posts/2017-11-04-gc%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</guid>
                <pubDate>Sat, 04 Nov 2017 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Java中的对象回收是通过GC，但是在回收之前需要知道哪些对象是可回收的，哪些对象是不可回收的。&lt;/p&gt;
&lt;h2 id=&#34;常见的回收机制&#34;&gt;常见的回收机制&lt;/h2&gt;
&lt;h3 id=&#34;引用计数算法&#34;&gt;引用计数算法&lt;/h3&gt;
&lt;p&gt;引用算法是在对象中添加引用计数器，每当有地方引用了此对象时候，引用计数加1，当引用失效时候引用计数器减1。没有任何地方引用此对象时候，说明此对象不再使用，可以被回收。常见的是C++中的智能指针使用了此算法。而Java中并未使用此算法，为什么呢？后面再回答吧。&lt;/p&gt;
&lt;h3 id=&#34;可达性分析算法&#34;&gt;可达性分析算法&lt;/h3&gt;
&lt;p&gt;在Java中判断是否可回收是通过可达性来判断的。可达性分析的基本思路是通过一系列的称为“GC ROOT”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC ROOT没有任何引用链时说明此对象可被回收。
例如：
&lt;img src=&#34;http://img.blog.csdn.net/20170308125242116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;GC-1&#34;&gt;
由于A，B对象没有引用链，因此可以被回收。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注 GC模型中的均为对象，而不是类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;java中的引用&#34;&gt;Java中的引用&lt;/h3&gt;
&lt;p&gt;现在Java语言中，引用分为强引用，软引用，弱引用，虚引用。&lt;/p&gt;
&lt;p&gt;强引用在代码中普遍存在， 类似于“Object object = new Object”，只要强引用存在，GC不会回收被引用的对象。&lt;/p&gt;
&lt;p&gt;软引用在代码中不常见，用于描述一些还有用但并非必需的对象。对于软引用关联的对象，Java中用SoftReference来实现的。&lt;/p&gt;
&lt;p&gt;弱引用描述非必需的对象，只被弱引用关联的对象只能生存到下一次GC发生之前，一旦GC被触发，只被弱引用引用的对象都会被回收。Java中用WeakReference来实现。&lt;/p&gt;
&lt;h3 id=&#34;java中gc-root简易模型分析&#34;&gt;Java中GC ROOT简易模型分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170308125448643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;GC-2&#34;&gt;
A对象释放了C的引用后，C，D对象无引用链可以到达,因此C，D对象可以被回收。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170308125555777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;GC-3&#34;&gt;
A对象释放对C对象的引用，然而GC ROOT -&amp;gt; A -&amp;gt; B -&amp;gt; C -&amp;gt; D，到C对象有引用链可达,到D对象有引用链子可达，所有没有对象可以被回收。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170308125704176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;GC-4&#34;&gt;
A释放对B，C的引用，根据引用链到B，C，D都不可达，因此B，C，D对象均可回收。
&lt;strong&gt;如果使用的是引用计数算法呢？&lt;/strong&gt;
由于B，C，D相互引用，导致了各个对象的引用计数器都不为0，从而均不可回收，对于相互循环引用的对象，引用计数算法不能很好的解决.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;包含弱引用情况，如下图B弱引用C
&lt;img src=&#34;http://img.blog.csdn.net/20170308125838921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;GC-5&#34;&gt;
当A释放C的引用，由于B是弱引用C，弱引用只会存在到GC发生之前，相当于无引用链可达，因此C，D对象会可被回收。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;android内存泄露&#34;&gt;Android内存泄露&lt;/h2&gt;
&lt;p&gt;AsyncTask的使用中会经常的直接Activity或者Fragment中创建匿名内部类来使用，这样很容易导致Activity或者Fragment的泄露。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public class TaskLeakActivity extends AppCompatActivity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        TextView textView = new TextView(this);
        textView.setText(&amp;quot;Task&amp;quot;);
        setContentView(textView);
        new AsyncTask&amp;lt;Void, Void, Void&amp;gt;() {
            @Override protected Void doInBackground(Void... params) {
                SystemClock.sleep(20000);
                return null;
            }
        }.execute();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LeakCanary检测 ：
&lt;img src=&#34;http://img.blog.csdn.net/20170308130200097?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;LeakCanary&#34;&gt;&lt;/p&gt;
&lt;p&gt;MAT检测：
&lt;img src=&#34;http://img.blog.csdn.net/20170308130229819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;MAT&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;gc-root简易模型&#34;&gt;GC ROOT简易模型&lt;/h3&gt;
&lt;p&gt;这个例子中虽然剪断GC ROOT到Activity的部分引用链，由于存在 GC ROOT -&amp;gt; Thead -&amp;gt; anonymous AsyncTask -&amp;gt; TaskLeakActivity引用链到TaskLeakActivity可达。因此导致了TaskLeakActivity不可回收，导致了泄露。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这里GC ROOT不正规，只是为了分析泄露引入的，其实GC ROOT是具体的类对象。对于哪些类的对象可作为GC ROOT可。
Google。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;经常的会听到这样一句话： 长周期的对象持有了短周期的对象导致内存泄露，为什么呢?&lt;/strong&gt;
&lt;strong&gt;这是因为长周期的对象，到短周期的对象的引用链可达，导致短周期的对象泄露。就像上述的Thread的对象到TaskLeakActivity的引用链可达。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何修复内存泄露&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修复内存泄露，我们就是剪断到对象引用链，使得引用链到对象不可达。&lt;/li&gt;
&lt;li&gt;避免不必要的引用，比如含有耗时操作匿名内部类改为静态内部类，查询数据库时只是需要ContentResolve，没必要传入Activity等等。&lt;/li&gt;
&lt;li&gt;使用长周期的对象替换短周期对象，比如需要Context对象，避免使用Activity，而是使用ApplicationContext等等。&lt;/li&gt;
&lt;li&gt;引入弱引用，弱引用可以只能存在到引用GC触发之前，不会影响内存的回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;GC ROOT简易模型有哪些好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;更好的使用常用的内存泄露的工具比如MAT，LeakCannary，这些工具根据引用链作为原理。&lt;/li&gt;
&lt;li&gt;更好的查找内存泄露。&lt;/li&gt;
&lt;li&gt;写代码时候更好的明白持有关系，避免从源头避免内存泄露。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/jvm/">JVM</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/gc/">GC</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>ImageLoader的设计</title>
                <link>https://example.com/posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
                <guid isPermaLink="true">https://example.com/posts/2017-11-04-imageloader%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
                <pubDate>Sat, 04 Nov 2017 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;imageloader解决的问题&#34;&gt;ImageLoader解决的问题&lt;/h2&gt;
&lt;p&gt;分析源码之前我们需要知道ImageLoader为什么要出现，或者说ImageLoader是用来解决什么问题的。总结了一下几点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于加载网络的图片是比较耗时的，而对于耗时的排序基本是 网络&amp;gt;磁盘&amp;gt;内存，因此我们需要尽量减少对于网络的请求次数，我们可以牺牲磁盘和内存来达到尽量减少网络请求的加载，这就是我们所说的三级缓存，先从内存获取，然后从磁盘获取，最后再从网络获取。所以ImageLoader需要对此问题给出解决方案。&lt;/li&gt;
&lt;li&gt;图片本身会占用大量的内存，如何做到内存的优化？ImageLoader需要对此问题给出解决方案，基本的解决方案是
&lt;ul&gt;
&lt;li&gt;图片的大小压缩，对应于Bitmap就是其大小&lt;/li&gt;
&lt;li&gt;图片的色彩压缩，对应于Bitmap就是像素的标识是565还是8888&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于加载图片需要在子线程中运行，如何合理的处理线程需要考虑&lt;/li&gt;
&lt;li&gt;扩展性，对于此问题不实现也可以，但写出来的代码绝对不是好代码，因为无法扩展
&lt;ul&gt;
&lt;li&gt;显示的时候，对返回的Bitmap做处理，比如说我们需要倒圆角，圆形图，那ImageLoader是否可以给予支持，给用户更好的使用。(ImageLoader可以不给予实现，但是此实现会极大的提高ImageLoader的易用性)。&lt;/li&gt;
&lt;li&gt;对于图片的加载，我们需要从网络加载，也可以从磁盘加载，而且网络加载是否可以引入其他的库比如HttpClient等等。如何做到这些呢？ImageLoader最好给予实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;易用性，既然是库，给client使用时候就需要考虑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以&lt;a href=&#34;https://github.com/nostra13/Android-Universal-Image-Loader&#34;&gt;Android-Universal-Image-Loader&lt;/a&gt;为例&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/nostra13/Android-Universal-Image-Loader&#34;&gt;Android-Universal-Image-Loader&lt;/a&gt;流程
&lt;img src=&#34;http://img.blog.csdn.net/20170521155701391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;ImageLoder对外充当高层接口，ImageLoaderEngine管理线程，而ImageDecoder和ImageDownloader用于加载图片，而BitmapDisplayer用于显示Bitmap到ImageView上。&lt;/p&gt;
&lt;p&gt;对外接口结构
&lt;img src=&#34;http://img.blog.csdn.net/20170521155933665?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;对外接口&#34;&gt;&lt;/p&gt;
&lt;p&gt;供客户端接口是通过Facade模式进行封装，把底层细节隐藏起来，提供给用户使用的是ImageLoader类和ImageLoaderConfiguraton类。客户端不需要涉及底层细节，提高易用性。&lt;/p&gt;
&lt;h2 id=&#34;源码分析&#34;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;下面以ImageLoader的displayImage为例，看看如何从网络获取图片，如何把图片设置到ImageView上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public void displayImage(String uri, ImageAware imageAware, DisplayImageOptions options,
          ImageSize targetSize, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) {
     ......
       // 获取控件大小，后面我们需要根据此来压缩图片
       if (targetSize == null) {
          targetSize = ImageSizeUtils.defineTargetSizeForView(imageAware, configuration.getMaxImageSize());
       }
      // 根据Uri生成一个key，这个key非常重要，在ListView中itemView复用的时候通过key识别
       String memoryCacheKey = MemoryCacheUtils.generateKey(uri, targetSize);
       engine.prepareDisplayTaskFor(imageAware, memoryCacheKey);

      //现在先从memory中看是否能获取到。
       Bitmap bmp = configuration.memoryCache.get(memoryCacheKey);
       if (bmp != null &amp;amp;&amp;amp; !bmp.isRecycled()) {
          // 这里是可以获取到Bitmap的代码，把Bitmap展示到ImageView中，可以查看ImageLoader的代码详细了解
       } else {
          if (options.shouldShowImageOnLoading()) {
             imageAware.setImageDrawable(options.getImageOnLoading(configuration.resources));
          } else if (options.isResetViewBeforeLoading()) {
             imageAware.setImageDrawable(null);
          }

          ImageLoadingInfo imageLoadingInfo = new ImageLoadingInfo(uri, imageAware, targetSize, memoryCacheKey,
                options, listener, progressListener, engine.getLockForUri(uri));
          LoadAndDisplayImageTask displayTask = new LoadAndDisplayImageTask(engine, imageLoadingInfo,
                defineHandler(options));
         //如果是同步加载，直接运行task，否则直接ImageLoaderEngine来提交工作线程处理
          if (options.isSyncLoading()) {
             displayTask.run();
          } else {
             engine.submit(displayTask);
          }
       }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的代码中可以看出先从内存中获取，获取不到的话会让LoadAndDisplayImageTask处理，我们一起分析一下LoadAndDisplayImageTask。&lt;/p&gt;
&lt;h4 id=&#34;loadanddisplayimagetask分析&#34;&gt;LoadAndDisplayImageTask分析&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;   public void run() {
      //如果pause就需要直接退出，比如我们的Activity进入pause，我们可以调用ImageLoader的
       if (waitIfPaused()) return;
       if (delayIfNeed()) return;
       Bitmap bmp;
       try {
         //先从内存中获取，
          bmp = configuration.memoryCache.get(memoryCacheKey);
          if (bmp == null || bmp.isRecycled()) {
            //没有获取到通过相应的方法获取。
             bmp = tryLoadBitmap();
          } else {
             loadedFrom = LoadedFrom.MEMORY_CACHE;
             L.d(LOG_GET_IMAGE_FROM_MEMORY_CACHE_AFTER_WAITING, memoryCacheKey);
          }

          if (bmp != null &amp;amp;&amp;amp; options.shouldPostProcess()) {
             L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);
             bmp = options.getPostProcessor().process(bmp);
             if (bmp == null) {
                L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);
             }
          }
          checkTaskNotActual();
          checkTaskInterrupted();
       } catch (TaskCancelledException e) {
          fireCancelEvent();
          return;
       } finally {
          loadFromUriLock.unlock();
       }
    	// 创建DisplayBitmapTask去加载Bitmap到ImageView上
       DisplayBitmapTask displayBitmapTask = new DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);
       runTask(displayBitmapTask, syncLoading, handler, engine);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;还是先从内存中获取Bitmap，存在多线程操作，因此这里会重新从内存总获取一次。&lt;/li&gt;
&lt;li&gt;调用tryLoadBitmap获取Bitmap&lt;/li&gt;
&lt;li&gt;通过DisplayBitmapTask对象来显示Bitmap&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于tryLoadBitmap方法的操作如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private Bitmap tryLoadBitmap() throws TaskCancelledException {
       Bitmap bitmap = null;
       try {
          File imageFile = configuration.diskCache.get(uri);
          if (imageFile != null &amp;amp;&amp;amp; imageFile.exists() &amp;amp;&amp;amp; imageFile.length() &amp;gt; 0) {
             L.d(LOG_LOAD_IMAGE_FROM_DISK_CACHE, memoryCacheKey);
             loadedFrom = LoadedFrom.DISC_CACHE;

             checkTaskNotActual();
            //通过磁盘缓存获取
             bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));
          }
          if (bitmap == null || bitmap.getWidth() &amp;lt;= 0 || bitmap.getHeight() &amp;lt;= 0) {
             L.d(LOG_LOAD_IMAGE_FROM_NETWORK, memoryCacheKey);
             loadedFrom = LoadedFrom.NETWORK;
    		 ......
              // 通过网络获取
             bitmap = decodeImage(imageUriForDecoding);

             if (bitmap == null || bitmap.getWidth() &amp;lt;= 0 || bitmap.getHeight() &amp;lt;= 0) {
                fireFailEvent(FailType.DECODING_ERROR, null);
             }
          }
       }
      ......
       return bitmap;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;先从磁盘中获取Bitmap&lt;/li&gt;
&lt;li&gt;然后从网络获取&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面分析一下decodeImage方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private Bitmap decodeImage(String imageUri) throws IOException {
       ViewScaleType viewScaleType = imageAware.getScaleType();
       ImageDecodingInfo decodingInfo = new ImageDecodingInfo(memoryCacheKey, imageUri, uri, targetSize, viewScaleType,
             getDownloader(), options);
       return decoder.decode(decodingInfo);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分析一下ImageDecoder的decode方法，而我们默认的BaseImageDecoder。&lt;/p&gt;
&lt;p&gt;以BaseImageDecoder为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public Bitmap decode(ImageDecodingInfo decodingInfo) throws IOException {
       Bitmap decodedBitmap;
       ImageFileInfo imageInfo;

      //通过ImageDownloader获取到InputStream对象
       InputStream imageStream = getImageStream(decodingInfo);
       if (imageStream == null) {
          L.e(ERROR_NO_IMAGE_STREAM, decodingInfo.getImageKey());
          return null;
       }
      //创建Bitmap
       try {
          imageInfo = defineImageSizeAndRotation(imageStream, decodingInfo);
          imageStream = resetStream(imageStream, decodingInfo);
          Options decodingOptions = prepareDecodingOptions(imageInfo.imageSize, decodingInfo);
          decodedBitmap = BitmapFactory.decodeStream(imageStream, null, decodingOptions);
       } finally {
          IoUtils.closeSilently(imageStream);
       }

      // 处理Bitmap类。
       if (decodedBitmap == null) {
          L.e(ERROR_CANT_DECODE_IMAGE, decodingInfo.getImageKey());
       } else {
          decodedBitmap = considerExactScaleAndOrientatiton(decodedBitmap, decodingInfo, imageInfo.exif.rotation,
                imageInfo.exif.flipHorizontal);
       }
       return decodedBitmap;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最主要的通过ImageDownloader获取到InputStream对象。后面还会详细分析。&lt;/p&gt;
&lt;p&gt;还有两个没有分析，一个是DisplayBitmapTask如何显示Bitmap的，一个是ImageLoaderEngine如何加载管理线程的。&lt;/p&gt;
&lt;h3 id=&#34;displaybitmaptask分析&#34;&gt;DisplayBitmapTask分析&lt;/h3&gt;
&lt;p&gt;DisplayBitmapTask继承Runnable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public void run() {
       if (imageAware.isCollected()) {
          L.d(LOG_TASK_CANCELLED_IMAGEAWARE_COLLECTED, memoryCacheKey);
          listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());
       } else if (isViewWasReused()) {
          L.d(LOG_TASK_CANCELLED_IMAGEAWARE_REUSED, memoryCacheKey);
          listener.onLoadingCancelled(imageUri, imageAware.getWrappedView());
       } else {
          L.d(LOG_DISPLAY_IMAGE_IN_IMAGEAWARE, loadedFrom, memoryCacheKey);
          displayer.display(bitmap, imageAware, loadedFrom);
          engine.cancelDisplayTaskFor(imageAware);
          listener.onLoadingComplete(imageUri, imageAware.getWrappedView(), bitmap);
       }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过BitmapDisplayer的对象来显示的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public final class SimpleBitmapDisplayer implements BitmapDisplayer {
       @Override
       public void display(Bitmap bitmap, ImageAware imageAware, LoadedFrom loadedFrom) {
          imageAware.setImageBitmap(bitmap);
       }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;imageloaderengine&#34;&gt;ImageLoaderEngine&lt;/h3&gt;
&lt;p&gt;ImageLoaderEngine主要是task的分发执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    void submit(final LoadAndDisplayImageTask task) {
       taskDistributor.execute(new Runnable() {
          @Override
          public void run() {
             File image = configuration.diskCache.get(task.getLoadingUri());
             boolean isImageCachedOnDisk = image != null &amp;amp;&amp;amp; image.exists();
             initExecutorsIfNeed();
             if (isImageCachedOnDisk) {
                taskExecutorForCachedImages.execute(task);
             } else {
                taskExecutor.execute(task);
             }
          }
       });
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;模块结构&#34;&gt;模块结构&lt;/h2&gt;
&lt;p&gt;主要功能有一下几点&lt;/p&gt;
&lt;h3 id=&#34;线程池管理&#34;&gt;线程池管理&lt;/h3&gt;
&lt;p&gt;线程池的管理主要是由ImageLoaderEngine负责。
&lt;img src=&#34;http://img.blog.csdn.net/20170521160445980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;线程池&#34;&gt;
对于ImageLoaderEngine的线程池主要有三个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;taskDistributor 用于分发Task,具体可查看ImageLoaderEngine的submit方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;taskExecutor 用于从网络上下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;taskExecutorForCachedImages 用于从磁盘缓存中获取，或者提交ProcessAndDisplayImageTask时候使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑一种情况，在Activity中有一个ListView而itemView中会从Uri中获取图片，在Activity中我们需要做什么操作呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当Activity处于paused的时候，现在界面不需要刷新，我们可以调用ImageLoader的pause来暂定新的请求加载&lt;/li&gt;
&lt;li&gt;当Activity处于stop的时候，界面不可见，我们可以调用stop来暂定所有的线程&lt;/li&gt;
&lt;li&gt;当Activity处于destory的时候，调用destroy来销毁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样做到了加载与Activity声明周期相关联。&lt;/p&gt;
&lt;h3 id=&#34;缓存&#34;&gt;缓存&lt;/h3&gt;
&lt;p&gt;这里以内存缓存为例
&lt;img src=&#34;http://img.blog.csdn.net/20170521160536497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;缓存&#34;&gt;&lt;/p&gt;
&lt;p&gt;抽象出MemoryCache接口，而外界只是引用其接口，DiskCache与此类似&lt;/p&gt;
&lt;h3 id=&#34;下载解析&#34;&gt;下载解析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170521160630324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;这里写图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于ImageDecoder解析是根据ImageDowloader的getStream获取InputStream，然后根据InputStream来解析出Bitmap。对外也都是引用均为接口。&lt;/p&gt;
&lt;p&gt;而ImageDownloader是通过装饰模式进行组织，BaseImageDownloader为ConcreateComponent。而SlowNetWorkImageDowloader为Decorator。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实现自己的下载，可以根据ImageDownloader来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而实现自己的图片解析器，可以根据ImageDecoder。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;显示&#34;&gt;显示&lt;/h3&gt;
&lt;p&gt;对于显示除了DisplayBitmapTask类外最主要的就是下面类图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170521160659997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;显示&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于BitmapDisplayer类图是对Bitmap进行进一步处理的过程，处理成圆形等等。&lt;/p&gt;
&lt;p&gt;对于ImageAware的类图主要是处理View的显示，弱引用View避免内存泄露，其中是通过&lt;strong&gt;模板方法&lt;/strong&gt;模式组织。&lt;/p&gt;
&lt;p&gt;ViewAware&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Override
    public boolean setImageBitmap(Bitmap bitmap) {
       if (Looper.myLooper() == Looper.getMainLooper()) {
          View view = viewRef.get();
          if (view != null) {
             setImageBitmapInto(bitmap, view);
             return true;
          }
       } else {
          L.w(WARN_CANT_SET_BITMAP);
       }
       return false;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于ViewAware子类只需要实现相应的抽象方法。&lt;/p&gt;
&lt;h2 id=&#34;imageloader问题解答&#34;&gt;ImageLoader问题解答&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;加载网络的图片是比较耗时，ImageLoader使用三级缓存进行处理。&lt;/li&gt;
&lt;li&gt;图片内存占用优化，Android-Universal-Image-Loader中ImageLoaderConfigue可以配置最大的长宽，而且还会根据View的大小计算出相应的图片大小。在ImageSizeUtils中获取ImageSize，而对于ImageDecoder中根据ImageSize进行计算取样（Glide会缓存两份，一份是大图，一份是缩略图，对于控件比较小，直接从缩略图中加载，以后分析Glide的时候在详细讲解）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public static ImageSize defineTargetSizeForView(ImageAware imageAware, ImageSize maxImageSize) {
          int width = imageAware.getWidth();
          if (width &amp;lt;= 0) width = maxImageSize.getWidth();

          int height = imageAware.getHeight();
          if (height &amp;lt;= 0) height = maxImageSize.getHeight();

          return new ImageSize(width, height);
       }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;对于色彩的优化，这里没有指定，默认是Bitmap.Config.ARGB_8888，如果需要优化需要自己指定。（对&lt;a href=&#34;https://github.com/bumptech/glide&#34;&gt;Glide&lt;/a&gt;默认是565）。&lt;/li&gt;
&lt;li&gt;线程的优化
&lt;ul&gt;
&lt;li&gt;对于Activity的生命周期有优化，不过需要自己手动设置pause，还有stop等，（&lt;a href=&#34;https://github.com/bumptech/glide&#34;&gt;Glide&lt;/a&gt;实现了自动管理）&lt;/li&gt;
&lt;li&gt;对于ListView的滑动，优化加载可见View的图片，具体可参考ImageLoader类的cancelDisplayTask方法（也是需要自己去实现，&lt;a href=&#34;https://github.com/bumptech/glide&#34;&gt;Glide&lt;/a&gt;实现自动管理）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展性与易用性，对于扩展性，使用面向接口，从而摆脱对具体实现的依赖。对于易用性，通过Facade模式来完成，隐藏底层细节，对外高层级的接口。&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%BC%80%E6%BA%90%E5%BA%93/">开源库</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/imageloader/">ImageLoader</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Volley传输网络数据</title>
                <link>https://example.com/posts/2017-11-04-volley%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/</link>
                <guid isPermaLink="true">https://example.com/posts/2017-11-04-volley%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE/</guid>
                <pubDate>Sat, 04 Nov 2017 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Volley是一个HTTP的库，能够让Android Apps的网络请求更容易，更迅速。Vollery在&lt;a href=&#34;https://github.com/google/volley&#34;&gt;github&lt;/a&gt;可以获取到。&lt;/p&gt;
&lt;p&gt;Volley有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动调度网络请求&lt;/li&gt;
&lt;li&gt;多个并发的网络连接&lt;/li&gt;
&lt;li&gt;标准的Http &lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_coherence&#34;&gt;cache coherence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;支持请求优先级&lt;/li&gt;
&lt;li&gt;取消请求的API，可以取消简单的请求，也可以取消一组网络请求&lt;/li&gt;
&lt;li&gt;可定制性，比如重试，重定向等&lt;/li&gt;
&lt;li&gt;强大的排序，可以轻松地使用网络请求的数据正确的填充到UI上。&lt;/li&gt;
&lt;li&gt;调试和跟踪的工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Volley的优点在于使用RPC-type的操作来填充UI，比如获取到一页的搜索结果作为结构化的数据。它可以轻松地与任何协议集成，Volley自带了字符串，图片和JSON的支持。通过内嵌一些特性，Volley可以让你从模板的代码中摆脱出来，而只需关注App的特定的逻辑。&lt;/p&gt;
&lt;p&gt;Volley不适合大型的下载或者流操作。因为Volley在解析的时候会把所有的响应保存到内存中，对于大型的下载操作，可以考虑使用&lt;a href=&#34;https://developer.android.com/reference/android/app/DownloadManager.html&#34;&gt;DownloadManager&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Vollery核心库是在&lt;a href=&#34;https://github.com/google/volley&#34;&gt;github&lt;/a&gt;上开发的，主要有请求分发以及一系列的通用的工具类，可以在Volley的工具箱中获取到。在项目中添加Volley最容易的方式是在gradle文件中添加以下内容。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;dependencies&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;compile&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;android&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;volley&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;volley&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;你也可以克隆Volley仓库并且设置它作为一个library工程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过下列的命令来克隆Volley的仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/google/volley&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导入源码到你的app工程里作为Android library，在&lt;a href=&#34;https://developer.android.com/studio/projects/android-library.html&#34;&gt;Create an Android Library&lt;/a&gt;查看如何创建Android library库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;发送简单请求&#34;&gt;发送简单请求&lt;/h2&gt;
&lt;p&gt;更高层次上，可以创建一个&lt;strong&gt;RequestQueue&lt;/strong&gt;传递给它&lt;strong&gt;Request&lt;/strong&gt;对象。&lt;strong&gt;RequestQueue&lt;/strong&gt;管理工作线程，这些工作线程用于运行网络请求，读写缓存和解析网络响应。Request解析原始的响应并且Volley分派解析后的响应返回到主线程中。&lt;/p&gt;
&lt;p&gt;这节描述如何使用&lt;strong&gt;Volley.newRequestQueue&lt;/strong&gt;方法发送请求，此方法设置一个&lt;strong&gt;RequestQueue&lt;/strong&gt;供我们使用。看&lt;strong&gt;设置RequestQueue&lt;/strong&gt;一节也可以了解如何自己设置&lt;strong&gt;RequestQueue&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这节描述如何使用&lt;strong&gt;RequestQueue&lt;/strong&gt;去添加请求和取消请求。&lt;/p&gt;
&lt;h3 id=&#34;添加网络权限&#34;&gt;添加网络权限&lt;/h3&gt;
&lt;p&gt;使用Volley，必须在manifest文件中添加&lt;code&gt;android.permission.INTERNET&lt;/code&gt;权限。&lt;/p&gt;
&lt;h3 id=&#34;使用newrequestqueue&#34;&gt;使用newRequestQueue&lt;/h3&gt;
&lt;p&gt;Volley提供了方便的方法&lt;strong&gt;Volley.newRequestQueue&lt;/strong&gt;去创建&lt;strong&gt;RequestQueue&lt;/strong&gt;，使用默认行为启动队列。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TextView&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mTextView&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TextView&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findViewById&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Instantiate the RequestQueue.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RequestQueue&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Volley&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;http://www.google.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Request a string response from the provided URL.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StringRequest&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// Display the first 500 characters of the response string.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;mTextView&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Response is: &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;500&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ErrorListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onErrorResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;VolleyError&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;mTextView&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;That didn&amp;#39;t work!&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// Add the request to the RequestQueue.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Volley传递解析后的响应到主线程中。主线程中使用接受到的数据填充UI是很方便的，同时你也在响应监听器中可以修改UI控件。&lt;/p&gt;
&lt;h3 id=&#34;发送请求&#34;&gt;发送请求&lt;/h3&gt;
&lt;p&gt;为了发送request，需要简单地构建一个&lt;strong&gt;Request&lt;/strong&gt;并且使用add方法添加到&lt;strong&gt;RequestQueue&lt;/strong&gt;，正如显示的，一旦添加了&lt;strong&gt;Request&lt;/strong&gt;，它将被传递，获取服务，有它自己解析响应，最终传递结果。&lt;/p&gt;
&lt;p&gt;当调用add方法的时候，Volley会运行一个缓存处理线程和网络分发的线程。当添加请求到队列中，请求就会被cache线程选取并且分类：如果请求能从cache中获取，缓存的响应将会在cache线程中解析并把解析后的响应传递到主线程中。如果请求不能从cache中获取，请求将被放置到网络队列里。首先网络线程会从网络队列中获取Request，执行HTTP传输，在工作线程中解析响应，把响应写入到缓存，然后把解析后的响应传递到主线程中。&lt;/p&gt;
&lt;p&gt;注意这些昂贵的开销像阻塞的I/O和解析和解码是在工作线程完成的。你可以在任意线程中添加Request，但是响应总是被传递到主线程中。&lt;/p&gt;
&lt;p&gt;图1展示了request的生命周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170612224303424?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;这里写图片描述&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;取消request&#34;&gt;取消Request&lt;/h3&gt;
&lt;p&gt;为了取消Request，调用cancel()方法。一旦Request被取消，Volley保证响应的handler不会被调用。这意味着在实践中你能在Activity的onStop()方法取消所有的request并且也不需要在响应的Handler中有getActivity()==null的检测，是否onSaveInstanceState()已经被调用了，或者其他的防御的编码。&lt;/p&gt;
&lt;p&gt;为了利用这个行为，需要做的就是跟踪所有的request，能够在恰当的时机取消它们。一个比较简单的方法：可以给每个Request对象分配一个tag对象。你可以使用这个tag去支持取消一定范围的Request。例如，可以使用activity类标记所有请求，然后在onStop()方法中调用&lt;strong&gt;requestQueue.cancelAll(this)&lt;/strong&gt;。类似情景是可以在ViewPager的当前的Tab标记所有的缩略图的请求，在滑动到新的Tab的时候然后取消request。&lt;/p&gt;
&lt;p&gt;下面的例子使用字符串来添加tag&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义tag，并在request中添加tag&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TAG&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;MyTag&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;StringRequest&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Assume this exists.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RequestQueue&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// Assume this exists.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// Set the tag on the request.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setTag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TAG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Add the request to the RequestQueue.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;在你的activity的onStop()方法中，使用tag取消所有的Request&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onStop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onStop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;cancelAll&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TAG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;取消请求时请留意。如果你依赖于你的响应处理程序（也就是回调）来推进状态或启动另一个进程，则需要解决此问题。再次提醒，一旦Request被取消响应的处理代码（也就是回调）将不被调用。&lt;/p&gt;
&lt;h2 id=&#34;设置requestqueue&#34;&gt;设置RequestQueue&lt;/h2&gt;
&lt;p&gt;前面的章节讲解了如何使用Volley.newRequestQueue去设置一个默认行为的RequestQueue，这节将会带你领略创建RequestQueue的真正的步骤，设置自定义的RequestQueue。&lt;/p&gt;
&lt;p&gt;这节也描述了推荐的创建RequestQueue的方式单例，这样可以保证RequestQueue与APP的生命周期一致。&lt;/p&gt;
&lt;h4 id=&#34;设置network和cache&#34;&gt;设置Network和Cache&lt;/h4&gt;
&lt;p&gt;一个RequestQueue需要两件事来完成它的工作：一个是network去执行Request的传输，和一个cache来处理缓存。在Volley的工具库中有相关的标准实现：DiskBasedCache提供了 one-file-per-response的缓存带着内存的索引，和BasicNetwork提供了网络传输依据于你的首选的HTTP客户端。&lt;/p&gt;
&lt;p&gt;BasicNetwork是Volley的默认网络实现。一个BasicNetwork必须被一个HTTP客户端初始化。典型的是HttpURLConnection。（也可以使用OkHttp来实现）&lt;/p&gt;
&lt;p&gt;下面的代码展示了设置RequestQueue的步骤：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;RequestQueue&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Instantiate the cache
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Cache&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DiskBasedCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getCacheDir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1024&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 1MB cap
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// Set up the network to use HttpURLConnection as the HTTP client.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Network&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;network&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BasicNetwork&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HurlStack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Instantiate the RequestQueue with the cache and network.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Start the queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;http://www.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Formulate the request and handle the response.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StringRequest&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// Do something with the response
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ErrorListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onErrorResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;VolleyError&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// Handle error
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Add the request to the RequestQueue.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果你只需要一次性的请求并且不想离开线程池，您可以在需要的地方创建RequestQueue，并在您的响应或错误返回后在RequestQueue上调用stop（）。但是更常用的情景是创建RequestQueue作为单例并且保持RequestQueue在APP的生命周期中一直运行，下节将会讲解。&lt;/p&gt;
&lt;h4 id=&#34;使用单例模式&#34;&gt;使用单例模式&lt;/h4&gt;
&lt;p&gt;如果你的应用一直使用网络，那或许需要设置单例的RequestQueue并且保证RequestQueue与在APP的生命周期一致。你可以通过各种方式实现。推荐的方法是实现单例类包裹着RequestQueue和其他的Volley功能。另一个方式实现Application的子类设置RequeueQueue在 &lt;strong&gt;Application.onCreate()&lt;/strong&gt;。但是这种方式是不鼓励的；静态的单例可以更加模块化的方式提供相同的功能。&lt;/p&gt;
&lt;p&gt;一个关键的点是RequestQueue实例化时使用Appliction context而不是Activity context。确保RequestQueue在应用的生命周期中一直在运行，而不是每次随着activity的创建一直被销毁再创建。&lt;/p&gt;
&lt;p&gt;下面的单例的例子提供了RequestQueue和ImageLoader的功能:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MySingleton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MySingleton&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RequestQueue&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ImageLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mImageLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mCtx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;MySingleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;mCtx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;mImageLoader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ImageLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ImageLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ImageCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LruCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bitmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LruCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bitmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

            &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
            &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bitmap&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getBitmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

            &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
            &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;putBitmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bitmap&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bitmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bitmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MySingleton&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Context&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;mInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MySingleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RequestQueue&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// getApplicationContext() is key, it keeps you from leaking the
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// Activity or BroadcastReceiver if someone passes one in.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Volley&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mCtx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getApplicationContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addToRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;getRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ImageLoader&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getImageLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mImageLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下面的例子是使用单例的RequestQueue。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Get a RequestQueue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RequestQueue&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;queue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MySingleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getApplicationContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()).&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;getRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// Add a request (in this example, called stringRequest) to your RequestQueue.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MySingleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addToRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stringRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;标准请求&#34;&gt;标准请求&lt;/h2&gt;
&lt;p&gt;本节将描述如何使用Volley支持的常用类型：&lt;/p&gt;
&lt;p&gt;StringRequest：指定特定URL并且在响应中接受到字符串，对于例子可以看&lt;strong&gt;设置RequeseQueue&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JsonObjectRequest和JsonArrayRequest（二者均为&lt;strong&gt;JsonRequest&lt;/strong&gt;的子类）：指定特定的URL并且会获取到JSON或者JSON数据组。&lt;/p&gt;
&lt;p&gt;如果你期望的响应是这些类型的一种，那不需要设置自定义的Request。这节将描述怎么去使用这些标准的请求类型，对于如何自定义Request请看下一节。&lt;/p&gt;
&lt;h3 id=&#34;json-request&#34;&gt;JSON Request&lt;/h3&gt;
&lt;p&gt;Volley为JSON请求提供了下面的类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JsonArrayRequest ：一个Request给定URL，将会接受到&lt;a href=&#34;https://developer.android.com/reference/org/json/JSONArray.html&#34;&gt;JSONArray&lt;/a&gt;的响应body&lt;/li&gt;
&lt;li&gt;JsonObjectRequest：一个Request给定的URL，接受到&lt;a href=&#34;https://developer.android.com/reference/org/json/JSONObject.html&#34;&gt;JSONObject&lt;/a&gt;响应body，允许&lt;a href=&#34;https://developer.android.com/reference/org/json/JSONObject.html&#34;&gt;JSONObject&lt;/a&gt;作为请求body的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述的两个类均为JSONObject的子类。你使用下面的模板来使用其他的JSON类。例如，下面的代码片段描述了获取JSON并展示到UI上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;TextView&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mTxtDisplay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ImageView&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mImageView&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;mTxtDisplay&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TextView&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findViewById&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;txtDisplay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;http://my-json-feed&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;JsonObjectRequest&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jsObjRequest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JsonObjectRequest&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JSONObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JSONObject&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;mTxtDisplay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Response: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ErrorListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;onErrorResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;VolleyError&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// TODO Auto-generated method stub
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Access the RequestQueue through yozur singleton class.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MySingleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addToRequestQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jsObjRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对于实现自定义的Request依赖于&lt;a href=&#34;https://github.com/google/gson&#34;&gt;Gson&lt;/a&gt;, 可以看下节。&lt;/p&gt;
&lt;h2 id=&#34;实现自定义的request&#34;&gt;实现自定义的Request&lt;/h2&gt;
&lt;p&gt;本节将描述怎么实现自定义的Request类型。&lt;/p&gt;
&lt;h3 id=&#34;自定义request&#34;&gt;自定义Request&lt;/h3&gt;
&lt;p&gt;在工具类中需要的Request都可以拿来即用；如果你的响应的数据类型是String，Image，或者JSON，那不必实现自定义的Request。&lt;/p&gt;
&lt;p&gt;对于实现自定义的Request你仅仅需要实现下面的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承Request&lt;T&gt;类，&lt;T&gt;为参数化表示期望解析的响应的类型。因此如果希望解析的响应是一个字符串就需要继承Request&lt;String&gt;。可以查看类StringRequest和ImageRequest作为继承Request&lt;T&gt;的例子。&lt;/li&gt;
&lt;li&gt;实现parseNetworkResponse() 和 deliverResponse()抽象方法，下面有更多细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;parsenetworkresponse方法&#34;&gt;parseNetworkResponse方法&lt;/h3&gt;
&lt;p&gt;Response封装了给定类型解析后的响应，（比如String，image或者JSON）。下面是一个parseNetworkResponse() 的实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;parseNetworkResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;NetworkResponse&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;json&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;HttpHeaderParser&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;parseCharset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gson&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fromJson&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clazz&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;HttpHeaderParser&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;parseCacheHeaders&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// handle errors
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NetworkResponse作为parseNetworkResponse()的参数，NetworkResponse包含响应作为byte[]类型，HTTP 状态码，和响应头。&lt;/li&gt;
&lt;li&gt;实现必须返回一个Response&lt;T&gt;，它包含了实现的响应对象的类型和缓存原始数据或者在解析失败的情况下的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你的协议包含非标准的语义，你可以构建自己的Cache.Entry,但是大多数请求都是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myDecodedObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;HttpHeaderParser&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;parseCacheHeaders&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Volley调用parseNetworkResponse()方法是在工作线程中。这个确保了耗时的操作不会阻塞主线程，比如解析JPEG成Bitmap。&lt;/p&gt;
&lt;h3 id=&#34;deliverresponse方法&#34;&gt;deliverResponse方法&lt;/h3&gt;
&lt;p&gt;Volley返回parseNetworkResponse()的对象传递到主线程。大多数的请求会在这里调用回调接口，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;deliverResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;例如GsonRequest&lt;/p&gt;
&lt;p&gt;Gson是一个使用反射技术把java对象转化成JSON，或者JSON转化为Java对象的库。你可以定义java对象与它对应的JSON的key有相同的名字。传递Gson对象，并且Gson将会填充对象的属性。下面是完整的Volley的Request实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GsonRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Gson&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gson&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Gson&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clazz&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * Make a GET request and return a parsed object from JSON.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * @param url URL of the request to make
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * @param clazz Relevant class object, for Gson&amp;#39;s reflection
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * @param headers Map of request headers
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     */&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GsonRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clazz&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ErrorListener&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;errorListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;errorListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;clazz&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clazz&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;headers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;listener&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getHeaders&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AuthFailureError&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;headers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getHeaders&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;deliverResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;listener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;parseNetworkResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NetworkResponse&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;json&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;HttpHeaderParser&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;parseCharset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;success&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;gson&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fromJson&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clazz&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;HttpHeaderParser&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;parseCacheHeaders&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UnsupportedEncodingException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ParseError&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JsonSyntaxException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Response&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ParseError&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Volley提供了方便的类JsonArrayReques和JsonArrayObject。可以看&lt;strong&gt;标准请求&lt;/strong&gt;一节来查看更多信息。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%BC%80%E6%BA%90%E5%BA%93/">开源库</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/volley/">Volley</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>高效实用Android Studio (一)</title>
                <link>https://example.com/posts/android_studio/2017-11-04-%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8android-studio-%E4%B8%80/</link>
                <guid isPermaLink="true">https://example.com/posts/android_studio/2017-11-04-%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8android-studio-%E4%B8%80/</guid>
                <pubDate>Sat, 04 Nov 2017 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;&lt;img src=&#34;https://example.com/assets/images/AndroidStudio/android-studio-logo.png&#34; alt=&#34;logo&#34;&gt;{: .align-center}&lt;/p&gt;
&lt;h2 id=&#34;快捷键&#34;&gt;快捷键&lt;/h2&gt;
&lt;p&gt;设置Preferences -&amp;gt; Keymap 设置快捷键，可以修改，或者添加keymap等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.blog.csdn.net/20170719202536443?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;kemap&#34;&gt;&lt;/p&gt;
&lt;p&gt;常用快捷键，每个系统及其设置不同，这里只是说出对应的名称，这样就可以直接搜索来查找快捷键。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run  运行安装APK&lt;/li&gt;
&lt;li&gt;Find
&lt;ol&gt;
&lt;li&gt;Find 在本文件内查找
2. Find in Path 在工程中查找
3. Find Usages 查找引用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Rename 重命名&lt;/li&gt;
&lt;li&gt;Sync Project with Gradle Files 同步Gradle&lt;/li&gt;
&lt;li&gt;Generate 生成代码或者字段的get或者set方法等等&lt;/li&gt;
&lt;li&gt;File Structure 查看类的方法等&lt;/li&gt;
&lt;li&gt;Type Hierarchy 查看继承关系&lt;/li&gt;
&lt;li&gt;Editor Tabs
&lt;ol&gt;
&lt;li&gt;Select Next Tab 选择下一个编辑窗口&lt;/li&gt;
&lt;li&gt;Select Previous Tab 选择上一个编辑窗口&lt;/li&gt;
&lt;li&gt;close 关闭一个编辑窗口&lt;/li&gt;
&lt;li&gt;close Others 关闭其他窗口&lt;/li&gt;
&lt;li&gt;close All 关闭所有的窗口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码格式&#34;&gt;代码格式&lt;/h2&gt;
&lt;p&gt;设置Tab的信息，Use tab character,未勾选将会使用空格代替Tab。
&lt;img src=&#34;http://img.blog.csdn.net/20170719202621693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;设置Tab&#34;&gt;&lt;/p&gt;
&lt;p&gt;经常的我们会有设置类的字段的命名m开头，我们就可以在Code Style -&amp;gt; Java -&amp;gt; Code Generation路径下，使用Name Prefix设置前缀，也可以使用Name suffix也可以设置后缀。
&lt;img src=&#34;http://img.blog.csdn.net/20170719202708883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;设置字段前缀&#34;&gt;&lt;/p&gt;
&lt;p&gt;设置文件的特定内容，比如作者等等。可以设置自己的代码风格。
&lt;img src=&#34;http://img.blog.csdn.net/20170719202744623?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;File Header&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;技巧&#34;&gt;技巧&lt;/h2&gt;
&lt;p&gt;设置Live Templates，添加模板代码。
&lt;img src=&#34;http://img.blog.csdn.net/20170719202818298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ZlaWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;Live Templates&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加并勾选&lt;/li&gt;
&lt;li&gt;设置abbreviation，当输入的时候会有补全，输入完成就会有响应的代码生成&lt;/li&gt;
&lt;li&gt;设置描述&lt;/li&gt;
&lt;li&gt;设置代码的内容&lt;/li&gt;
&lt;li&gt;设置什么时候会提醒，根据自己的需要设置相关的功能&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android-studio/">Android Studio</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/android-studio/">Android Studio</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>重构原则</title>
                <link>https://example.com/posts/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/2016-08-30-%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/</link>
                <guid isPermaLink="true">https://example.com/posts/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/2016-08-30-%E9%87%8D%E6%9E%84%E5%8E%9F%E5%88%99/</guid>
                <pubDate>Tue, 30 Aug 2016 21:27:50 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;&lt;img src=&#34;https://github.com/wfeii/wfeii.github.io_raw_important/blob/master/%E9%87%8D%E6%9E%84-%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%842-%E5%8E%9F%E5%88%99.png?raw=true&#34; alt=&#34;重构原则&#34;&gt;{: .align-center}&lt;/p&gt;
&lt;h2 id=&#34;何谓重构&#34;&gt;&lt;strong&gt;何谓重构&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;重构 ： 对软件内部结构的一种调整，目的是在不改变软件可观察性的前提下，提高其可理解性，降低其修改的成本 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实重构是在不改变代码的功能基础上，提高代码的可读性，提高代码的扩展性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两顶帽子&lt;/strong&gt;&lt;br&gt;
添加新功能，重构。在软件开发中，两种情况不断变换，首先可能尝试添加新功能，其次意识到： 结构调整一下，功能更容易添加。于是就做一次重构，结构调整好之后，继续添加新功能，发现问题又会重构，就这样迭代。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Notice: 在做新功能时候，不能只为添加新功能而添加新功能，需要保持代码的结构性，易读性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;为何重构&#34;&gt;&lt;strong&gt;为何重构&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重构改进软件设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有重构，程序的设计可能逐渐的不可控，程序的机构性会遭到破坏，代码的可读性也会降低。&lt;strong&gt;代码机构的流失是累积的，越难看出代码的设计意图，就越难保护其设计，代码的设计腐败的越快，代码的可控性就严重降低。&lt;/strong&gt; 通过重构可以让所有的代码回归的到本身应该在的位置。重构帮助代码维持该有的设计。
&lt;br /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重构使软件更容易理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引用一句话，我觉得很恰当&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;连傻子都能写出让机器机能运行的代码，但优秀的代码却是能让人理解的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序设计很大程度上是跟计算机交流，但是除了跟计算机交流之外最重要的交流对象是人，&lt;strong&gt;写的连鬼都看不懂的代码，让人看个鬼，过了一段时间自己都看不懂自己写的代码就真是见了鬼了（这种情况比见到鬼容易多了，哈哈哈）&lt;/strong&gt;。通过重构可以保证代码的可读性，而且通过重构可以更好的理解不熟悉的代码。&lt;br&gt;
重构的开始可能只提留在细枝末节上。随着代码的简化，我们可以看到一些一些一切看不到的设计的层面的问题，有前辈把“早期重构”描述为“擦掉窗户上的污垢，使你看的更远”。如果没有重构，达不到这种层次。
&lt;br /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重构帮助找到bug&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于代码的理解，可以帮助找到bug。通过重构更深入的理解代码的结构、行为，从而找到隐藏很深的bug。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我不是一个伟大的程序员，我只是个有着一些优秀习惯的程序员
- Kent Beck&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提高编程速度&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;良好的设计是快速开发的根本，拥有良好的设计才能快速的开发。如果没有良好的设计，或许一段时间内你的进展迅速，但恶劣的设计很快就让你的速度慢下来。会有大量的时间去调试，理解代码的逻辑，寻找重复的代码。最终坏的代码带来大的灾难。&lt;br&gt;
重构一定程度提高了代码的扩展性，保持了代码良好的结构，添加新功能也就容易点。&lt;br&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;何时重构&#34;&gt;&lt;strong&gt;何时重构&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;你不应该为了重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把事情做好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;三次法则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事不过三，三则重构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出现了代码重复，说明需要重构了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加新功能时重构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过重构可以更好的理解代码的逻辑，理清代码的结构，更好的添加新功能。&lt;/li&gt;
&lt;li&gt;代码的设计无法帮助我们轻松的添加想要的功能时候，就需要重构来更好的添加新功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;修复bug时候&lt;/strong&gt;&lt;br&gt;
收到bug但是不能一眼看出bug的问题，很大程度说明代码的逻辑不够清楚，需要重构了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复审代码时重构&lt;/strong&gt; &lt;br&gt;
复审者提出好的建议，然后一起探讨一些修改能否通过重构轻松实现，如果是这样，一起着手修改，这样保证了代码的质量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么重构有用&lt;/strong&gt;&lt;br&gt;
程序有两方面的价值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;今天可以为你做什么&lt;/li&gt;
&lt;li&gt;明天可以为你做什么
我们都只关注今天想要程序做什么。修复bug,添加新功能，我们都是为了让程序能力更强，让它今天更有价值。如果为了今天的工作不择手段，导致不可能在明天完成任务，最终还是失败。重构是摆脱这个困境的道路。&lt;strong&gt;如果发现昨天的决定已经不能适应今天的情况，放心改变这个决定就是，然后就可以完成今天的决定，日复一日。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是什么程序难以修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难以阅读的代码，难以修改&lt;/li&gt;
&lt;li&gt;逻辑重复的代码，难以修改&lt;/li&gt;
&lt;li&gt;添加新行为时需要修改已有的代码结构，难以修改&lt;/li&gt;
&lt;li&gt;带有复杂逻辑的程序，难以修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重构的难题&#34;&gt;&lt;strong&gt;重构的难题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大多数商用程序都与它们背后的数据库耦合在一起，导致了数据结构难以修改之一&lt;/li&gt;
&lt;li&gt;数据迁移，非常小心地将系统分层，将数据结构和对象模型间的一类降至最低，但数据库结构的改变还是会让人不得不迁移所有的数据
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;修改接口&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于未发布的接口 如果接口的调用者都在自己的控制下，修改接口不会造成影响&lt;/li&gt;
&lt;li&gt;已发布的接口 接口已经发布了，那么就需要维护新旧接口，保证调用者正常运行，对于旧接口可以通过新接口来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不要过早发布接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;难以通过重构手法完成设计的改动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑候选设计方案时，想想将某个方案改为另一设计的难度又多大？如果看上去简短，就不必担心选择是否得当，就可以先简单实现。如果预先不到重构方法，就需要在设计上投入更多力气。
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时不该重构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重写，有时既有代码的是在太混乱，重构不如重写一个简单。重写的一个信号就是现有代码不能正常的运行。&lt;/li&gt;
&lt;li&gt;项目已经接近尾声，没有时间来重构。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重构与设计&#34;&gt;&lt;strong&gt;重构与设计&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一种观点，重构代替预先设计，只是按照最开始的想法编程，让代码有效运行，然后再重构成型，极限编程的支持者也支持这种方式。虽然这个方式也能收到很好的效果，但不是最有效的方式。往往可能会推到重做。&lt;/li&gt;
&lt;li&gt;一种观点是检验各种想法，然后得到一个可以被接受的解决方案，然后再开始编程，最后再使用重构。这种方式简化了设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;过度的设计往往是不需要的，每个可能变化都提高灵活性，不仅工作量大，而且整个系统的复杂度大大的增加了。可是这些灵活性在后面的开发中可能完全用不到。先简单的实现，然后需要的时候通过重构来达到灵活性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;
&lt;h2 id=&#34;重构与性能&#34;&gt;&lt;strong&gt;重构与性能&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然重构&lt;strong&gt;可能&lt;/strong&gt;使软件运行更慢，但是它也可以使软件的优化更容易。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三种编写出快速的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间预算法，分解设计时做好预算，每个组件预定分配一定资源。每个组件不能超出自己的预算。这种方式只适用于实时性的系统。&lt;/li&gt;
&lt;li&gt;持续关注法，这种方式要求程序员在任何时间做任何事时，都要保持系统的高性能。这种方式如果为了提高性能，通常会使程序难以维护，进而减缓开发的速度。然后性能改善一但被分散程序的各个角落，每次改善并不能去除实际问题。&lt;/li&gt;
&lt;li&gt;性能提升法，如果一视同仁地优化所有代码，往往90%的优化都是徒劳的。此方法使用工具找到性能热点，然后重构保证程序正常运行，并优化性能，一单发现不能提高性能，直接回退。然后继续的&amp;quot;发现热点，去除热点&amp;quot;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;良好的程序首先可以保证开速地增加功能，有更多的时间优化，其次良好的程序，进行调优时候又较细的粒度，从而更容易调优。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E9%87%8D%E6%9E%84/">重构</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/%E9%87%8D%E6%9E%84/">重构</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>UI优化</title>
                <link>https://example.com/posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/</link>
                <guid isPermaLink="true">https://example.com/posts/android_optimize/2016-08-06-ui%E4%BC%98%E5%8C%96/</guid>
                <pubDate>Sat, 06 Aug 2016 16:40:12 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;总结来源与Google发布的性能优化的视频 &lt;strong&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&#34;&gt;Android Performance Patterns&lt;/a&gt;&lt;/strong&gt; 和   &lt;strong&gt;&lt;a href=&#34;https://www.udacity.com/course/android-performance--ud825&#34;&gt;Android Performance Optimizing Apps for Speed and Usability&lt;/a&gt;&lt;/strong&gt;
对于用户感到卡顿,不流畅的原因有很多,比如Layout层级结构过深,动画过多,界面刷新,等等导致了CPU或者GPU的负担过重,16ms内无法完成一帧的绘制,导致了掉帧,从而表现出卡顿,不流畅.&lt;/p&gt;
&lt;h2 id=&#34;绘制原理&#34;&gt;绘制原理&lt;/h2&gt;
&lt;p&gt;为了更好的理解UI优化,在此之前先要说明一下硬件的基础.&lt;/p&gt;
&lt;h3 id=&#34;vsync&#34;&gt;VSYNC&lt;/h3&gt;
&lt;p&gt;两个概念 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的参数，例如60Hz。&lt;/li&gt;
&lt;li&gt;Frame Rate：代表了GPU在一秒内绘制的帧数,例如60fps。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GPU获取图形数据绘制,然后硬件负责把绘制的内容显示再屏幕上,二者协调正常.&lt;/p&gt;
&lt;p&gt;如果帧速率高于屏幕刷新速率,就会出现撕裂的现象,一部分显示当前的帧,一部分显示现在的帧,这种解决的方案就是双缓冲机制,GPU将帧写进存储器被成为back buffer,而存储器的次级区域成为frame buffer,当写入一帧时,它会开始填充back buffer,而framen buffer保持不变,现在刷新屏幕,使用frame buffer进行绘制,刷新屏幕,vsync触发,也会把back buffer复制到fragme buffer.
更具体的内容参考: &lt;strong&gt;&lt;a href=&#34;http://source.android.com/devices/graphics/index.html&#34;&gt;Graphics&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果屏幕刷新速率高于帧速率时,就会导致屏幕显示还是上一帧的内容,从而出现卡顿,动画不流畅等现象&lt;/p&gt;
&lt;h3 id=&#34;一帧画面绘制过程&#34;&gt;一帧画面绘制过程&lt;/h3&gt;
&lt;p&gt;了解了VSYNC的原理,下面该考虑应用程序是如何把画面绘制到屏幕上的了?或者是如何把XML文件转换成用户能够看到并理解的图像的?&lt;/p&gt;
&lt;p&gt;其实这个过程的核心就是进行光栅化(rasterization)的处理过程.这个过程就是把一些高级的对象,比如字符串,形状等转换成屏幕上纹理中的像素点.光栅化是一个非常耗时的过程.正因如此,手机硬件上有一个特殊的部分用于提高光栅化的过程,叫做图像处理器,或者说GPU.
&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/android%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%8A%BD%E8%B1%A1%E5%9B%BE.png&#34; alt=&#34;1-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;图像绘制到屏幕上首先在CPU上转换成多边形或者纹理,然后再传递到GPU进行光栅化处理,处理UI对象并转化成多边形和纹理并不是很快的操作,同样从CPU传递给GPU也不是那么快,这行就想办法较少UI对象转换的数量,和提交到GPU的数量,OpenGL ES API允许你将内容传递到GPU,并保存到GPU中,当以后再次绘制一个按钮的时候,只需要参考GPU内存中的已经存在的纹理.&lt;/p&gt;
&lt;p&gt;渲染优化,尽可能多且快的将更多的数据上传到GPU,然后留在GPU中,尽可能长的时间里不去修改.每次更新GPU中的资源,你将会失去宝贵的处理时间.&lt;/p&gt;
&lt;p&gt;下面说明什么时候会导致GPU资源更新.
Android把xml语言转化成GPU能够识别的资源从而渲染到屏幕上,是通过Display List来实现的,一个Display List对象中基本上包含了所有GPU需要的渲染信息,Display List中包含了GPU可能需要的常用的资源列表,同时也包含了Open GL命令列表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/displayList%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;Alt text&#34;&gt;
在某个视图第一次需要被渲染时,Display List就会被创建,当视图需要显示在屏幕时,会执行GPU的相关指令来进行渲染.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/layout%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png&#34; alt=&#34;Alt text&#34;&gt;
从上图可以看出&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只是View属性改变时,只是参考GPU内存中的已经存在,然后执行相关Open GL进行渲染,&lt;/li&gt;
&lt;li&gt;InvaliDated View也不会重新创建Display List&lt;/li&gt;
&lt;li&gt;View 布局改变,比如可见性,大小等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优化点&#34;&gt;优化点&lt;/h2&gt;
&lt;h3 id=&#34;概述-1&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。
&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/android_performance_course_render_problems.jpg&#34; alt=&#34;Alt text&#34;&gt;
对于CPU,应该尽量减少布局的层级深度,CPU减少measure等操作的时间,而对于GPU主要是减少不必要的过度绘制.&lt;/p&gt;
&lt;h3 id=&#34;过度绘制&#34;&gt;过度绘制&lt;/h3&gt;
&lt;p&gt;过度绘制是指同一帧内一个像素点绘制了多次,通过查看overdraw(开发者选项-&amp;gt; 调试GPU过度绘制)
&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/overdraw.png&#34; alt=&#34;Alt text&#34;&gt;&lt;/p&gt;
&lt;p&gt;颜色代表了像素点过度绘制的次数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True color: No overdraw&lt;/li&gt;
&lt;li&gt;Blue: Overdrawn once&lt;/li&gt;
&lt;li&gt;Green: Overdrawn twice&lt;/li&gt;
&lt;li&gt;Pink: Overdrawn three times&lt;/li&gt;
&lt;li&gt;Red: Overdrawn four or more times&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举例说明,通过不必要的background导致了过度绘制,
&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/overdraw_example.png&#34; alt=&#34;Alt text&#34;&gt;
左边是使用了大量的backgroud导致了严重的过度绘制,而右图可以看到移除不必要的background后的效果.
有些过度绘制是不可避免的,优化的目标是尽可能的大部分布局显示真是颜色,少部分显示一层过度绘制.&lt;/p&gt;
&lt;p&gt;避免过渡绘制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除window的背景&lt;/li&gt;
&lt;li&gt;移除布局中不必要的背景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关的代码可以通过git获得&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/udacity/ud825-render/tree/1.11_chat_with_overdraws&#34;&gt;chart with overdraw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/udacity/ud825-render/tree/1.12_chat_overdraws_reduced&#34;&gt; chat overdraws reduced&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;布局的层级深度&#34;&gt;布局的层级深度&lt;/h3&gt;
&lt;p&gt;了解布局的层级结构可以使用hierarchy viewer,它可以很直接的&lt;strong&gt;呈现布局的层次关系&lt;/strong&gt;，&lt;strong&gt;视图组件的各种属性&lt;/strong&gt;(可以查看Vie
w可见性,焦点等,可以很好的调试View问题).
对于提升布局性能的关键是避免出现重复的嵌套布局,尽可能的减小层级的深度.
以性能优化视频中的List Item优化为例,
&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/%E5%87%8F%E5%B0%91%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png&#34; alt=&#34;Alt text&#34;&gt;
把LinearLayout的布局改为RelativeLayout布局从而减少了布局层级深度&lt;/p&gt;
&lt;p&gt;相关的代码:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/udacity/ud825-render/tree/1.31_comparing_layouts&#34;&gt;comparing layouts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/udacity/ud825-render/tree/1.32_using_a_flattened_hierarchy&#34;&gt;using a flattened hierarchy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/android%E6%80%A7%E8%83%BD/">Android性能</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>知识框架</title>
                <link>https://example.com/posts/2016-07-30-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</link>
                <guid isPermaLink="true">https://example.com/posts/2016-07-30-%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/</guid>
                <pubDate>Sat, 30 Jul 2016 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wfeii/wangfei1991.github.com_raw_important/master/knowledge.png&#34; alt=&#34;知识框架&#34;&gt;{: .align-center}&lt;/p&gt;
&lt;h1 id=&#34;内功心法&#34;&gt;&lt;strong&gt;内功心法&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;
&lt;h2 id=&#34;框架&#34;&gt;框架&lt;/h2&gt;
&lt;h2 id=&#34;重构&#34;&gt;重构&lt;/h2&gt;
&lt;h1 id=&#34;外功招式&#34;&gt;&lt;strong&gt;外功招式&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;android&#34;&gt;&lt;em&gt;Android&lt;/em&gt;&lt;/h2&gt;
&lt;h3 id=&#34;android基础&#34;&gt;Android基础&lt;/h3&gt;
&lt;h3 id=&#34;android进阶&#34;&gt;Android进阶&lt;/h3&gt;
&lt;h3 id=&#34;android性能&#34;&gt;Android性能&lt;/h3&gt;
&lt;h2 id=&#34;java&#34;&gt;&lt;em&gt;Java&lt;/em&gt;&lt;/h2&gt;
&lt;h2 id=&#34;前端&#34;&gt;&lt;em&gt;前端&lt;/em&gt;&lt;/h2&gt;
&lt;h1 id=&#34;实践&#34;&gt;&lt;strong&gt;实践&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;开源框架&#34;&gt;&lt;em&gt;开源框架&lt;/em&gt;&lt;/h2&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Android事件传递机制</title>
                <link>https://example.com/posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</link>
                <guid isPermaLink="true">https://example.com/posts/2015-11-15-touch%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
                <pubDate>Thu, 28 Jul 2016 16:40:12 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;touch事件处理&#34;&gt;Touch事件处理&lt;/h2&gt;
&lt;h3 id=&#34;activity中的touch事件处理函数&#34;&gt;Activity中的Touch事件处理函数&lt;/h3&gt;
&lt;p&gt;有touch事件来的时候,会调用Activity的dispatchTouchEvent()派发事件,然后会调用getWindow().superDispatchTouchEvent(ev)派发事件,最终会调用布局中的View.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果View中没有消耗事件,最后会调用Activity的onTouchEvent()处理.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;view的touch事件处理&#34;&gt;View的Touch事件处理&lt;/h3&gt;
&lt;h4 id=&#34;view的touch事件处理特性&#34;&gt;View的Touch事件处理特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;View中的Touch事件一个是View控件的Touch事件处理,一个是ViewGroup控件的Touch事件处理,二者处理方式有所不同&lt;/li&gt;
&lt;li&gt;View的Touch事件处理是先有子View控件处理,子View控件没有消耗,然后有父View控件进行处理.&lt;/li&gt;
&lt;li&gt;对于ViewGroup控件可以通过相关的方法拦截Touch事件&lt;/li&gt;
&lt;li&gt;View中的Touch事件处理会先调用dispatchTouchEvent()分发,然后调用onTouch()处理,未处理会调用onTouchEvent()处理.View控件还是ViewGroup控件处理逻辑都是一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;view控件的touch事件处理&#34;&gt;View控件的Touch事件处理.&lt;/h4&gt;
&lt;p&gt;View处理Touch事件时首先被调用的是dispatchTouchEvent(),此方法的主要工作是调用恰当的方法进行处理.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
	...
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
                    &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                    &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {
                result = true;
            }
        }
	...
	}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的代码很容易看出,先调用onTouch()进行处理,如果onTouch()(也就是setOnTouchListener()方法设置的listener的onTouch方法)没有消耗的话,就会调用onTouchEvent()进行处理.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以ACTION_DOWN事件分析&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
      ...
        if (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {
            switch (event.getAction()) {
				...
                case MotionEvent.ACTION_DOWN:
                    mHasPerformedLongPress = false;
                        setPressed(true, x, y);
                        checkForLongClick(0);
            }
			...
            return true;
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把代码抽取出来,基本就是设置pressed状态,检测长按事件(从方法中分析可以看出再按下500ms之后就会触发长按)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析ACTION_MOVE&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public boolean onTouchEvent(MotionEvent event) {
	    ...
        if (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {
            switch (event.getAction()) {
            ...

                case MotionEvent.ACTION_MOVE:
                    // Be lenient about moving outside of buttons
                    if (!pointInView(x, y, mTouchSlop)) {
                        // Outside button
                        removeTapCallback();
                        if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                            // Remove any future long press/tap checks
                            removeLongPressCallback();
                            setPressed(false);
                        }
                    }
                    break;
			}
		}
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;pointInView()是否在View内,一旦移动出View范围,就会移除长按消息,并设置pressed状态为false.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析ACTION_UP&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
	    ...
        if (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_UP:                    
                        if (!mHasPerformedLongPress) {
                            removeLongPressCallback();
                            if (!focusTaken) {
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }
					}
				}
		}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有触发长按事件就会mHasPerformedLongPress为false,然后移除长按事件的message,然后post(mPerformClick),如果View树已经建立联系,就会返回false,现在执行click, 否则会把mPerformClick添加进queue,等建立联系以后再执行.&lt;/p&gt;
&lt;p&gt;从上面可以总结出click事件的触发的touch事件&lt;br&gt;
点击事件: ACTION_DOWN -&amp;gt; ACTION_UP,  ACTION_DOWN -&amp;gt; ACTION_MOVE...-&amp;gt; ACTION-&amp;gt;UP(未移动到View之外)   小于500ms or 大于500ms,长按没有被处理&lt;br&gt;
长按事件: ACTION_DOWN -&amp;gt; ... ACTION_DOWN -&amp;gt; ACTION_MOVE...(未移动到View之外)  大于500ms&lt;/p&gt;
&lt;h4 id=&#34;viewgroup控件的touch事件处理&#34;&gt;ViewGroup控件的Touch事件处理&lt;/h4&gt;
&lt;p&gt;ViewGroup继承自View,并覆写View的dispatchTouchEvent()的方法.
我们从很多书上都说ViewGroup的touch事件处理,先派发事件处理给子View控件处理,子View事件处理后返回false就有ViewGroup处理,从源码角度分析.到底是如何实现的. &lt;br&gt;
由于代码太多,分段阅读.  &lt;br&gt;
&lt;strong&gt;分析ACTION_DOWN事件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent ev) {

            // 1. Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
				...
            }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;触发了Touch的ACTION_DOWN时,会触发,清除原来状态.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // 2. Check for interception.
	final boolean intercepted;
	if (actionMasked == MotionEvent.ACTION_DOWN
			|| mFirstTouchTarget != null) {
			final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
			if (!disallowIntercept) {
				intercepted = onInterceptTouchEvent(ev);
				ev.setAction(action);
			} else {
				intercepted = false;
			}
	} else {
			intercepted = true;
	}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检测是否要拦截touch事件, 检测是否是ACTION_DOWN,是否mFirstTouchTarget(其实这个是处理事件的)为null,二者都不满足的话,会继续拦截事件.有其中一个满足就检测FLAG_DISALLOW_INTERCEPT,此flag设置,就说明,不允许ViewGroup拦截事件,没设置最后会调用onInterceptTouchEvent()来检测拦截.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!canceled &amp;amp;&amp;amp; !intercepted) {

                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0) {
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                continue;
                            }
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { //事件派发给子View处理
                                ...
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);  //设置mFirstTouchTarget
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                        }

                    }                 
                }
            }

            if (mFirstTouchTarget == null) {
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);   //ViewGroup自行处理                      
            } else {
				...
			}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这部分主要查找ViewGroup的子View来处理,还有并有子View来处理事件.查找是通过canViewReceivePointerEvents()(也就是通过判断可见性)和isTransformedTouchPointInView()(通过touch事件是否在View上)函数. 对于消息的处理,如果子View消耗了事件,会通过addTouchTarget()函数设置mFirstTouchTarget(后面会直接通过它来处理ACTION_UP事件), 如果没有子View处理事件, mFirstTouchTarget会为null, 那么ViewGroup自己处理.&lt;/p&gt;
&lt;p&gt;下面分析一下dispatchTransformedTouchEvent()到底如何处理事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
	if (newPointerIdBits == oldPointerIdBits) {
	            if (child == null || child.hasIdentityMatrix()) {
	                if (child == null) {
	                    handled = super.dispatchTouchEvent(event);    //ViewGroup自行处理事件,
	                } else {
	                    handled = child.dispatchTouchEvent(event);    //子View处理事件.

	                    event.offsetLocation(-offsetX, -offsetY);
	                }
	                return handled;
	            }
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果child为null,就会调用ViewGroup的dispatchTouchEvent()函数派发处理,不为null,就是子View处理事件.dispatchTransformedTouchEvent()函数上面还有一段类似的代码没有显示,处理的是cancel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析ACTION_MOVE&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public boolean dispatchTouchEvent(MotionEvent ev) {
			...
            if (mFirstTouchTarget == null) {
                handled = dispatchTransformedTouchEvent(ev, canceled, null,   //ViewGroup处理
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;amp;&amp;amp; target == newTouchTarget) {  //ACTION_DOWN已经处理,就会走这里
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {     //子View处理
                            handled = true;
                        }  
                    }
                }
            }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于ACTION_MOVE的事件拦截的检测跟ACTION_DOWN一致,这里就没有说明
在ACTION_DOWN时候,如果没有子View处理时,mFirstTouchTarget会为null,对于ACTION_MOVE也就有ViewGroup处理,
在ACTION_DOWN时候,如果有子View处理时,mFirstTouchTarget不会为null,如果没有拦截,对于ACTION_MOVE也就有子View处理,
对于ACTION_UP的分析跟ACTION_MOVE一致.&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E8%BF%9B%E9%98%B6/">Android进阶</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/">Android事件传递机制</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>事务</title>
                <link>https://example.com/posts/database/2016-05-07-%E4%BA%8B%E5%8A%A1/</link>
                <guid isPermaLink="true">https://example.com/posts/database/2016-05-07-%E4%BA%8B%E5%8A%A1/</guid>
                <pubDate>Sat, 07 May 2016 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;事务定义了一组SQL命令的边界, 这组命令作为一个整体被全部执行,或者都不执行,这被称为数据库完整性的原子性原则.事务和锁在数据库操作中密切相关,数据操作总是在事务中执行,事务又涉及到锁,如果控制不当,会导致很多问题.所以我们应该看懂自己写的代码并能指出事务的状态,或者至少能够发现潜在问题.&lt;/p&gt;
&lt;h2 id=&#34;事务的范围&#34;&gt;事务的范围&lt;/h2&gt;
&lt;p&gt;事务由3个命令控制:begin, commit和rollback, begin开始一个事务, begin之后的所有操作都可以被取消. commit提交事务开始后的所有执行的操作, rollback 还原begin之后的所有操作.
默认情况下, SQLite中每条语句自成事务. 也就是SQLite默认每条单独的SQLu\语句就是begin ... commit/rollback的事务.这种情况下, 所有成功完成的命令自动提交.同样遇到错误命令都会回滚.&lt;/p&gt;
&lt;h2 id=&#34;事务生命周期&#34;&gt;事务生命周期&lt;/h2&gt;
&lt;p&gt;代码和事务需要考虑一些问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务在哪些对象上运行&lt;/li&gt;
&lt;li&gt;事务的持续事件&lt;/li&gt;
&lt;li&gt;事务与锁的关联&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务在哪些对象上运行&#34;&gt;事务在哪些对象上运行&lt;/h3&gt;
&lt;p&gt;一个连接对象代表到数据库的连接和事务上下文,statement来自连接对象.一个statement代表了一个编译的SQL语句.每个连接都有一个B-tree和与之关联的pager,连接处理相关操作,实际是pager代劳处理.数据库写操作时,是在用一个连接,一次一个事务.因此所有的对象都是运行在派生它们自身的连接的单个事务上下中.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/w-fei/wangfei1991.github.com_raw_important/master/SQLite%20C%20API%20object%20model.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;事务的持续时间&#34;&gt;事务的持续时间&lt;/h3&gt;
&lt;p&gt;事务持续的时间与单个语句一样短暂, 或者可以很长.默认情况下,连接运行在自动提交模式下,这意味着发出的每个命令都运行一个单独的事务.事务当持续到调用COMMIT或者rollback,或者SQL命令引起约束违反进而导致rollback.&lt;/p&gt;
&lt;h3 id=&#34;事务与锁的关联&#34;&gt;事务与锁的关联&lt;/h3&gt;
&lt;p&gt;大多数情况下,锁持续时间隐藏在事务的持续时间内,二者不总是一起开始,但总是一起结束,释放于其相关的锁.SQLite有5中不同的锁状态,连接总是处于其中之一.
白色的锁状态-未锁定,待定,共享和保留,全都可以在同一时间同一数据库的不同连接中存在.不过从灰色的待定锁开始,限制就多了,灰色的待定状态代表锁正在被某个连接锁拥有,即某个想要获取独占锁的写操作.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/w-fei/wangfei1991.github.com_raw_important/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;读事务&#34;&gt;读事务&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;begin;
select * from episodes;
select * from episodes;
commit;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里锁的状态 UNLOKED -&amp;gt; PENDING -&amp;gt; SHARED -&amp;gt; UNLOCKED.&lt;/p&gt;
&lt;p&gt;如果去除begin,commit,两条select命令运行在自动提交模式下, 因此他们经历路径是UNLOKED -&amp;gt; PENDING -&amp;gt; SHARED -&amp;gt; UNLOCKED-&amp;gt; PENDING -&amp;gt; SHARED -&amp;gt; UNLOCKED.&lt;/p&gt;
&lt;h4 id=&#34;写事务&#34;&gt;写事务&lt;/h4&gt;
&lt;p&gt;单个命令的锁状态路径
UNLOKED -&amp;gt; PENDING -&amp;gt; SHARED -&amp;gt;RESERVED -&amp;gt; PENDING -&amp;gt; EXCULSIVE -&amp;gt; UNLOCKED&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RESERVED 状态
连接尝试着向数据库写入内容时,必须从共享锁转换到预留锁.如果获得了预留锁,则准备好开始对数据修改.连接在此时修改数据库,它也可以修改内容存储在本地pager内的内存缓存中.因为页面缓存,写操作连接可以在预留锁完成实际工作,而不干扰其他读操作,有效的地让多个读操作和写操作同一时间在同一数据库中工作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PENDING 状态
当连接完成了写操作,并提交事务时,pager开始进入独占状态的过程.一旦获取了待定锁,并继续持有该锁,其他连接无法从未待定转换到共享状态,结果是没有可以进入数据库的新连接.当其他连接释放了该锁,数据库就进入写操作, pager从待定状态转换到独占状态.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EXCLUSIVE
独占状态主要工作是将修改的页从页面缓存刷新到数据库文件.pager将所有已修改的页复制到数据库文件.事务提交,从排他锁回到未锁定状态.如果该事务未提交,pager继续持有独占锁,直到发出COMMIT或者ROLLBACK状态.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;锁的实现&#34;&gt;锁的实现&lt;/h3&gt;
&lt;p&gt;SQLite的锁是基于标准的文件锁定来实现的.SQLite在数据库文件中有三种不同的文件锁: 保留锁, 待定锁和一个共享区域.
一切从待定字节开始.若要从未锁定移动到共享,连接首先尝试在待定字节上获取读锁.如果成功,在共享区域的任意字节上获取读锁,并释放待定字节商的读锁.若要从共享状态移动到保留状态,连接尝试获取对保留字节上的写入锁,若要从保留状态转换到独享状态,连接尝试获取待定字节上的写入锁.因为其他连接不能从待定锁中获取读锁,从而进入独享状态.最后,想要获取排它锁,连接尝试从共享区域获取写入锁.由于共享区域有其他连接的读取锁,此步骤保证了只有其他共享锁释放后,才能属于排它锁.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/w-fei/wangfei1991.github.com_raw_important/master/%E9%94%81%E5%AE%9E%E7%8E%B0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>ContentProvider</title>
                <link>https://example.com/posts/android_base/content-provider/2014-11-08-contentprovider/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/content-provider/2014-11-08-contentprovider/</guid>
                <pubDate>Wed, 20 Apr 2016 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;什么是android中的content-provider&#34;&gt;&lt;strong&gt;什么是Android中的Content Provider&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Content Provider是用于管理访问结构化数据集的一种组件，最经常管理数据集是数据库。content provider会封装数据，提供数据安全的机制。content provider用于一个进程与另一个运行中的进程的数据连接。  &lt;br&gt;
&lt;strong&gt;Notice:&lt;/strong&gt;&lt;br&gt;
当不打算共享数据给其他应用时，不需要定义自己的Content Provider.&lt;/p&gt;
&lt;h4 id=&#34;content-provider如何表示数据的呢&#34;&gt;&lt;strong&gt;Content Provider如何表示数据的呢？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Content Provider呈现数据是通过一个或多个表，类似与数据库，使用Content Provider跟使用数据库相类似。&lt;/p&gt;
&lt;h4 id=&#34;如何访问content-povider&#34;&gt;&lt;strong&gt;如何访问Content Povider?&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Content Provider的访问很简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义Uri&lt;/li&gt;
&lt;li&gt;获取ContentResolver对象&lt;/li&gt;
&lt;li&gt;使用ContentResolver对象进行相关的操作。&lt;/li&gt;
&lt;li&gt;配置访问时要求的权限&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何定义uri以及uri到底是做什么用的&#34;&gt;&lt;strong&gt;如何定义Uri，以及Uri到底是做什么用的？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Uri是URI的引用，URI是Uniform Resource Identifier(统一资源标识符)简称，用于标识某一资源名称的,
组成形式：协议://authority／path。&lt;br&gt;
ContentResolver使用的Uri是用于标识内容提供者的数据，组成形式：content://authority/path如果使用Content Provider共享的数据是数据库，那么path就是操作的table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*填入要操作的数据的内容提供者的字符串*/
Uri uri = Uri.parse(&amp;quot; &amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;contentresolver能够进行哪些相关的操作&#34;&gt;&lt;strong&gt;ContentResolver能够进行哪些相关的操作&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;可能（这里使用可能是因为要看Content Provider具体实现，也许访问的Content Provider只支持其中部分操作）支持的操作如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;li&gt;query&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何insert插入数据&#34;&gt;&lt;strong&gt;如何insert插入数据？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;可以像这样：&lt;/p&gt;
&lt;p&gt;{% highlight ruby %}
/&lt;em&gt;1. 定义要操作的Uri（记得初始化）&lt;/em&gt;/
Uri mUri;
/&lt;em&gt;2. 定义ContentValues对象，用于保存要插入的数据&lt;/em&gt;/
ContentValues contentValues= new ContentValues();
contentValues.put();
contentValues.pust();
...
/&lt;em&gt;3 获取ContentResolver对象&lt;/em&gt;/
ContentResolver resolver = getContentResolver();
/&lt;em&gt;4 插入数据&lt;/em&gt;/
resolver.insert(mUri,contentValues);
{% endhighlight %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;####&lt;strong&gt;如何delete数据？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;{% highlight ruby linenos %}
/&lt;em&gt;1. 定义要操作的Uri（记得初始化）&lt;/em&gt;/
Uri mUri;
/&lt;em&gt;2. 定义ContentValues对象，用于保存要插入的数据&lt;/em&gt;/
...
/&lt;em&gt;3 获取ContentResolver对象&lt;/em&gt;/
ContentResolver resolver = getContentResolver();
/&lt;em&gt;4 插入数据&lt;/em&gt;/
resolver.delete(mUri, where, selectionArgs);
{% endhighlight %}&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://example.com/posts/android_base/server/2014-10-31-services/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/server/2014-10-31-services/</guid>
                <pubDate>Sun, 10 Apr 2016 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;
&lt;h4 id=&#34;什么是android中的serice&#34;&gt;什么是Android中的Serice？&lt;/h4&gt;
&lt;p&gt;Service是一个长期运行在后台不提供用户界面的组件。&lt;/p&gt;
&lt;h4 id=&#34;service听起来像是一个线程它们有什么区别&#34;&gt;Service听起来像是一个线程，它们有什么区别？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程独立主线程（UI线程）之外，而Service可以运行在主线程（默认情况下)中，也可以不在其中。&lt;/li&gt;
&lt;li&gt;线程一旦被启动，只有满足相应的条件才能停止，而Service开启，可以通过stopService()或者unbindService()来停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;service如何启动呢&#34;&gt;Service如何启动呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;started ： 在组件(例如activity)中调用startService()，一旦启动将会长时间运行在后台，通常started的服务用于执行单个操作并且不需要返回结果给开启者。例如下载，当完成下载，应该调用stopSelf()方法&amp;quot;自杀&amp;quot;。&lt;/li&gt;
&lt;li&gt;bound : 在组件中调用bindService()方法，bound的服务允许组件发送请求，获取结果，甚至可以进行进程间通信（IPC）,当service没有被绑定时，service对象将会被销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; service默认运行在主进程的主线程中，这就意味着如果service要处理耗时操作或者阻塞操作(例如Map3播放，联网，蓝牙连接），应该在服务中开启工作线程来做这些工作，通过这种方式可以减少应用无响应(Application Not Responding ANR)的发生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;started-service&#34;&gt;Started Service&lt;/h3&gt;
&lt;h4 id=&#34;如何定义started-service呢&#34;&gt;如何定义Started Service呢？&lt;/h4&gt;
&lt;p&gt;继承Service或者IntentService&lt;br&gt;
在manifest文件中配置Service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;manifest ... &amp;gt;
    ...
    &amp;lt;application ... &amp;gt;
    &amp;lt;service android:name=&amp;quot;....&amp;quot; /&amp;gt;
    ...
    &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more---&gt;
&lt;h4 id=&#34;service和intentservice怎么选择使用哪一个呢&#34;&gt;Service和IntentService怎么选择使用哪一个呢？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对于单个操作可以使用IntentService，IntentService开启一个工作线程，&lt;br&gt;
当onHandlentent()函数执行完毕，service就会自杀，部分源码是这样的&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;	private final class ServiceHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            onHandleIntent((Intent)msg.obj);  //处理完操作就会自杀，
            stopSelf(msg.arg1);
        }
    }  
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;较复杂逻辑的要继承Service来完成了。&lt;/li&gt;
&lt;li&gt;IntentService使用比较简单只需实现onHandlentent()方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;继承service应该覆写哪些方法呢&#34;&gt;继承Service应该覆写哪些方法呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/master/img/android/android_knowledge/startedServiceflow.png&#34; alt=&#34;activity开启service执行过程&#34;&gt;&lt;br&gt;
所以要覆写三个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public class HelloService extends Service {

  @Override
  public void onCreate() {
    /*在创建Service时执行，如果开启的服务已经再运行，不会调用这个方法*/
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
/**
       *1. 在组件(例如Activity)调用了startService()就会执行此方法，一旦此方法  
	   *   执行，service就会运行在后台，如果你想停止服务需要在组件中  
	   *   调用stopService()，或者在service中调用stopSelf()  
	   *2. 对于返回值必须是下面常量的其中一个：
	   *   START_NOT_STICKY : 当系统杀死该服务,将不会重建这个service的对象。  
	   *   START_NOT_STICKY : 当系统杀死该服务，将会重新创建service，并且调  
	   *                      用onStartCommand()方法，但不会重新提交最后  
	   *                      一次intent,也就是系统调用onStartCommand()  
	   *                      但传入intent为null  
	   *   START_REDELIVER_INTENT: 系统杀死service后，重新创建service并且  
	   *                           调用onStartCommand()并把最后的请求的  
	   *                           intent传入  
	   */
      return START_STICKY;
  }

  /*********************用于绑定服务这里可以返回null****************/
  @Override
  public IBinder onBind(Intent intent) {
      // We don&#39;t provide binding, so return null
      return null;
  }

  @Override
  public void onDestroy() {
/*
        *当服务不再被使用时会调用此方法，在此方法中，应该放弃资源比如线程的  
        *注册的监听，等等。  
        */
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;在组件中如何启动started-service呢&#34;&gt;在组件中如何启动started service呢？&lt;/h4&gt;
&lt;p&gt;使用startService(Intent),并且intent定义方法与开启activity的intent一样有两种方式显式（类名）与隐式（action）。&lt;/p&gt;
&lt;h4 id=&#34;如何停止started-service&#34;&gt;如何停止started service?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;stopService()： 组件来停止服务，一般用于防止耗电，避免浪费系统资源 时使用。&lt;/li&gt;
&lt;li&gt;stopSelf()： 一般用于在onStartCommand()执行一个请求，当执行完相应操作就使用stopSelf()自杀。&lt;/li&gt;
&lt;li&gt;stopSelf(int)： 当在onStartCommand()中执行多个请求时，建议使用此方法，因为这样可以避免当新的请求到来后，关闭了service的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考文档&#34;&gt;参考文档&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://developer.android.com/guide/components/services.html&#34;&gt;参考文档1&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Bound Services</title>
                <link>https://example.com/posts/android_base/server/2014-11-01-boundservices/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/server/2014-11-01-boundservices/</guid>
                <pubDate>Sat, 20 Jun 2015 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;
&lt;h4 id=&#34;如何绑定service&#34;&gt;如何绑定service?&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;创建一个bound service&lt;/li&gt;
&lt;li&gt;在组件中调用bindService()方法进行绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何创建一个bound-service呢&#34;&gt;如何创建一个bound Service呢？&lt;/h4&gt;
&lt;p&gt;继承Service，用于绑定的类，首先，必须提供一个IBinder用于与客户端(例如Activity)&lt;br&gt;
交互,有三种方式可以提供此IBinder,每一种方式又有不同的实现方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承Binder(实现了IBinder)类&lt;/li&gt;
&lt;li&gt;使用Messenger&lt;/li&gt;
&lt;li&gt;使用AIDL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其次是在onBind()中返回IBinder&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**Notice:**多个clients连接到service时，只在第一次绑定时调用onBind()方法获取&lt;br&gt;
IBinder对象，对于其他的clients，系统直接传递一个IBinder，不会再调&lt;br&gt;
用onBind()方法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;创建bound-service三种方式可以提供此ibinder如何选择呢&#34;&gt;创建bound service三种方式可以提供此IBinder,如何选择呢？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;继承Binder： 在servie只能在本应用中使用，并且不涉及多进程时使用（也就是与 客户端处于相同的进程中）&lt;/li&gt;
&lt;li&gt;使用Messenger：当想要IBinder工作于不同的进程中，并且不在意请求的同时执行，使用 此方法.这是最简单方式对于IPC，因为Messenger队列请求都是单线程的                       无需考虑线程安全问题。&lt;/li&gt;
&lt;li&gt;使用AIDL：首先，使用Messenger是基于AIDL，当想要同时处理多个请求时可以使用此方式，当 要自己处理多线程和线程安全问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;**Notice:**不是所有组件都能绑定service，广播就是个例外，但广播可以启动service。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;bound-service&#34;&gt;bound service&lt;/h3&gt;
&lt;h4 id=&#34;继承binder如何定义bound-service组件中如何使用&#34;&gt;继承Binder如何定义bound service，组件中如何使用？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;service定义&lt;br&gt;
1.1 在Service中Binder的对象，此对象中包含组件可以使用的共有方法，在公有方法中返回service对象，或者返回有service托管的类（类中要有public方法）。&lt;br&gt;
1.2：在onBind()方法中返回Binder对象。&lt;/li&gt;
&lt;li&gt;组件中绑定service&lt;br&gt;
2.1组件中onServiceConnected（）方法中获取IBinder并操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	/******继承Binder方式bound service定义的模板******/

	public class LocalService extends Service {
    //返回到给客户端(例如Activity)
    private final IBinder mBinder = new LocalBinder();
    /*
     * 继承Binder
     */
    public class LocalBinder extends Binder {
        LocalService getService() {
            //返回service对象客户端能调用service的public方法。
            return LocalService.this;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    /*客户端（例如activity）中能够调用此方法*/
    public int getTest {
      return 12;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;	public class BindingActivity extends Activity {
	//保存获取service的对象
    LocalService mService;
	//用于标志是否service绑定了
    boolean mBound = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }

    @Override
    protected void onStart() {
        super.onStart();
        // 绑定service
        Intent intent = new Intent(this, LocalService.class);
		//第二个参数Serviceonnection对象
        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        // 解除绑定
        if (mBound) {
            unbindService(mConnection);
            mBound = false;
        }
    }

    //button
    public void onButtonClick(View v) {
        if (mBound) {
		    int num = service.getTest();
            Toast.makeText(this, &amp;quot;number: &amp;quot; + num, Toast.LENGTH_SHORT).show();
        }
    }

    /*由于bindService是立即的返回，没有值返回，而ServiceConnection用于监听  
     *连接的当建立连接了就会调用onServiceConnected(),从而可以获取到IBinder  
     */
    private ServiceConnection mConnection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName className,
                IBinder service) {
            LocalBinder binder = (LocalBinder) service;
            mService = binder.getService();
            mBound = true;
        }

        @Override
        public void onServiceDisconnected(ComponentName arg0) {
            mBound = false;
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;使用messenger如何定义bound-service组件中如何使用&#34;&gt;使用Messenger如何定义bound service，组件中如何使用？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在Service中定义一个Handler用于处理来自client的请求，&lt;/li&gt;
&lt;li&gt;使用Handler对象作为参数来创建一个Messenger对象&lt;/li&gt;
&lt;li&gt;在onBind()方法中使用Messenger对象返回一个IBinder对象，&lt;/li&gt;
&lt;li&gt;在clients中的ServiceConnection的onServiceConnetion()中根据IBinder 对象来实例化Messenger,&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    public class MessengerService extends Service {

    static final int MSG_SAY_HELLO = 1;

    /**
     * 1. 定义一个Handler用于处理来自client的请求
     */
    class IncomingHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_SAY_HELLO:
                    Toast.makeText(getApplicationContext(), &amp;quot;hello!&amp;quot;,  
					     Toast.LENGTH_SHORT).show();
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }

    /**
     * 2. 使用Handler对象作为参数来创建一个Messenger对象  
     */
    final Messenger mMessenger = new Messenger(new IncomingHandler());

    /**
     * 3. 在onBind()方法中使用Messenger对象返回一个IBinder对象，
     */
    @Override
    public IBinder onBind(Intent intent) {
        return mMessenger.getBinder();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;public class ActivityMessenger extends Activity {
    Messenger mService = null;

    /**用于判断是否已连接*/
    boolean mBound;

    /**
     * Class for interacting with the main interface of the service.
     */
    private ServiceConnection mConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className,   
		       IBinder service) {
           //4 根据IBinder对象来实例化Messenger,  
            mService = new Messenger(service);
            mBound = true;
        }

        public void onServiceDisconnected(ComponentName className) {
            // This is called when the connection with the service has been
            // unexpectedly disconnected
            mService = null;
            mBound = false;
        }
    };

	//Button
    public void sayHello(View v) {
        if (!mBound) return;
        Message msg = Message.obtain(null,  
		              MessengerService.MSG_SAY_HELLO, 0, 0);
        try {
            mService.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }

    @Override
    protected void onStart() {
        super.onStart();
        // Bind to the service
        bindService(new Intent(this, MessengerService.class),   
		                mConnection, Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        // Unbind from the service
        if (mBound) {
            unbindService(mConnection);
            mBound = false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;**Notice：**这里没有演示service对client的回应，一个很好的例子时APIDemo中MessengerService.java和MesengerServiceActivity的例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;上面对于clients绑定service很模糊究竟怎么连接&#34;&gt;上面对于clients绑定service很模糊，究竟怎么连接？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;实现ServiceConnection&lt;br&gt;
1.1  onServiceConnected() client-service建立连接就会调用此函数， 传递onBind()中创建的IBinder。&lt;br&gt;
1.2  onServiceDisconnected() client-service之间的连接断开时会调用这个函数。&lt;/li&gt;
&lt;li&gt;调用bindService时传递一个ServiceConnection实现。&lt;/li&gt;
&lt;li&gt;当解除绑定时调用unbindService方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Intent intent = new Intent(this, LocalService.class);  
//BIND_AUTO_CREATE:如果Service没有在运行，就自动创建。
bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Skill:&lt;/strong&gt;  * Activity与service交互是在Activity可视时应该bindService() 在onCreate（）,unbindService()在onStop()中 ,Activity在后台也能接受service的回应，那可以在onCreate()中调用bindService，在onDestory()中调用unbindService().&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; 不应该绑定在onResume()，在onPause()解除定，在多个Activity来回切换的话可能导致service不断的销毁，然后在重建，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;service生命周期&#34;&gt;service生命周期&lt;/h3&gt;
&lt;h4 id=&#34;started-service&#34;&gt;started service&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/startedServiceflow.png&#34; alt=&#34;started service声明周期&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;bound-service-1&#34;&gt;bound service&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/bindserverflow.png&#34; alt=&#34;bound service生命周期&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;开启服务与绑定了服务共存&#34;&gt;开启服务与绑定了服务共存&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/service_binding_tree_lifecycle.png&#34;&gt;查看图片&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**Notice:**在开启service和绑定service都存在时，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;先解除所有绑定，会调用onUnbind(),但不会调用onDestroy（）方法，当调用stopService（）或者stopSelf()时才会调用onDestroy()，&lt;/li&gt;
&lt;li&gt;先调用stopService（）或者stopSelf()时，由于service没有解除绑定, 此时不会调用onDestroy(),当所有绑定都解除，才会调用onDestroy（）。&lt;/li&gt;
&lt;li&gt;也就说只要servie使用中，就不会调用onDestroy().&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;参考文档&#34;&gt;参考文档&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://developer.android.com/guide/components/bound-services.html&#34;&gt;参考文档1&lt;/a&gt;&lt;/p&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Brodcast</title>
                <link>https://example.com/posts/android_base/broadcast/2014-11-03-brodcast/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/broadcast/2014-11-03-brodcast/</guid>
                <pubDate>Wed, 10 Jun 2015 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;基础&#34;&gt;基础&lt;/h3&gt;
&lt;h4 id=&#34;什么是android中的广播&#34;&gt;什么是android中的广播?&lt;/h4&gt;
&lt;p&gt;广播就是在Android系统中发生某件事情（电量，电话的来电与去电等等），然后会向android系统中发送消息的组件&lt;/p&gt;
&lt;h4 id=&#34;android系统中发生某件事情怎么向android系统中发送消息呢&#34;&gt;Android系统中发生某件事情，怎么向android系统中发送消息呢？&lt;/h4&gt;
&lt;p&gt;有两种方式，一个通过发送正常的广播，sendBroadcast(),或者发送有序广播，sendOrderedBroadcast()。&lt;/p&gt;
&lt;h4 id=&#34;发送正常的广播也可称为无序广播和发送有序广播有什么区别呢&#34;&gt;发送正常的广播（也可称为无序广播）和发送有序广播有什么区别呢？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;正常广播(也可称为无序广播)：所有接受者都可同时接受到广播，更加的高效，但是接受者不能取消广播。&lt;/li&gt;
&lt;li&gt;有序广播:一次只能传递给一个接受者（根据android:priority，）上一级接收者可以传送数据给下一级，并且可以中止广播 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;** Notice: 有序广播的接受是根据&lt;intent-filter&gt;属性中priority来判断优先级的，对于优先级越高，越较早接收到广播，相同的优先级，会根据AndroidManfiest.xml中的顺序调用。**&lt;/p&gt;
&lt;h4 id=&#34;如何使用广播呢&#34;&gt;如何使用广播呢?&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;定义广播接收器,继承自BroadcastReceiver或其子类，覆写onReceive()方法。&lt;/li&gt;
&lt;li&gt;注册定义的广播接收器。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;如何注册定义的广播接收者呢&#34;&gt;如何注册定义的广播接收者呢？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用代码注册&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//监听的广播的动作
IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_ON);
//注册广播接收者
registerReceiver(new ScreenonReceiver(), filter);
// 在AndroidManifest.xml中配置   
&amp;lt;receiver android:name=&amp;quot;com.broadcast.ScreenonReceiver&amp;quot;  
    android:enabled=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;intent-filter &amp;gt;
        &amp;lt;action android:name=&amp;quot;android.intent.action.SCREEN_ON&amp;quot;/&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; 使用在AndroidManifest.xml中配置的方式，必须指定android:enabled=&amp;quot;true&amp;quot;否则可能导致接收不到广播。&lt;br&gt;
&lt;strong&gt;Skill:&lt;/strong&gt; 最好不要使用AndroidManifest.xml中配置，一般的使用场景是开启service在Service中注册广播接收者，因为这样可以方便的取消注册，可控性比较好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;常用广播的接受&#34;&gt;常用广播的接受&lt;/h3&gt;
&lt;h4 id=&#34;开机启动的广播接收&#34;&gt;开机启动的广播接收&lt;/h4&gt;
&lt;p&gt;** Intent.ACTION_BOOT_COMPLETED ** 监听此动作的权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	RECEIVE_BOOT_COMPLETED  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;屏幕唤醒的广播接收&#34;&gt;屏幕唤醒的广播接收&lt;/h4&gt;
&lt;p&gt;监听的广播的动作为:Intent.ACTION_SCREEN_ON&lt;/p&gt;
&lt;h4 id=&#34;屏幕关闭的广播接收&#34;&gt;屏幕关闭的广播接收&lt;/h4&gt;
&lt;p&gt;监听的广播的动作为:Intent.ACTION_SCREEN_OFF&lt;/p&gt;
&lt;h4 id=&#34;来电广播的接收&#34;&gt;来电广播的接收&lt;/h4&gt;
&lt;p&gt;监听的广播的动作为:
&lt;code&gt;android.intent.action.PHONE_STATE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;监听此动作时要加权限，READ_PHONE_STATE&lt;/p&gt;
&lt;h4 id=&#34;去电广播的接收&#34;&gt;去电广播的接收&lt;/h4&gt;
&lt;p&gt;监听的广播的动作为:
&lt;code&gt;Intent.ACTION_NEW_OUTGOING_CALL&lt;/code&gt;
所要求的权限READ_PHONE_STATE，PROCESS_OUTGOING_CALLS&lt;/p&gt;
&lt;h4 id=&#34;短信到来的广播接收&#34;&gt;短信到来的广播接收&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;android.provider.Telephony.SMS_RECEIVED&lt;/code&gt;
所需要的权限RECEIVE_SMS&lt;/p&gt;
&lt;h3 id=&#34;发送广播&#34;&gt;发送广播&lt;/h3&gt;
&lt;h4 id=&#34;发送无序广播&#34;&gt;发送无序广播&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	//action:自定义的动作，
    Intent intent = new Intent(action);
    sendBroadcast(intent);  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果想加权限使用
** sendBroadcast(intent，receiverPermission); **&lt;/p&gt;
&lt;h4 id=&#34;发送有序广播&#34;&gt;发送有序广播&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;	//action:自定义的动作，
    Intent intent = new Intent(action);
    sendOrderedBroadcast(intent, receiverPermission);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Skill:&lt;/strong&gt; 对于只在本应用使用的广播建议使用LocalBroadcastManager进行发送广播，接受广播，好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更加高效，&lt;/li&gt;
&lt;li&gt;不必担心其他应用能够接收到广播，防止了广播中携带的数据被窃取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Fragment Usage</title>
                <link>https://example.com/posts/android_base/activity/2014-11-25-fragment/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/activity/2014-11-25-fragment/</guid>
                <pubDate>Sat, 30 May 2015 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;使用fragment实现代码与布局的复用&#34;&gt;使用Fragment实现代码与布局的复用&lt;/h3&gt;
&lt;p&gt;源码是 &lt;strong&gt;&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample&#34;&gt;Androidbase / Fragment / FragmentExample /&lt;/a&gt;&lt;/strong&gt; 中的&lt;strong&gt;DynamicFragment&lt;/strong&gt;相关的代码。&lt;/p&gt;
&lt;p&gt;实现的效果：在手机中处理title与content显示在不同的界面,在平板中左边显示title,右边显示content。&lt;br&gt;
&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/fragments.png&#34;&gt;查看效果图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现的思路： 在手机中加载的布局和平板加载的布局肯定不同，要分别定义不同的布局。在手机中点击title，跳转到另一界面显示content，可以使用两个fragment分别让activity关联。在平板中不涉及界面的跳转，可以在布局文件中使用**&amp;lt;fragment&amp;gt;**标签来定义。&lt;/p&gt;
&lt;p&gt;实现的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义不同的布局，在本例中定义了两个布局文件activity_dynamic_fragment,一个是在layout中定义（用于手机使用）,一个是layout-large中定义(用于平板)。&lt;/li&gt;
&lt;li&gt;定义title的fragment和content的fragment&lt;/li&gt;
&lt;li&gt;在Activity的onCreate()方法中content相关的view是否存在，不存在就是手机设备要把title的fragment加到activity中。&lt;/li&gt;
&lt;li&gt;title点击处理使用了回调的方式，手机的处理方式是添加content的fragment,而平板的处理方式是获取content的fragment来更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;使用fragment实现滑动的效果&#34;&gt;使用Fragment实现滑动的效果&lt;/h3&gt;
&lt;p&gt;源码是在**&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample&#34;&gt;Androidbase / Fragment / FragmentExample /&lt;/a&gt;**中的**ViewpagerFragment**相关的代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单实现方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个Fragment&lt;/li&gt;
&lt;li&gt;在activity布局文件使用V4支持包中的&lt;strong&gt;ViewPager&lt;/strong&gt;标签来定义viewpager控件。&lt;/li&gt;
&lt;li&gt;在activity中获取viewpager控件，并调用setAdapter()，其参数为PagerAdapter,对于使用fragment的viewpager有两个类可以继承,实现方法比较少，分别是FragmentPagerAdapter和FragmentStatePagerAdapter.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带有指示器的Viewpager&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个Fragment&lt;/li&gt;
&lt;li&gt;在activity布局文件使用V4支持包中&lt;strong&gt;ViewPager&lt;/strong&gt;标签来定义viewpager控件，并添加V4支持包中的&lt;strong&gt;PagerTabStrip&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在activity中获取viewpager控件并调用setAdapter()，参数继承FragmentPagerAdapter或者FragmentStatePagerAdapter，并覆写其getPageTitle()方法的类对象 。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTICE:&lt;/strong&gt; Viewpager默认的情况下，滑动后的pager可能会被销毁，一般少量pager时使用FragmentPagerAdapt（一般3个左右）子类  而有许多pager时会使用FragmentStatePagerAda子类pt，因为它会保存状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在fragment中嵌套Viewpager&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;fragment的布局文件中使用&lt;strong&gt;android.support.v4.view.ViewPager&lt;/strong&gt;标签来定义Viewpager控件。&lt;/li&gt;
&lt;li&gt;在fragment中获取viewpager控件，并调用setAdapter()&lt;/li&gt;
&lt;li&gt;把fragment添加到activity的一个viewgroup中&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;**NOTICE:**在fragment中viewpager设置fragment使用的FragmentManager要通过getChildFragmentManager()来获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://developer.android.com/guide/components/fragments.html&#34;&gt;参考文档1&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&lt;a href=&#34;http://developer.android.com/training/implementing-navigation/lateral.html#tabs&#34;&gt;参考文档2&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Fragment</title>
                <link>https://example.com/posts/android_base/activity/2014-11-18-fragment/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/activity/2014-11-18-fragment/</guid>
                <pubDate>Thu, 28 May 2015 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;什么是fragment&#34;&gt;什么是Fragment？&lt;/h3&gt;
&lt;p&gt;Fragment不是Activity，但是需要内嵌到Activtiy中，Fragment不是容器（viewGroup或者其子类），通常Fragment创建ViewGroup.&lt;br&gt;
Fragment代表的是一种行为或者Activity的用户界面的一部分。&lt;/p&gt;
&lt;h3 id=&#34;为什么要使用fragment呢&#34;&gt;为什么要使用Fragment呢？&lt;/h3&gt;
&lt;p&gt;Android是在3.0时引入的Fragment，为了更好的支持大屏幕设备（平板）。使用Fragment来封装UI和Java代码，提高了复用性。&lt;/p&gt;
&lt;h3 id=&#34;什么时候使用fragment呢&#34;&gt;什么时候使用Fragment呢？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;逻辑共享：不同设备和屏幕尺寸之间共享UI和逻辑，通常用于平板电脑&lt;/li&gt;
&lt;li&gt;回退导航：把fragment添加到堆栈中，当回退时，就会出栈，这种实现方式避免了activity的重建&lt;/li&gt;
&lt;li&gt;整体滑动的效果：与ViewPager一起使用实现整体滑动的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;怎么使用fragment呢&#34;&gt;怎么使用Fragment呢？&lt;/h3&gt;
&lt;p&gt;可以查看 &lt;strong&gt;&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample&#34;&gt;Androidbase / Fragment / FragmentExample /&lt;/a&gt;&lt;strong&gt;下的&lt;/strong&gt;FirstFragment&lt;/strong&gt;相关的代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在activity的布局文件中声明
这种方式就好像fragment是一个View一样，但这种方式缺乏灵活性，不能动态的更改fragment，较少使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;
    &amp;lt;fragment android:name=&amp;quot;com.example.news.ArticleListFragment&amp;quot;
            android:id=&amp;quot;@+id/list&amp;quot;
            android:layout_weight=&amp;quot;1&amp;quot;
            android:layout_width=&amp;quot;0dp&amp;quot;
            android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;
    &amp;lt;fragment android:name=&amp;quot;com.example.news.ArticleReaderFragment&amp;quot;
            android:id=&amp;quot;@+id/viewer&amp;quot;
            android:layout_weight=&amp;quot;2&amp;quot;
            android:layout_width=&amp;quot;0dp&amp;quot;
            android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;The &lt;em&gt;&lt;strong&gt;android:name&lt;/strong&gt;&lt;/em&gt; attribute in the &lt;em&gt;&lt;strong&gt;&amp;lt;fragment&amp;gt;&lt;/strong&gt;&lt;/em&gt;specifies the Fragment class to instantiate in the layout.
When the system creates this activity layout, it instantiates each fragment specified in the layout and calls the &lt;em&gt;&lt;strong&gt;onCreateView()&lt;/strong&gt;&lt;/em&gt; method for each one, to retrieve each fragment&#39;s layout. The system inserts the View returned by the fragment directly in place of the &lt;em&gt;&lt;strong&gt;&amp;lt;fragment&amp;gt;&lt;/strong&gt;&lt;/em&gt; element.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTICE:&lt;/strong&gt; Each fragment requires a unique identifier that the system can use to restore the fragment if the activity is restarted (and which you can use to capture the fragment to perform transactions, such as remove it). There are three ways to provide an ID for a fragment:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Supply the &lt;em&gt;&lt;strong&gt;android:id&lt;/strong&gt;&lt;/em&gt; attribute with a unique ID.&lt;/li&gt;
&lt;li&gt;Supply the &lt;em&gt;&lt;strong&gt;android:tag&lt;/strong&gt;&lt;/em&gt; attribute with a unique string.&lt;/li&gt;
&lt;li&gt;If you provide neither of the previous two, the system uses the ID of the container view.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通过java代码方式添加fragment到一个ViewGroup中
在Activity运行时可以动态的向Activity的布局中添加fragment，只需要指定fragment位于ViewGroup&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*1.获取FragmentManager*/
FragmentManager fragmentManager = getFragmentManager();
/*2.获取FragmentTransaction对象*/
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
/*3.创建fragment对象*/
ExampleFragment fragment = new ExampleFragment();
/*4.添加fragment*/
fragmentTransaction.add(R.id.fragment_container, fragment);
/*5.提交*/
fragmentTransaction.commit();
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;fragment的生命周期&#34;&gt;Fragment的生命周期&lt;/h3&gt;
&lt;p&gt;fragment生命周期与activity生命周期息息相关。&lt;br&gt;
代码可以查看 &lt;strong&gt;&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/Fragment/FragmentExample&#34;&gt;Androidbase / Fragment / FragmentExample /&lt;/a&gt;&lt;strong&gt;下的&lt;/strong&gt;FirstFragment&lt;/strong&gt;相关的代码进行测试&lt;br&gt;
一副图看懂看懂全部&lt;br&gt;
&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/fragment_lifecycle.png&#34;&gt;查看图片&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;参考文档&#34;&gt;参考文档&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://developer.android.com/guide/components/fragments.html#Lifecycle&#34;&gt;参考文档&lt;/a&gt;&lt;/p&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Activity</title>
                <link>https://example.com/posts/android_base/activity/2014-10-30-activity/</link>
                <guid isPermaLink="true">https://example.com/posts/android_base/activity/2014-10-30-activity/</guid>
                <pubDate>Thu, 07 May 2015 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;创建activity&#34;&gt;创建Activity&lt;/h3&gt;
&lt;h4 id=&#34;什么是android中的activity&#34;&gt;什么是Android中的Activity？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;一个activity是提供一个界面，用于与用户交互（打电话，发邮件等）的应用组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;如何创建一个activity呢&#34;&gt;如何创建一个Activity呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在layout中定义个布局文件&lt;/li&gt;
&lt;li&gt;定义一个Activity（或者已存在的Activity子类）的子类，并实现相关的方法.&lt;/li&gt;
&lt;li&gt;在AndroidManifest.xml中配置Activity&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;定义一个activity子类时要实现哪些方法呢&#34;&gt;定义一个Activity子类时，要实现哪些方法呢&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;onCreate(): 你必须实现这个方法，系统会在创建activity时，调用此方法，在这个方法中初始化的activity重要部分，尤其是调用setContentView()使用资源资源来设置activity的界面。&lt;/li&gt;
&lt;li&gt;onPause(): 当用户将要离开activity时，系统调用的第一方法就是此方法，通常保存在当前会话中的变化的信息。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wangfei1991.github.io/Blog/android%E5%9F%BA%E7%A1%80/2014/10/30/activity/#activity-7&#34;&gt;更多的activity信息请看管理生命周期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;如何在在androidmanifestxml中配置呢&#34;&gt;如何在在AndroidManifest.xml中配置呢？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;manifest ... &amp;gt;
    &amp;lt;application ... &amp;gt;
        &amp;lt;activity  android:name=&amp;quot;ExampleActivity&amp;quot;  &amp;gt;
            &amp;lt;intent-filter&amp;gt;
			....
            &amp;lt;/intent-filter&amp;gt;

         &amp;lt;/activity&amp;gt;
           ...
    &amp;lt;/application&amp;gt;
    ...
&amp;lt;/manifest &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;android:name属性唯一必须指定的，它指定到一个特定的actiivty的类名（包含包名） &lt;br&gt;
如果actiivty能被其他应用访问就要定intent filter &lt;br&gt;
如果是入口的activity，必须指定如下的intent filter&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity  android:name=&amp;quot;...&amp;quot;&amp;gt;
   &amp;lt;intent-filter&amp;gt;
       &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;
       &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;
   &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;启动activity&#34;&gt;启动Activity&lt;/h3&gt;
&lt;h4 id=&#34;启动activiy的方法有哪些&#34;&gt;启动Activiy的方法有哪些？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;startActivity()&lt;/li&gt;
&lt;li&gt;startActivityForResult()&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;启动activity的方法有哪些异同&#34;&gt;启动Activity的方法有哪些异同？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;相同点：均需要Intent对象作为参数，均可通过Intent传递少量数据。&lt;/li&gt;
&lt;li&gt;不同点：如果想从启动的activity获取数据，使用startActivityForResult().&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;启动activity的intent如何定义&#34;&gt;启动Activity的Intent如何定义？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;显式启动，只能启动本应用的Activity&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;Intent intent = new Intent(this, SignInActivity.class);
startActivity(intent);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;gt; * 隐式启动，只要知道Activity的\&amp;lt;action\&amp;gt;就可以启动Ativity  
&amp;gt; ```
Intent intent = new Intent(Intent.ACTION_SEND);  
intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);  
startActivity(intent);  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;关闭activity&#34;&gt;关闭Activity&lt;/h3&gt;
&lt;h4 id=&#34;怎么关闭一个activity呢&#34;&gt;怎么关闭一个Activity呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;关闭自身可以调用finish()&lt;/li&gt;
&lt;li&gt;关闭由startActivityForResult()启动的Activity可以使用finishActivity()&lt;br&gt;
&lt;strong&gt;Notice：&lt;/strong&gt;&lt;br&gt;
尽量不要显式的结束Activity，因为这样会破坏Activity的生命周期，降低用户体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;activity的生命周期&#34;&gt;Activity的生命周期&lt;/h3&gt;
&lt;h4 id=&#34;什么是activity的生命周期&#34;&gt;什么是Activity的生命周期？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Activity的创建，运行，销毁等所经历的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;activity的生命周期怎样的形式表现的&#34;&gt;Activity的生命周期怎样的形式表现的？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;系统调用Activity的回调函数来表现的，共有六个主要的回调函数和其他的辅助函数&lt;br&gt;
onCreate() onStart() onResume() onPause() onStop() onDestory()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;activity的六大回调函数都有什么作用呢&#34;&gt;Activity的六大回调函数都有什么作用呢？&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;   public class ExampleActivity extends Activity {

   @Override
   /**********第一次创建Activity调用此方法***************/
   public void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       /*
        * 1. 创建视图(基本使用setContentView()方法来加载视图)
        * 2. Bundle对象中保存了Activity的以前状态，进行一些必要的复原。
        * 3. 相关数据获取，比如数据库数据的获取。
        */
   }

   @Override
   /***************在Activity可视之前调用***************/
   protected void onStart() {
       super.onStart();
       /*
        *1. Followed by onResume() Activtiy将会可见（正常）
        *2. Followed by onStop() Activity将会隐藏（不正常）
        */
   }

   @Override
   /************在Activity可以交互之前执行**************/
   protected void onResume() {
       super.onResume();
       /*
        *在此刻activity已位于回退栈的top  
        *此方法执行完之后，Activity就会处于运行状态。  
        */
   }

   @Override
   /*********当前Activity失去了焦点，但仍可见***********/
   protected void onPause() {
       super.onPause();
       /*
        *1. 保存数据，停止动画，或者其他消耗CPU的操作等等。
        *2. 这个方法不要执行耗时操作。
        */
   }

   @Override
   /********当Activity不再可视时，会调用此方法*********/
   protected void onStop() {
       super.onStop();
       /*
        *1. 意味着被Activity被销毁，
        *2. 或着其他的Activity运行覆盖了此方法
        */
   }

   @Override
   /*************在Activity销毁时执行***************/
   protected void onDestroy() {
       super.onDestroy();
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; 在重写Activity的回调函数时，必须先调用父类的相应的回调函数，再添加自己的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;如果activity-a启动activity-b-那回调方法是如何被调用的呢&#34;&gt;如果Activity A启动Activity B 那回调方法是如何被调用的呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A的onPause()执行&lt;/li&gt;
&lt;li&gt;B的执行顺序 onCreate(), onStart(), onResume().&lt;/li&gt;
&lt;li&gt;如果A不可见，A的onStop()方法执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;**Notice:** 当两个Activity共享的数据，最好在A的onPause()中执行，例如：A必须写                   入数据到数据库以便B可以读取时，要在A的onPause()中执行。  
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;activity生命周期都有哪些状态呢&#34;&gt;Activity生命周期都有哪些状态呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Resumed：Activity可视，并且获取焦点。&lt;/li&gt;
&lt;li&gt;Paused : 另一个Activity可视的，并获取了焦点，但paused的Activity仍然是可视。也就是说另一个Activity在paused的Activtiy之上，另一个Activity是通明的或者是没有覆盖整个屏幕。paused的Activity是存活的（activity对象仍然保存在内存，维持着所有状态，仍然附着在window上  ）&lt;/li&gt;
&lt;li&gt;Stopped : stoped的Activity不可见的，但仍然存活（activity对象仍然保存在内存，维持着所有状态，仍然附着在window）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/master/img/android/android_knowledge/activity_lifecycle.png&#34;&gt;activity生命周期图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;保存activity的状态&#34;&gt;保存Activity的状态&lt;/h3&gt;
&lt;h4 id=&#34;为什么要保存activity的状态呢正常情况下不是挺好吗&#34;&gt;为什么要保存Activity的状态呢，正常情况下不是挺好吗？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在正常情况下paused和stopped的activity对象会保存在内存中，activity状态也会保留，当activity可见时，也能够正常恢复。但是当系统为了获取内存，销毁了activity对象，当activity要Resumed时，必须重新创建Activity对象，用户的改变的状态将不复存在，所以要保存activity的状态。可以使用onSaveInstanceState()来保存信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;那如何保存activity的状态呢&#34;&gt;那如何保存Activity的状态呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;保存临时数据（通常是UI的状态时）可以使用用onSaveInstanceState（）&lt;/li&gt;
&lt;li&gt;保存持久的数据就需要在onPause()中进行了&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;onsaveinstancestate如何保存临时数据的又是如何恢复数据的呢&#34;&gt;onSaveInstanceState()如何保存临时数据的，又是如何恢复数据的呢？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/master/img/android/android_knowledge/restore_instance.png&#34;&gt;临时数据保存与恢复图&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不能保证onSaveInstanceState()一定会被执行，例如当用户使用back button关闭         时，当系统调用了此函数，可能是在onStop()之前调用，或者onPause()之前。&lt;/li&gt;
&lt;li&gt;onSaveInstanceState()提供了默认的实现，即对于view只要提供了ID，就会保存其状         态，因此在覆写时，首先要调用父类的onSaveInstanceState().&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Skill:&lt;/strong&gt; 测试状态保存是否正确可以旋转屏幕，因为旋转屏幕默认情况会销毁Activity，     重新创建Activity。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;参考文档&#34;&gt;参考文档：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://developer.android.com/guide/components/activities.html&#34;&gt;参考文档1&lt;/a&gt;&lt;/p&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>menu和action bar</title>
                <link>https://example.com/posts/ui/2014-11-25-menuandactionbar/</link>
                <guid isPermaLink="true">https://example.com/posts/ui/2014-11-25-menuandactionbar/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;从android3.0开始传统的6-items的菜单被action bar的形式所取代，在这篇文章中，将使用action bar方式实现menu，并且使用的是支持库的方式，这样可以解决版本兼容问题。&lt;/p&gt;
&lt;h3 id=&#34;三种菜单类型&#34;&gt;三种菜单类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;options menu&lt;/li&gt;
&lt;li&gt;context menu&lt;/li&gt;
&lt;li&gt;popup menu&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何定义menu&#34;&gt;如何定义menu&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在res/menu/下使用xml中定义menu item, 代码中填充菜单&lt;/li&gt;
&lt;li&gt;直接在代码中创建menu，添加menu条目&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTICE：&lt;/strong&gt; 最好使用menu资源来定义menu items&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;It&#39;s easier to visualize the menu structure in XML.&lt;/li&gt;
&lt;li&gt;It separates the content for the menu from your application&#39;s behavioral code.&lt;/li&gt;
&lt;li&gt;It allows you to create alternative menu configurations for different platform versions, screen sizes, and other configurations by leveraging the app resources framework.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;下面就是不同类型menu的创建方式&lt;/p&gt;
&lt;h3 id=&#34;创建options-menu&#34;&gt;创建options menu&lt;/h3&gt;
&lt;p&gt;options menu既可以在activity子类中定义，又可以在fragment子类中定义，如果两个同时定义了menu，那最后的menu形式将是二者的结合。activity的menu items先出现，然后是根据fragment在activity添加的次序来添加它们的menu items。&lt;/p&gt;
&lt;p&gt;源码可以查看&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/UI/app/src/main/java/cn/edu/wyu/ui/menu_actionbar&#34;&gt;Androidbase/UI/&lt;/a&gt;下OptionsMenuUsingActionbar相关的代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承v7ActionBarActivity,在activity覆写onCreateOptionsMenu（）方法（对于Fragment不仅要覆写onCreateOptionsMenu()方法,而且要在onCreate()中调用 setHasOptionsMenu(true),否则将不能显示）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;         @Override
    public boolean onCreateOptionsMenu(Menu menu) {  
        // 使用menu资源来填充menu  
        getMenuInflater().inflate(R.menu.menu_refresh_setting_menu, menu);  
        //动态的menu item,并以action bar形式显示  
        MenuItem locationMenuItem = menu.add(0,R.id.menu_location,0,&amp;quot;Location&amp;quot;);  
        locationMenuItem.setIcon(R.drawable.ic_action_location);  
        MenuItemCompat.setShowAsAction(locationMenuItem,  
                MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);  
        return true;  
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;覆写onOptionsItemSelected()方法,响应item点击事件（Fragment也是覆写onOptionsItemSelected()方法）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        switch (id)
        {
            case R.id.menu_refresh:
                return true;
            case R.id.menu_location:
                return true;
            case R.id.menu_settings:
                return true;
        }

        return super.onOptionsItemSelected(item);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用Theme.AppCompat的主题，这里打开了action bar，有的主题把action bar关闭了，一定要注意这一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与options-menu相关的内容&#34;&gt;与options menu相关的内容&lt;/h3&gt;
&lt;p&gt;下面基本在options menu中使用，在另外两种类型中比较少使用。&lt;/p&gt;
&lt;h4 id=&#34;添加tabs&#34;&gt;添加tabs&lt;/h4&gt;
&lt;p&gt;使用场景类似于：&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/ui/menu_actionbar/actionbar-tabs-stacked@2x.png&#34;&gt;点击查看&lt;/a&gt;&lt;br&gt;
源码可以查看&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/UI/app/src/main/java/cn/edu/wyu/ui/menu_actionbar&#34;&gt;Androidbase/UI/&lt;/a&gt;的TabsAndSplitActionBar相关的代码&lt;br&gt;
使用步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现ActionBar.TabListener接口，用于处理tab的事件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    /*
     * 实现TabListener方法
     */
    @Override
    public void onTabSelected(ActionBar.Tab tab,
	                          FragmentTransaction fragmentTransaction)
    {
        //tab选择时调用这个方法
    }

    @Override
    public void onTabUnselected(ActionBar.Tab tab,
	                            FragmentTransaction fragmentTransaction)
    {
        //tab没有选择后调用的方法
    }

    @Override
    public void onTabReselected(ActionBar.Tab tab,
	                            FragmentTransaction fragmentTransaction)
    {
        //重复选择时调用的方法
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;获取action bar添加tabs，并设置ActionBar.TabListener。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    ActionBar actionBar = getSupportActionBar();
    actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
    for (int i=1; i&amp;lt;4; i++) {
        actionBar.addTab(actionBar.newTab()
                 .setText(&amp;quot;TAB &amp;quot;+i).setTabListener(this));
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;添加action-view&#34;&gt;添加Action View&lt;/h4&gt;
&lt;p&gt;使用场景类似于：&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/ui/menu_actionbar/actionbar-searchview@2x.png&#34;&gt;点击查看&lt;/a&gt;&lt;br&gt;
源码可以查看&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/UI/app/src/main/java/cn/edu/wyu/ui/menu_actionbar&#34;&gt;Androidbase/UI/&lt;/a&gt;的OptionsMenuAddActionView相关的代码&lt;br&gt;
实现的步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在menu资源文件中添加actionViewClass属性，用于声明action view&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;item android:id=&amp;quot;@+id/action_search&amp;quot;
    android:title=&amp;quot;search&amp;quot;
    android:icon=&amp;quot;@android:drawable/ic_menu_search&amp;quot;
    android:orderInCategory=&amp;quot;100&amp;quot;
    app:showAsAction=&amp;quot;ifRoom&amp;quot;
    app:actionViewClass=&amp;quot;android.support.v7.widget.SearchView&amp;quot;
    /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;在onCreateOptionsMenu()中配置action view(例如监听事件)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@Override
    public boolean onCreateOptionsMenu(Menu menu) {
         //使用menu资源来填充menu
         getMenuInflater().inflate(
		                R.menu.menu_options_add_action_view,menu);
         MenuItem menuItem = (MenuItem) menu.findItem(R.id.action_search);
         //在android11以后，可以使用menuItem.getActionView()的方式获取action iew
         SearchView searchView = (SearchView)
                                  MenuItemCompat.getActionView(menuItem);
        /*searchView事件处理*/
        return super.onCreateOptionsMenu(menu);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;添加action-provider&#34;&gt;添加Action Provider&lt;/h4&gt;
&lt;p&gt;这里以添加ShareActionProvider为例。&lt;br&gt;
使用场景类似于：&lt;a href=&#34;https://raw.githubusercontent.com/wangfei1991/Blog/gh-pages/img/android/android_knowledge/ui/menu_actionbar/actionbar-shareaction@2x.png&#34;&gt;点击查看&lt;/a&gt;&lt;br&gt;
源码可以查看&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/UI/app/src/main/java/cn/edu/wyu/ui/menu_actionbar&#34;&gt;Androidbase/UI/&lt;/a&gt;的OptionsMenuAddActionProvider相关的代码&lt;br&gt;
实现步骤:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在menu资源的&amp;lt;item&amp;gt;定义actionProvider，添加&lt;em&gt;&lt;strong&gt;ShareActionProvider&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;item android:id=&amp;quot;@+id/action_share&amp;quot;
        android:title=&amp;quot;share&amp;quot;
        android:icon=&amp;quot;@android:drawable/ic_menu_share&amp;quot;
        android:orderInCategory=&amp;quot;100&amp;quot;
        app:showAsAction=&amp;quot;ifRoom&amp;quot;        
        app:actionProviderClass=
                 &amp;quot;android.support.v7.widget.ShareActionProvider&amp;quot;
        /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;在onCreateOptionsMenu( )中获取&lt;em&gt;&lt;strong&gt;ShareActionProvider&lt;/strong&gt;&lt;/em&gt;，并调用setShareIntent()方法来设置要分享的Intent。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(
		               R.menu.menu_options_add_action_provider, menu);
        MenuItem menuItem = menu.findItem(R.id.action_share);
        ShareActionProvider actionProvider;
        /*获取ShareActionProvider*/
        actionProvider = (ShareActionProvider)
                     MenuItemCompat.getActionProvider(menuItem);
        /*来设置要分享的Inte*/
        actionProvider.setShareIntent(getDefaultInten());
        return true;
    }

    public Intent getDefaultInten()
    {
        Intent intent = new Intent(Intent.ACTION_SEND);
        intent.setType(&amp;quot;*/*&amp;quot;);
        return intent;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;添加drow-down-navigation&#34;&gt;添加Drow-down Navigation&lt;/h4&gt;
&lt;p&gt;drow-down list使用在内容重要但不频繁改变的情况，对于频繁改变的内容要使用tabs来代替。
源码可以查看&lt;a href=&#34;https://github.com/wangfei1991/Androidbase/tree/master/UI/app/src/main/java/cn/edu/wyu/ui/menu_actionbar&#34;&gt;Androidbase/UI/&lt;/a&gt;的OptionsMeneAddDropdown相关的代码&lt;br&gt;
实现步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个SpinnerAdapter提供drow-down的item，&lt;/li&gt;
&lt;li&gt;实现ActionBar.onNavigiationListener定义用户选择item的行为&lt;/li&gt;
&lt;li&gt;在Activity的onCreate()的方法中，开启此模式通过调用&lt;/li&gt;
&lt;li&gt;获取action bar，调用setListNavigationCallbacks()方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_options_mene_add_dropdown);
        ActionBar actionBar = getSupportActionBar();

		/*1. 创建一个SpinnerAdapter提供drow-down的item，*/
        spinnerAdapter = new ArrayAdapter&amp;lt;String&amp;gt;(this,
                android.R.layout.simple_spinner_dropdown_item,
                android.R.id.text1,data);

		/*3. 在Activity的onCreate()的方法中，开启此模式通过调用*/
        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);

		/*4. 获取action bar，调用setListNavigationCallbacks()方法。*/
        actionBar.setListNavigationCallbacks(spinnerAdapter,
                                             onNavigationListenerImp );
    }

    /*2. 实现ActionBar.onNavigiationListener定义用户选择item的行为*/
    private ActionBar.OnNavigationListener onNavigationListenerImp =
                              new ActionBar.OnNavigationListener() {
        @Override
        public boolean onNavigationItemSelected(int i, long l) {
             /*这里做相应的选择处理*/             
            Log.e(&amp;quot;OptionsMeneAddDropdownActivity&amp;quot;,&amp;quot;选择&amp;quot;+i+&amp;quot;位置&amp;quot;);
            return true;
        }
    };
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;参考文档&#34;&gt;参考文档：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://developer.android.com/guide/topics/ui/actionbar.html&#34;&gt;参考文档1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://developer.android.com/guide/topics/ui/menus.html&#34;&gt;参考文档2&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>menu和actionbar</title>
                <link>https://example.com/posts/ui/2014-11-26-menuandactionbar/</link>
                <guid isPermaLink="true">https://example.com/posts/ui/2014-11-26-menuandactionbar/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;context-menu的创建&#34;&gt;context menu的创建&lt;/h3&gt;
&lt;p&gt;context menu可以使用到任意view上，但通常使用在ListView，GridView的items上，或者其他用户能够执行item操作的view集合。&lt;/p&gt;
&lt;p&gt;有两种方式可以创建context menu&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;In a &lt;em&gt;&lt;strong&gt;floating context menu&lt;/strong&gt;&lt;/em&gt;. A menu appears as a floating list of menu items (similar to a dialog) when the user performs a long-click (press and hold) on a view that declares support for a context menu. Users can perform a contextual action on one item at a time.&lt;/li&gt;
&lt;li&gt;In the &lt;em&gt;&lt;strong&gt;contextual action mode&lt;/strong&gt;&lt;/em&gt;. This mode is a system implementation of ActionMode that displays a contextual action bar at the top of the screen with action items that affect the selected item(s). When this mode is active, users can perform an action on multiple items at once (if your app allows it).&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTICE:&lt;/strong&gt; &lt;em&gt;&lt;strong&gt;contextual action mode&lt;/strong&gt;&lt;/em&gt;在android3.0以后才可使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;创建floating-context-menu&#34;&gt;创建&lt;em&gt;&lt;strong&gt;floating context menu&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;注册view到context menu中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    /*1. 注册于context menu关联的iew*/
    registerForContextMenu(textview);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;实现onCreateContextMenu()方法在activity或者fragment中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   /*2.实现onCreateContextMenu()方法,当注册的view长按时,就会调用onCreateContextMenu()方法*/
    @Override
    public void onCreateContextMenu(ContextMenu menu, View v,
	                     ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu_share_items, menu);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;实现onContextItemSelected()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    /*3. 实现onContextItemSelected(),处理menu item选择的响应*/
    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterView.AdapterContextMenuInfo menuInfo =
            (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        switch (item.getItemId())
        {
            case R.id.menu_share:
                /*在这里作相应的处理*/
                return true;
            default:
                return super.onContextItemSelected(item);
        }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;创建contextual-action-mode&#34;&gt;创建&lt;em&gt;&lt;strong&gt;contextual action mode&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;对于android3.0及以上版本，应该使用&lt;em&gt;&lt;strong&gt;contextual action mode&lt;/strong&gt;&lt;/em&gt;代替&lt;em&gt;&lt;strong&gt;floating context menu&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;为view提供conteual操作，通常调用下面两种contextual操作中的一个或者两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长按View&lt;/li&gt;
&lt;li&gt;选择了一个checkbox或者类似的iew。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Tips&lt;/strong&gt;: How your application invokes the contextual action mode and defines the behavior for each action depends on your design. There are basically two designs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For contextual actions on individual, arbitrary views.&lt;/li&gt;
&lt;li&gt;For batch contextual actions on groups of items in a ListView or GridView (allowing the user to select multiple items and perform an action on them all).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;对于单个view使用Context menu&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
为了当用户选择一个特定的View，调用Contextual action mode,需要做下面的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现ActionMode.Callback接口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  private ActionMode.Callback mCallback = new ActionMode.Callback() {

        /*当action mode被创建的的时候调用*/
        @Override
        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            mode.getMenuInflater().inflate(R.menu.menu_share_items,menu);
            return true;
        }

        /*每次调用onCreateActionMode()之后调用此方法,当mode无效的时候会调用多次*/
        @Override
        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            /*这里没有相应的处理*/
            return false;
        }

        /*当选择context item时,会调用此方法*/
        @Override
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            switch (item.getItemId())
            {
                case R.id.menu_share:
                    Toast.makeText(ContextMenuActionBarModeActivity.this,
                            &amp;quot;share&amp;quot;,Toast.LENGTH_LONG).show();
                    mode.finish();
                    return true;
                default:
                    return false;
            }
        }

        @Override
        public void onDestroyActionMode(ActionMode mode) {
            mCallback = null;
        }
    };
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;显示时调用startActionMode()方法（例如长按特定view）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*长按时显示action bar*/
        textView.setOnLongClickListener(new View.OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                if (mActionMode != null) {
                    return false;
                }
                mActionMode = startActionMode(mCallback);
                textView.setSelected(true);
                return true;
            }
        });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;对于listiew和GridView使用Context menu&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
对于批量处理listiew和GridView时需要做下面操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现AbaListView.MultiChiceModeListener接口，并调用ListView或者GridView的setMultiChioceModeListener()设置。&lt;/li&gt;
&lt;li&gt;ListView或者GridView调用setChoiceMode()方法，设置参数为CHOICE_MODE_MULTIPLE_MODE.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;popup-menu的创建&#34;&gt;popup menu的创建&lt;/h3&gt;
&lt;p&gt;实现的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个PopupMenu对象&lt;/li&gt;
&lt;li&gt;使用menu资源填充menu&lt;/li&gt;
&lt;li&gt;调用PopupMenu.show().&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;styling-the-action-bar&#34;&gt;Styling the action bar&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://developer.android.com/guide/topics/ui/actionbar.html#Style&#34;&gt;style action bar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###参考文档：
&lt;a href=&#34;http://developer.android.com/guide/topics/ui/actionbar.html&#34;&gt;参考文档1&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://developer.android.com/guide/topics/ui/menus.html&#34;&gt;参考文档2&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E5%9F%BA%E7%A1%80/">Android基础</category>
                                
                            
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>异步处理一</title>
                <link>https://example.com/posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</link>
                <guid isPermaLink="true">https://example.com/posts/2015-11-27-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>wangfei199101@gmail.com (快马夜小刀)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;异步处理&#34;&gt;异步处理&lt;/h3&gt;
&lt;h4 id=&#34;handler&#34;&gt;Handler&lt;/h4&gt;
&lt;p&gt;A Handler allows you to send and process Message and Runnable objects associated with a thread&#39;s MessageQueue. Each Handler instance is associated with a single thread and that thread&#39;s message queue.&lt;/p&gt;
&lt;p&gt;从描述可以总结出Handler一些特性:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个Handler实例都会与一个线程以及线程的messageQueue关联.&lt;/li&gt;
&lt;li&gt;发送消息.&lt;/li&gt;
&lt;li&gt;处理消息,处理Runnable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Handler的处理机制示意图 &lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/wangfei1991/wangfei1991.github.com_raw_important/master/Handler%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.png&#34; alt=&#34;Handler处理机制&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出其实,Handler机制就是:Looper不断从MessageQueue中获取Message,然后Hanlder处理消息&lt;br&gt;
从上图可以看出要分析的问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;looper如何从MessageQueue中获取需要处理的message&lt;/li&gt;
&lt;li&gt;Handler如何处理消息&lt;/li&gt;
&lt;li&gt;Handler如何发送消息&lt;/li&gt;
&lt;/ol&gt;
&lt;!--  more  --&gt;
&lt;p&gt;再讲前面的问题之前还是要先了解一个问题,就是Handler实例如何与线程,线程的messageQueue关联的?&lt;/p&gt;
&lt;h5 id=&#34;handler与线程messagequeue关联&#34;&gt;Handler与线程,MessageQueue关联&lt;/h5&gt;
&lt;p&gt;下面以默认构造函数来说明.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Handler() {
        this(null, false);
    }

	public Handler(Callback callback, boolean async) {
		...
        mLooper = Looper.myLooper();  //获取looper
        if (mLooper == null) {
            throw new RuntimeException(
                &amp;quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&amp;quot;);
        }
        mQueue = mLooper.mQueue;   //从looper中获取MessageQueue
        mCallback = callback;
		...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面看能看出是looper中获取MessageQueue,并没有与什么线程关联?
其实玄机在于Looper.myLooper()中.
下面是Looper类用于说明原因.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class Looper {
	static final ThreadLocal&amp;lt;Looper&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;Looper&amp;gt;();

	private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&amp;quot;Only one Looper may be created per thread&amp;quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

	public static Looper myLooper() {
        return sThreadLocal.get();   //从sThreadLocal获取中looper,而添加是在prepare中.
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实每个Thread只能对应一个Looper,也可以不对应Looper,而每个Handler必须对应一个Looper.&lt;/p&gt;
&lt;h5 id=&#34;looper如何从messagequeue中获取需要处理的message&#34;&gt;Looper如何从MessageQueue中获取需要处理的message&lt;/h5&gt;
&lt;p&gt;对于Looper从MessageQueue是在looper类的loope()方法中,loope()函数一直从MessageQueue中获取Message,获取到了message然后调用message.target.dispatchMessage(),message.target其实就是Handler本身,message.target的设置是在发送消息时设置的.&lt;/p&gt;
&lt;h5 id=&#34;handler如何处理消息&#34;&gt;Handler如何处理消息&lt;/h5&gt;
&lt;p&gt;其实Handler机制图中已经很清楚了,就是dispatchMessage()分发消息,调用恰当的函数处理.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void dispatchMessage(Message msg) {
        if (msg.callback != null) {    //基本是通过Handler的post的相关的函数来发送的消息时调用
            handleCallback(msg);
        } else {
            if (mCallback != null) {   //通过基本的Handler的构造函数
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);       //上述的都为null,最后交有handleMessage()方法处理
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;handler如何发送消息&#34;&gt;Handler如何发送消息&lt;/h5&gt;
&lt;p&gt;通过两种方式post()相关的函数,sendMessage()相关的函数.而这两种方式最终都会调用到sendMessageAtTime()发送message.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;post()传入的是一个Runnable,然后有调用sendMessageAtTime()并把Runnable封装成message,message.callback为Runnable,有Handler消息处理机制可以知道,处理消息时优先调用message.callback,从而Runnable得以处理.&lt;/li&gt;
&lt;li&gt;sendMessage()的方法最终会调用sendMessageAtTime()方法,然后调用enqueueMessage()方法,而在enqueueMessage()方法中会设置message.target为此Handler,这样looper获取到的message可以调用message.target来处理了.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;thread&#34;&gt;Thread&lt;/h4&gt;
&lt;p&gt;Thread类对于开发者并不陌生,两种实现方式,然后调用start()方法就开启了线程.而在Android中Thread经常与Looper的结合使用.下面以Android中的HandlerThread为例:&lt;br&gt;
主要看run()方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void run() {
		...
        Looper.prepare();      //1. 做好准备工作 主要是创建looper,并创建MssageQueue,获取当前线程
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        onLooperPrepared();
        Looper.loop();  //2. 开始循环,获取MessageQueue中的message
		...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Android创建线程,如果涉及到长期处理消息,就使用HandlerThread,然后使用Handler处理消息,效果很佳,对于休眠,退出的设计都不需要自己处理.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Notices:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不需要线程时,要调用quit()相关的方法.&lt;/li&gt;
&lt;li&gt;一定要调用start()方法以后,再获取线程中的looper,不然获取的looper为null,因为创建looper是在run()方法中.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;asyncqueryhandler&#34;&gt;AsyncQueryHandler&lt;/h4&gt;
&lt;p&gt;AsyncQueryHandler主要用途是使ContentProvider查询等操作更容易.&lt;br&gt;
AsyncQueryHandler继承自Handler,并且内部还有工作线程WorkHandler,工作原理就是AsyncQueryHandler(主线程中) 发送消息到WorkHandler(工作线程中)查询,查询完成,发送消息到AsyncQueryHandler(主线程中)从而更新界面等操作. 现在从源码分析原理.&lt;br&gt;
先分析构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public AsyncQueryHandler(ContentResolver cr) {
        super();
        synchronized (AsyncQueryHandler.class) {
        //启动线程
            if (sLooper == null) {
                HandlerThread thread = new HandlerThread(&amp;quot;AsyncQueryWorker&amp;quot;);
                thread.start();

                sLooper = thread.getLooper();
            }
        }
        mWorkerThreadHandler = createHandler(sLooper);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动一个工作线程(HandlerThread上面有说过),获取looper,然后通过createHandler()创建一个Handler对象.
分析createHandler()方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected Handler createHandler(Looper looper) {
        return new WorkerHandler(looper);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只是创建了一个WorkerHandler对象,并且关联获取的looper,这样handler处理消息,就在工作线程里了.对于WorkerHandler比较简单,就不分析了. &lt;br&gt;
那startQuery(),startInsert(),如何工作的呢?&lt;br&gt;
下面已startQuery()分析为例.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void startQuery(int token, Object cookie, Uri uri,
            String[] projection, String selection, String[] selectionArgs,
            String orderBy) {
		...
        mWorkerThreadHandler.sendMessage(msg);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很简单,使用mWorkerThreadHandler发送消息.&lt;br&gt;
然后mWorkerThreadHandler关联的looper取出消息,交由mWorkerThreadHandler处理.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protected class WorkerHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            WorkerArgs args = (WorkerArgs) msg.obj;
			......
            switch (event) {
                case EVENT_ARG_QUERY:
                    Cursor cursor;
                    ......
                    cursor = resolver.query(args.uri, args.projection,
                            args.selection, args.selectionArgs,
                            args.orderBy);
					......
                    args.result = cursor;
                    break;
			}
			Message reply = args.handler.obtainMessage(token);
            reply.obj = args;
            reply.arg1 = msg.arg1;
            reply.sendToTarget();
		}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询数据库,组织数据,从AsyncQueueHandler中获取message,函数中设置了message.target,然后通过sendToTarget()发送消息.这样就轮到AsyncQueueHandler处理消息了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public void handleMessage(Message msg) {
        switch (event) {
            case EVENT_ARG_QUERY:
                onQueryComplete(token, args.cookie, (Cursor) args.result);
                break;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只是调用了onQueryComplete()方法,而onQueryComplete()什么都没做.可以覆写,实现自己的逻辑.&lt;/p&gt;
&lt;h4 id=&#34;asynctask&#34;&gt;AsyncTask&lt;/h4&gt;
&lt;p&gt;对于AsyncTask也是Thread，Handler执行task，只是线程的创建方式，返回值做了修改。&lt;br&gt;
Thread如何获取返回值&lt;br&gt;
一般我们创建线程覆写Thread的run方法，或者是通过runnable接口创建线程，这样不会获取Thread的返回值，而想要获取Thread的返回值，就需要使用Future，callable接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableTest {
    public static void main(String[] args){
        FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;String&amp;gt;(new Callable&amp;lt;String&amp;gt;() {
            @Override
            public String call() throws Exception {
                return &amp;quot;Test&amp;quot;;
            }
        });
        Thread thread = new Thread(futureTask);
        thread.start();
        try {
            String test = futureTask.get();
            System.out.print(test);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;FutureTask实现Future接口
FutureTask中的get()这个方法会产生阻塞，会一直等到任务执行完毕才返回&lt;/p&gt;
&lt;p&gt;使用Executor创建线程&lt;br&gt;
Executor只是Java1.5引入的Executor框架的一个接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public interface Executor {
	     void execute(Runnable command);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以在execute中构造线程池进行创建线程。&lt;/p&gt;
&lt;p&gt;AsyncTask分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FutureTask&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; public AsyncTask() {
        mWorker = new WorkerRunnable&amp;lt;Params, Result&amp;gt;() {
            public Result call() throws Exception {
                mTaskInvoked.set(true);

                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                //noinspection unchecked
                return postResult(doInBackground(mParams));
            }
        };

        mFuture = new FutureTask&amp;lt;Result&amp;gt;(mWorker) {
            @Override
            protected void done() {
	           ......
               postResultIfNotInvoked(get());
			   ......
        };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mWork是WorkerRunnable的实现的对象，WorkerRunnable实现了Callable接口，在call（）方法中，会调用
doInBackground（）处理，然后通过postResult()通知InnerHandler处理消息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private void finish(Result result) {
        if (isCancelled()) {
            onCancelled(result);
        } else {
            onPostExecute(result);
        }
        mStatus = Status.FINISHED;
    }

    private static class InternalHandler extends Handler {
        public InternalHandler() {
            super(Looper.getMainLooper());
        }

        public void handleMessage(Message msg) {
            AsyncTaskResult&amp;lt;?&amp;gt; result = (AsyncTaskResult&amp;lt;?&amp;gt;) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT:
                    // There is only one result
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS:
                    result.mTask.onProgressUpdate(result.mData);
                    break;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于&lt;strong&gt;MESSAGE_POST_RESULT&lt;/strong&gt;消息，会调用&lt;strong&gt;AsyncTask&lt;/strong&gt;的finish（）方法，在finish（）中会调用onPostExecute(result)，可以覆写此方法，来更新界面等操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executor&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;  

public static final Executor SERIAL_EXECUTOR = new SerialExecutor();  

private static class SerialExecutor implements Executor {
    final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) {
            scheduleNext();
        }
    }
    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认的&lt;strong&gt;Executor&lt;/strong&gt;是&lt;strong&gt;sDefaultExecutor&lt;/strong&gt;，  &lt;strong&gt;sDefaultExecutor&lt;/strong&gt;其实是&lt;strong&gt;SERIAL_EXECUTOR&lt;/strong&gt;，而&lt;strong&gt;SERIAL_EXECUTOR&lt;/strong&gt;是&lt;strong&gt;SerialExecutor&lt;/strong&gt;对象,&lt;strong&gt;SerialExecutor&lt;/strong&gt;的executor()方法中会使用&lt;strong&gt;THREAD_POOL_EXECUTOR&lt;/strong&gt;线程池来创建线程。&lt;/p&gt;
&lt;p&gt;THREAD_POOL_EXECUTOR&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public static final Executor THREAD_POOL_EXECUTOR
            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建线程池，其中指出了最大的线程数，最大的队列数，线程工厂对象等。&lt;/p&gt;
&lt;p&gt;AsyncTask运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);
    }  

public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,
        Params... params) {
        .......
        onPreExecute();

        mWorker.mParams = params;
        exec.execute(mFuture);

        return this;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用onPreExecute()，可以覆写此方法，然后在线程运行前做些准备，比如进度条运行等。&lt;br&gt;
然后调用&lt;strong&gt;Executor&lt;/strong&gt;的execute()方法来开始运行线程。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/%E5%A4%96%E5%8A%9F%E6%8B%9B%E5%BC%8F/">外功招式</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android/">Android</category>
                                
                            
                                
                                
                                
                                    <category domain="https://example.com/categories/android%E8%BF%9B%E9%98%B6/">Android进阶</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://example.com/tags/background_jobs/">Background_jobs</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
